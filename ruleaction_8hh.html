<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ruleaction.hh File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">ruleaction.hh File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the basic set of transformation <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode. ">Rule</a> objects.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="action_8hh_source.html">action.hh</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ruleaction.hh:</div>
<div class="dyncontent">
<div class="center"><img src="ruleaction_8hh__incl.png" border="0" usemap="#ruleaction_8hh" alt=""/></div>
<map name="ruleaction_8hh" id="ruleaction_8hh">
<area shape="rect" id="node2" href="action_8hh.html" title="Action, Rule, and other associates classes supporting transformations on function data&#45;flow..." alt="" coords="388,80,463,107"/>
<area shape="rect" id="node3" href="block_8hh.html" title="Classes related to basic blocks and control&#45;flow structuring. " alt="" coords="390,155,461,181"/>
<area shape="rect" id="node4" href="jumptable_8hh.html" title="Classes to support jump&#45;tables and their recovery. " alt="" coords="377,229,473,256"/>
<area shape="rect" id="node5" href="emulateutil_8hh.html" title="(Lightweight) emulation interface for executing PcodeOp objects within a syntax tree or for executing..." alt="" coords="434,304,537,331"/>
<area shape="rect" id="node41" href="rangeutil_8hh.html" title="Documentation for the CircleRange class. " alt="" coords="321,304,410,331"/>
<area shape="rect" id="node6" href="emulate_8hh.html" title="Classes for emulating p&#45;code. " alt="" coords="442,603,529,629"/>
<area shape="rect" id="node30" href="op_8hh.html" title="The PcodeOp and PcodeOpBank classes. " alt="" coords="342,379,397,405"/>
<area shape="rect" id="node7" href="memstate_8hh.html" title="Classes for keeping track of memory state during emulation. " alt="" coords="517,677,616,704"/>
<area shape="rect" id="node28" href="translate_8hh.html" title="Classes for disassembly and pcode generation. " alt="" coords="403,677,493,704"/>
<area shape="rect" id="node8" href="pcoderaw_8hh.html" title="Raw descriptions of varnodes and p&#45;code ops. " alt="" coords="544,752,640,779"/>
<area shape="rect" id="node27" href="loadimage_8hh.html" title="Classes and API for accessing a binary load image. " alt="" coords="421,752,520,779"/>
<area shape="rect" id="node9" href="address_8hh.html" title="Classes for specifying addresses and other low&#45;level constants. " alt="" coords="429,827,515,853"/>
<area shape="rect" id="node25" href="opbehavior_8hh.html" title="Classes for describing the behavior of individual p&#45;code operations. " alt="" coords="541,827,643,853"/>
<area shape="rect" id="node10" href="space_8hh.html" title="Classes for describing address spaces. " alt="" coords="480,901,555,928"/>
<area shape="rect" id="node11" href="error_8hh.html" title="Base class for error handling facilities. " alt="" coords="559,976,625,1003"/>
<area shape="rect" id="node23" href="xml_8hh.html" title="Lightweight (and incomplete) XML parser for marshaling data to and from the decompiler. " alt="" coords="297,976,359,1003"/>
<area shape="rect" id="node12" href="types_8h_source.html" title="types.h" alt="" coords="215,1051,281,1077"/>
<area shape="rect" id="node26" href="opcodes_8hh.html" title="All the individual p&#45;code operations. " alt="" coords="366,901,455,928"/>
<area shape="rect" id="node29" href="float_8hh.html" title="Support for decoding different floating&#45;point formats. " alt="" coords="318,827,383,853"/>
<area shape="rect" id="node31" href="typeop_8hh.html" title="Data&#45;type and behavior information associated with specific p&#45;code op&#45;codes. " alt="" coords="330,453,409,480"/>
<area shape="rect" id="node32" href="cpool_8hh.html" title="Definitions to support a constant pool for deferred compilation languages (i.e. java byte&#45;code) ..." alt="" coords="234,528,305,555"/>
<area shape="rect" id="node34" href="variable_8hh.html" title="Definitions for high&#45;level variables. " alt="" coords="329,528,415,555"/>
<area shape="rect" id="node37" href="printlanguage_8hh.html" title="Classes for printing tokens in a high&#45;level language. " alt="" coords="67,603,184,629"/>
<area shape="rect" id="node33" href="type_8hh.html" title="Classes for describing and printing data&#45;types. " alt="" coords="237,752,302,779"/>
<area shape="rect" id="node35" href="varnode_8hh.html" title="The Varnode and VarnodeBank classes. " alt="" coords="329,603,415,629"/>
<area shape="rect" id="node36" href="cover_8hh.html" title="Classes describing the topological scope of variables within a function. " alt="" coords="307,677,379,704"/>
<area shape="rect" id="node38" href="capability_8hh.html" title="Infrastructure for discovering code extensions to the decompiler. " alt="" coords="115,976,210,1003"/>
<area shape="rect" id="node39" href="cast_8hh.html" title="API and specific strategies for applying type casts. " alt="" coords="43,677,109,704"/>
<area shape="rect" id="node40" href="prettyprint_8hh.html" title="Routines for emitting high&#45;level (C) language syntax in a well formatted way. " alt="" coords="133,677,232,704"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ruleaction_8hh__dep__incl.png" border="0" usemap="#ruleaction_8hhdep" alt=""/></div>
<map name="ruleaction_8hhdep" id="ruleaction_8hhdep">
<area shape="rect" id="node2" href="coreaction_8hh.html" title="Core decompilation actions which are indepedent of any particular architecture. " alt="" coords="5,80,105,107"/>
<area shape="rect" id="node3" href="double_8hh_source.html" title="double.hh" alt="" coords="129,80,208,107"/>
</map>
</div>
</div>
<p><a href="ruleaction_8hh_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddTreeState.html">AddTreeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for sorting out pointer expression trees.  <a href="classAddTreeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleEarlyRemoval.html">RuleEarlyRemoval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rid of unused <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects where we can guarantee the output is unused.  <a href="classRuleEarlyRemoval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleCollectTerms.html">RuleCollectTerms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect terms in a sum: <code>V * c + V * d =&gt; V * (c + d)</code>  <a href="classRuleCollectTerms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSelectCse.html">RuleSelectCse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for common sub-expressions (built out of a restricted set of ops)  <a href="classRuleSelectCse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePiece2Zext.html">RulePiece2Zext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with 0 becomes an extension: <code>V = concat(#0,W) =&gt; V = zext(W)</code>  <a href="classRulePiece2Zext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePiece2Sext.html">RulePiece2Sext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with sign bits becomes an extension: <code>concat( V s&gt;&gt; #0x1f , V) =&gt; sext(V)</code>  <a href="classRulePiece2Sext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBxor2NotEqual.html">RuleBxor2NotEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate BOOL_XOR: <code>V ^^ W =&gt; V != W</code>  <a href="classRuleBxor2NotEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleOrMask.html">RuleOrMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_OR with full mask: <code>V = W | 0xffff =&gt; V = W</code>  <a href="classRuleOrMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAndMask.html">RuleAndMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse unnecessary INT_AND.  <a href="classRuleAndMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleOrConsume.html">RuleOrConsume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply OR with unconsumed input: `V = A | B =&gt; V = B if nzm(A) &amp; consume(V) == 0.  <a href="classRuleOrConsume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleOrCollapse.html">RuleOrCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse unnecessary INT_OR.  <a href="classRuleOrCollapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAndOrLump.html">RuleAndOrLump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constants in logical expressions: <code>(V &amp; c) &amp; d =&gt; V &amp; (c &amp; d)</code>  <a href="classRuleAndOrLump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleNegateIdentity.html">RuleNegateIdentity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply INT_NEGATE identities: <code>V &amp; ~V =&gt; #0, V | ~V -&gt; #-1</code>  <a href="classRuleNegateIdentity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleShiftBitops.html">RuleShiftBitops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifting away all non-zero bits of one-side of a logical/arithmetic op.  <a href="classRuleShiftBitops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleRightShiftAnd.html">RuleRightShiftAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_RIGHT and INT_SRIGHT ops where an INT_AND mask becomes unnecessary.  <a href="classRuleRightShiftAnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleIntLessEqual.html">RuleIntLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert LESSEQUAL to LESS: <code>V &lt;= c =&gt; V &lt; (c+1)</code>  <a href="classRuleIntLessEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleEquality.html">RuleEquality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse INT_EQUAL and INT_NOTEQUAL: <code>f(V,W) == f(V,W) =&gt; true</code>  <a href="classRuleEquality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleTermOrder.html">RuleTermOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order the inputs to commutative operations.  <a href="classRuleTermOrder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePullsubMulti.html">RulePullsubMulti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull SUBPIECE back through MULTIEQUAL.  <a href="classRulePullsubMulti.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePullsubIndirect.html">RulePullsubIndirect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull-back SUBPIECE through INDIRECT.  <a href="classRulePullsubIndirect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePushMulti.html">RulePushMulti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify MULTIEQUAL operations where the branches hold the same value.  <a href="classRulePushMulti.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleNotDistribute.html">RuleNotDistribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute BOOL_NEGATE: <code>!(V &amp;&amp; W) =&gt; !V || !W</code>  <a href="classRuleNotDistribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleHighOrderAnd.html">RuleHighOrderAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_AND when applied to aligned INT_ADD: <code>(V + c) &amp; 0xfff0 =&gt; V + (c &amp; 0xfff0)</code>  <a href="classRuleHighOrderAnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAndDistribute.html">RuleAndDistribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute INT_AND through INT_OR if result is simpler.  <a href="classRuleAndDistribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLessOne.html">RuleLessOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform INT_LESS of 0 or 1: <code>V &lt; 1 =&gt; V == 0, V &lt;= 0 =&gt; V == 0</code>  <a href="classRuleLessOne.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleRangeMeld.html">RuleRangeMeld</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> range conditions of the form: <code>V s&lt; c, c s&lt; V, V == c, V != c</code>  <a href="classRuleRangeMeld.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleFloatRange.html">RuleFloatRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> range conditions of the form: <code>V f&lt; c, c f&lt; V, V f== c</code> etc.  <a href="classRuleFloatRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAndCommute.html">RuleAndCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute INT_AND with INT_LEFT and INT_RIGHT: <code>(V &lt;&lt; W) &amp; d =&gt; (V &amp; (W &gt;&gt; c)) &lt;&lt; c</code>  <a href="classRuleAndCommute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAndPiece.html">RuleAndPiece</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert PIECE to INT_ZEXT where appropriate: <code>V &amp; concat(W,X) =&gt; zext(X)</code>  <a href="classRuleAndPiece.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAndCompare.html">RuleAndCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_ZEXT and SUBPIECE in masked comparison: <code>zext(V) &amp; c == 0 =&gt; V &amp; (c &amp; mask) == 0</code>  <a href="classRuleAndCompare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDoubleSub.html">RuleDoubleSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify chained SUBPIECE: <code>sub( sub(V,c), d) =&gt; sub(V, c+d)</code>  <a href="classRuleDoubleSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDoubleShift.html">RuleDoubleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify chained shifts INT_LEFT and INT_RIGHT.  <a href="classRuleDoubleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDoubleArithShift.html">RuleDoubleArithShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify two sequential INT_SRIGHT: <code>(x s&gt;&gt; #c) s&gt;&gt; #d =&gt; x s&gt;&gt; saturate(#c + #d)</code>  <a href="classRuleDoubleArithShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleConcatShift.html">RuleConcatShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_RIGHT canceling PIECE: <code>concat(V,W) &gt;&gt; c =&gt; zext(V)</code>  <a href="classRuleConcatShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLeftRight.html">RuleLeftRight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform canceling INT_RIGHT or INT_SRIGHT of INT_LEFT.  <a href="classRuleLeftRight.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleShiftCompare.html">RuleShiftCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform shifts in comparisons: <code>V &gt;&gt; c == d =&gt; V == (d &lt;&lt; c)</code>  <a href="classRuleShiftCompare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLessEqual.html">RuleLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify 'less than or equal': <code>V &lt; W || V == W =&gt; V &lt;= W</code>  <a href="classRuleLessEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLessNotEqual.html">RuleLessNotEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_LESSEQUAL &amp;&amp; INT_NOTEQUAL: <code>V &lt;= W &amp;&amp; V != W =&gt; V &lt; W</code>  <a href="classRuleLessNotEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleTrivialArith.html">RuleTrivialArith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify trivial arithmetic expressions.  <a href="classRuleTrivialArith.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleTrivialBool.html">RuleTrivialBool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify boolean expressions when one side is constant.  <a href="classRuleTrivialBool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleZextEliminate.html">RuleZextEliminate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_ZEXT in comparisons: <code>zext(V) == c =&gt; V == c</code>  <a href="classRuleZextEliminate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSlessToLess.html">RuleSlessToLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_SLESS to INT_LESS when comparing positive values.  <a href="classRuleSlessToLess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleZextSless.html">RuleZextSless</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform INT_ZEXT and INT_SLESS: <code>zext(V) s&lt; c =&gt; V &lt; c</code>  <a href="classRuleZextSless.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBitUndistribute.html">RuleBitUndistribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo distributed operations through INT_AND, INT_OR, and INT_XOR.  <a href="classRuleBitUndistribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBooleanNegate.html">RuleBooleanNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify comparisons with boolean values: <code>V == false =&gt; !V, V == true =&gt; V</code>  <a href="classRuleBooleanNegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBoolZext.html">RuleBoolZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify boolean expressions of the form zext(V) * -1.  <a href="classRuleBoolZext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLogic2Bool.html">RuleLogic2Bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert logical to boolean operations: <code>V &amp; W =&gt; V &amp;&amp; W, V | W =&gt; V || W</code>  <a href="classRuleLogic2Bool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleIndirectCollapse.html">RuleIndirectCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a CPUI_INDIRECT if its blocking <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is dead.  <a href="classRuleIndirectCollapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleMultiCollapse.html">RuleMultiCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse MULTIEQUAL whose inputs all trace to the same value.  <a href="classRuleMultiCollapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSborrow.html">RuleSborrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify signed comparisons using INT_SBORROW.  <a href="classRuleSborrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleTrivialShift.html">RuleTrivialShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify trivial shifts: <code>V &lt;&lt; 0 =&gt; V, V &lt;&lt; #64 =&gt; 0</code>  <a href="classRuleTrivialShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSignShift.html">RuleSignShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize sign-bit extraction: <code>V &gt;&gt; 0x1f =&gt; (V s&gt;&gt; 0x1f) * -1</code>  <a href="classRuleSignShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleTestSign.html">RuleTestSign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sign-bit test to signed comparison: <code>(V s&gt;&gt; 0x1f) != 0 =&gt; V s&lt; 0</code>  <a href="classRuleTestSign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleIdentityEl.html">RuleIdentityEl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse operations using identity element: <code>V + 0 =&gt; V</code>  <a href="classRuleIdentityEl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleShift2Mult.html">RuleShift2Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_LEFT to INT_MULT: <code>V &lt;&lt; 2 =&gt; V * 4</code>  <a href="classRuleShift2Mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleShiftPiece.html">RuleShiftPiece</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert "shift and add" to PIECE: (zext(V) &lt;&lt; 16) + zext(W) =&gt; concat(V,W)  <a href="classRuleShiftPiece.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleCollapseConstants.html">RuleCollapseConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constant expressions.  <a href="classRuleCollapseConstants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleTransformCpool.html">RuleTransformCpool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform CPOOLREF operations by looking up the value in the constant pool.  <a href="classRuleTransformCpool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePropagateCopy.html">RulePropagateCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate the input of a COPY to all the places that read the output.  <a href="classRulePropagateCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRule2Comp2Mult.html">Rule2Comp2Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_2COMP: <code>-V =&gt; V * -1</code>  <a href="classRule2Comp2Mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleCarryElim.html">RuleCarryElim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform INT_CARRY using a constant: <code>carry(V,c) =&gt; -c &lt;= V</code>  <a href="classRuleCarryElim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSub2Add.html">RuleSub2Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_SUB: <code>V - W =&gt; V + W * -1</code>  <a href="classRuleSub2Add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleXorCollapse.html">RuleXorCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate INT_XOR in comparisons: <code>(V ^ W) == 0 =&gt; V == W</code>  <a href="classRuleXorCollapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAddMultCollapse.html">RuleAddMultCollapse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse constants in an additive or multiplicative expression.  <a href="classRuleAddMultCollapse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLoadVarnode.html">RuleLoadVarnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert LOAD operations using a constant offset to COPY.  <a href="classRuleLoadVarnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleStoreVarnode.html">RuleStoreVarnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert STORE operations using a constant offset to COPY.  <a href="classRuleStoreVarnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubExtComm.html">RuleSubExtComm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute SUBPIECE and INT_ZEXT: <code>sub(zext(V),c) =&gt; zext(sub(V,c))</code>  <a href="classRuleSubExtComm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubCommute.html">RuleSubCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute SUBPIECE operations with earlier operations where possible.  <a href="classRuleSubCommute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleConcatCommute.html">RuleConcatCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute PIECE with INT_AND, INT_OR, and INT_XOR.  <a href="classRuleConcatCommute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleConcatZext.html">RuleConcatZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute PIECE with INT_ZEXT: <code>concat(zext(V),W) =&gt; zext(concat(V,W))</code>  <a href="classRuleConcatZext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleZextCommute.html">RuleZextCommute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commute INT_ZEXT with INT_RIGHT: <code>zext(V) &gt;&gt; W =&gt; zext(V &gt;&gt; W)</code>  <a href="classRuleZextCommute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleZextShiftZext.html">RuleZextShiftZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify multiple INT_ZEXT operations: <code>zext( zext(V) &lt;&lt; c ) =&gt; zext(V) &lt;&lt; c</code>  <a href="classRuleZextShiftZext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleShiftAnd.html">RuleShiftAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate any INT_AND when the bits it zeroes out are discarded by a shift.  <a href="classRuleShiftAnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleConcatZero.html">RuleConcatZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify concatenation with zero: <code>concat(V,0) =&gt; zext(V) &lt;&lt; c</code>  <a href="classRuleConcatZero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleConcatLeftShift.html">RuleConcatLeftShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify concatenation of extended value: <code>concat(V, zext(W) &lt;&lt; c) =&gt; concat( concat(V,W), 0)</code>  <a href="classRuleConcatLeftShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubZext.html">RuleSubZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_ZEXT applied to SUBPIECE expressions.  <a href="classRuleSubZext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubCancel.html">RuleSubCancel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify composition of SUBPIECE with INT_ZEXT or INT_SEXT.  <a href="classRuleSubCancel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleShiftSub.html">RuleShiftSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify SUBPIECE applied to INT_LEFT: <code>sub( V &lt;&lt; 8*c, c) =&gt; sub(V,0)</code>  <a href="classRuleShiftSub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleHumptyDumpty.html">RuleHumptyDumpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify break and rejoin: <code>concat( sub(V,c), sub(V,0) ) =&gt; V</code>  <a href="classRuleHumptyDumpty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDumptyHump.html">RuleDumptyHump</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify join and break apart: <code>sub( concat(V,W), c) =&gt; sub(W,c)</code>  <a href="classRuleDumptyHump.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleHumptyOr.html">RuleHumptyOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify masked pieces INT_ORed together: <code>(V &amp; ff00) | (V &amp; 00ff) =&gt; V</code>  <a href="classRuleHumptyOr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleEmbed.html">RuleEmbed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify PIECE intended as embedding: <code>concat(V, sub(W,0)) =&gt; W &amp; 0xff | (zext(W) &lt;&lt; 8)</code>  <a href="classRuleEmbed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSwitchSingle.html">RuleSwitchSingle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert BRANCHIND with only one computed destination to a BRANCH.  <a href="classRuleSwitchSingle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleCondNegate.html">RuleCondNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip conditions to match structuring cues.  <a href="classRuleCondNegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleBoolNegate.html">RuleBoolNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a set of identities involving BOOL_NEGATE.  <a href="classRuleBoolNegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLess2Zero.html">RuleLess2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_LESS applied to extremal constants.  <a href="classRuleLess2Zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleLessEqual2Zero.html">RuleLessEqual2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_LESSEQUAL applied to extremal constants.  <a href="classRuleLessEqual2Zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSLess2Zero.html">RuleSLess2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_SLESS applied to 0 or -1.  <a href="classRuleSLess2Zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleEqual2Zero.html">RuleEqual2Zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_EQUAL applied to 0: <code>0 == V + W * -1 =&gt; V == W or 0 == V + c =&gt; V == -c</code>  <a href="classRuleEqual2Zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleEqual2Constant.html">RuleEqual2Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_EQUAL applied to arithmetic expressions.  <a href="classRuleEqual2Constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePtrArith.html">RulePtrArith</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pointer arithmetic.  <a href="classRulePtrArith.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleStructOffset0.html">RuleStructOffset0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a LOAD or STORE to the first element of a structure to a PTRSUB.  <a href="classRuleStructOffset0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePushPtr.html">RulePushPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with known pointer data-type to the bottom of its additive expression.  <a href="classRulePushPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePtraddUndo.html">RulePtraddUndo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove PTRADD operations with mismatched data-type information.  <a href="classRulePtraddUndo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePtrsubUndo.html">RulePtrsubUndo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove PTRSUB operations with mismatched data-type information.  <a href="classRulePtrsubUndo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleMultNegOne.html">RuleMultNegOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert INT_2COMP from INT_MULT: <code>V * -1 =&gt; -V</code>  <a href="classRuleMultNegOne.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleAddUnsigned.html">RuleAddUnsigned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert INT_ADD of constants to INT_SUB: <code>V + 0xff... =&gt; V - 0x00...</code>  <a href="classRuleAddUnsigned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRule2Comp2Sub.html">Rule2Comp2Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert INT_ADD back to INT_SUB: <code>V + -W ==&gt; V - W</code>  <a href="classRule2Comp2Sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubRight.html">RuleSubRight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Convert truncation to cast: <code>sub(V,c) =&gt; sub(V&gt;&gt;c*8,0)</code>  <a href="classRuleSubRight.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePtrsubCharConstant.html">RulePtrsubCharConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup: Set-up to print string constants.  <a href="classRulePtrsubCharConstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubNormal.html">RuleSubNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull-back SUBPIECE through INT_RIGHT and INT_SRIGHT.  <a href="classRuleSubNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePositiveDiv.html">RulePositiveDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed division of positive values is unsigned division.  <a href="classRulePositiveDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDivTermAdd.html">RuleDivTermAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions associated with optimized division expressions.  <a href="classRuleDivTermAdd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDivTermAdd2.html">RuleDivTermAdd2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify another expression associated with optimized division.  <a href="classRuleDivTermAdd2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleDivOpt.html">RuleDivOpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_MULT and shift forms into INT_DIV or INT_SDIV.  <a href="classRuleDivOpt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSignDiv2.html">RuleSignDiv2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert INT_SRIGHT form into INT_SDIV: <code>(V + -1*(V s&gt;&gt; 31)) s&gt;&gt; 1 =&gt; V s/ 2</code>  <a href="classRuleSignDiv2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSignForm.html">RuleSignForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize sign extraction: <code>sub(sext(V),c) =&gt; V s&gt;&gt; 31</code>  <a href="classRuleSignForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSignNearMult.html">RuleSignNearMult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify division form: <code>(V + (V s&gt;&gt; 0x1f)&gt;&gt;(32-n)) &amp; (-1&lt;&lt;n) =&gt; (V s/ 2^n) * 2^n</code>  <a href="classRuleSignNearMult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleModOpt.html">RuleModOpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions that optimize INT_REM and INT_SREM.  <a href="classRuleModOpt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSegment.html">RuleSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate constants through a SEGMENTOP.  <a href="classRuleSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubvarAnd.html">RuleSubvarAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SubVariableFlow analysis triggered by INT_AND.  <a href="classRuleSubvarAnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubvarSubpiece.html">RuleSubvarSubpiece</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SubVariableFlow analysis triggered by SUBPIECE.  <a href="classRuleSubvarSubpiece.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSplitFlow.html">RuleSplitFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to detect and split artificially joined Varnodes.  <a href="classRuleSplitFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePtrFlow.html">RulePtrFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects that are carrying or operating on pointers.  <a href="classRulePtrFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubvarCompZero.html">RuleSubvarCompZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="classSubvariableFlow.html" title="Class for shrinking big Varnodes carrying smaller logical values. ">SubvariableFlow</a> analysis triggered by testing of a single bit.  <a href="classRuleSubvarCompZero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubvarShift.html">RuleSubvarShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="classSubvariableFlow.html" title="Class for shrinking big Varnodes carrying smaller logical values. ">SubvariableFlow</a> analysis triggered by INT_RIGHT.  <a href="classRuleSubvarShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubvarZext.html">RuleSubvarZext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="classSubvariableFlow.html" title="Class for shrinking big Varnodes carrying smaller logical values. ">SubvariableFlow</a> analysis triggered by INT_ZEXT.  <a href="classRuleSubvarZext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubvarSext.html">RuleSubvarSext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="classSubvariableFlow.html" title="Class for shrinking big Varnodes carrying smaller logical values. ">SubvariableFlow</a> analysis triggered by INT_SEXT.  <a href="classRuleSubvarSext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleSubfloatConvert.html">RuleSubfloatConvert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="classSubfloatFlow.html" title="Class for tracing changes of precision in floating point variables. ">SubfloatFlow</a> analysis triggered by FLOAT_FLOAT2FLOAT.  <a href="classRuleSubfloatConvert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleNegateNegate.html">RuleNegateNegate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify INT_NEGATE chains: <code>~~V =&gt; V</code>  <a href="classRuleNegateNegate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleConditionalMove.html">RuleConditionalMove</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify various conditional move situations.  <a href="classRuleConditionalMove.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleFloatCast.html">RuleFloatCast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace (casttosmall)(casttobig)V with identity or with single cast.  <a href="classRuleFloatCast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleIgnoreNan.html">RuleIgnoreNan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treat FLOAT_NAN as always evaluating to false.  <a href="classRuleIgnoreNan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleFuncPtrEncoding.html">RuleFuncPtrEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminate ARM/THUMB style masking of the low order bits on function pointers.  <a href="classRuleFuncPtrEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRuleThreeWayCompare.html">RuleThreeWayCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions involving <em>three-way</em> comparisons.  <a href="classRuleThreeWayCompare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePopcountBoolXor.html">RulePopcountBoolXor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify boolean expressions that are combined through POPCOUNT.  <a href="classRulePopcountBoolXor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRulePiecePathology.html">RulePiecePathology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for concatenations with unlikely things to inform return/parameter consumption calculation.  <a href="classRulePiecePathology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the basic set of transformation <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode. ">Rule</a> objects. </p>
<p>Each <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode. ">Rule</a> triggers on a specific localized data-flow configuration. They are generally applied simultaneously from a pool (see <a class="el" href="classActionPool.html" title="A pool of Rules that apply simultaneously. ">ActionPool</a>) and can interact with each other to produce an emergent transformation. The Rules are applied repeatedly until no <a class="el" href="classRule.html" title="Class for performing a single transformation on a PcodeOp or Varnode. ">Rule</a> can make any additional transformations. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
