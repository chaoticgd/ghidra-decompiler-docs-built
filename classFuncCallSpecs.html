<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: FuncCallSpecs Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classFuncCallSpecs-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FuncCallSpecs Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for analyzing parameters to a sub-function call.  
 <a href="classFuncCallSpecs.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fspec_8hh_source.html">fspec.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FuncCallSpecs:</div>
<div class="dyncontent">
<div class="center"><img src="classFuncCallSpecs__inherit__graph.png" border="0" usemap="#FuncCallSpecs_inherit__map" alt="Inheritance graph"/></div>
<map name="FuncCallSpecs_inherit__map" id="FuncCallSpecs_inherit__map">
<area shape="rect" id="node2" href="classFuncProto.html" title="A function prototype. " alt="" coords="19,5,102,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FuncCallSpecs:</div>
<div class="dyncontent">
<div class="center"><img src="classFuncCallSpecs__coll__graph.png" border="0" usemap="#FuncCallSpecs_coll__map" alt="Collaboration graph"/></div>
<map name="FuncCallSpecs_coll__map" id="FuncCallSpecs_coll__map">
<area shape="rect" id="node2" href="classFuncProto.html" title="A function prototype. " alt="" coords="19,5,102,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5f7aaec10dc1e68d73a07eaf4cac2542"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classFuncCallSpecs.html#a5f7aaec10dc1e68d73a07eaf4cac2542a584ec7401809588c22798803bff5b796">offset_unknown</a> = 0xBADBEEF
 }</td></tr>
<tr class="separator:a5f7aaec10dc1e68d73a07eaf4cac2542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a96cbd6a1b0311883aeb840f47e4a0ec7">FuncCallSpecs</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *call_op)</td></tr>
<tr class="memdesc:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct based on CALL or CALLIND.  <a href="#a96cbd6a1b0311883aeb840f47e4a0ec7">More...</a><br /></td></tr>
<tr class="separator:a96cbd6a1b0311883aeb840f47e4a0ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbc2ae7d43e62971751d96cbddf1b32"><td class="memItemLeft" align="right" valign="top"><a id="a9dbc2ae7d43e62971751d96cbddf1b32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9dbc2ae7d43e62971751d96cbddf1b32">setAddress</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a9dbc2ae7d43e62971751d96cbddf1b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (override) the callee's entry address. <br /></td></tr>
<tr class="separator:a9dbc2ae7d43e62971751d96cbddf1b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88ee3058ece9a8b19f4e25566c03121"><td class="memItemLeft" align="right" valign="top"><a id="ad88ee3058ece9a8b19f4e25566c03121"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad88ee3058ece9a8b19f4e25566c03121">getOp</a> (void) const</td></tr>
<tr class="memdesc:ad88ee3058ece9a8b19f4e25566c03121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CALL or CALLIND corresponding to <b>this</b>. <br /></td></tr>
<tr class="separator:ad88ee3058ece9a8b19f4e25566c03121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860b42c7f272e40dae078854e101b6bc"><td class="memItemLeft" align="right" valign="top"><a id="a860b42c7f272e40dae078854e101b6bc"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a860b42c7f272e40dae078854e101b6bc">getFuncdata</a> (void) const</td></tr>
<tr class="memdesc:a860b42c7f272e40dae078854e101b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object associated with the called function. <br /></td></tr>
<tr class="separator:a860b42c7f272e40dae078854e101b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f63fcf31daa5cc5663df227a813f0a"><td class="memItemLeft" align="right" valign="top"><a id="ae2f63fcf31daa5cc5663df227a813f0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae2f63fcf31daa5cc5663df227a813f0a">setFuncdata</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:ae2f63fcf31daa5cc5663df227a813f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object associated with the called function. <br /></td></tr>
<tr class="separator:ae2f63fcf31daa5cc5663df227a813f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649b58eb85cf052096ac32e5ced8607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ac649b58eb85cf052096ac32e5ced8607">clone</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *newop) const</td></tr>
<tr class="memdesc:ac649b58eb85cf052096ac32e5ced8607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone <b>this</b> given the mirrored p-code CALL.  <a href="#ac649b58eb85cf052096ac32e5ced8607">More...</a><br /></td></tr>
<tr class="separator:ac649b58eb85cf052096ac32e5ced8607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5bb2445140cdde864320679ba347b0"><td class="memItemLeft" align="right" valign="top"><a id="a5c5bb2445140cdde864320679ba347b0"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a5c5bb2445140cdde864320679ba347b0">getName</a> (void) const</td></tr>
<tr class="memdesc:a5c5bb2445140cdde864320679ba347b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function name associated with the callee. <br /></td></tr>
<tr class="separator:a5c5bb2445140cdde864320679ba347b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5d18be6037559397af11e6764abbcd"><td class="memItemLeft" align="right" valign="top"><a id="a0a5d18be6037559397af11e6764abbcd"></a>
const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0a5d18be6037559397af11e6764abbcd">getEntryAddress</a> (void) const</td></tr>
<tr class="memdesc:a0a5d18be6037559397af11e6764abbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entry address of the callee. <br /></td></tr>
<tr class="separator:a0a5d18be6037559397af11e6764abbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d9cc82055fdcbc01f0a37ae3a56a01"><td class="memItemLeft" align="right" valign="top"><a id="a41d9cc82055fdcbc01f0a37ae3a56a01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a41d9cc82055fdcbc01f0a37ae3a56a01">setEffectiveExtraPop</a> (int4 epop)</td></tr>
<tr class="memdesc:a41d9cc82055fdcbc01f0a37ae3a56a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specific <em>extrapop</em> associate with <b>this</b> call site. <br /></td></tr>
<tr class="separator:a41d9cc82055fdcbc01f0a37ae3a56a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3352e35ffd4ed59bbc78f4b43c2998"><td class="memItemLeft" align="right" valign="top"><a id="ade3352e35ffd4ed59bbc78f4b43c2998"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ade3352e35ffd4ed59bbc78f4b43c2998">getEffectiveExtraPop</a> (void) const</td></tr>
<tr class="memdesc:ade3352e35ffd4ed59bbc78f4b43c2998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specific <em>extrapop</em> associate with <b>this</b> call site. <br /></td></tr>
<tr class="separator:ade3352e35ffd4ed59bbc78f4b43c2998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8990f080a96809b347656d7331236c5"><td class="memItemLeft" align="right" valign="top"><a id="ad8990f080a96809b347656d7331236c5"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad8990f080a96809b347656d7331236c5">getSpacebaseOffset</a> (void) const</td></tr>
<tr class="memdesc:ad8990f080a96809b347656d7331236c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack-pointer relative offset at the point of <b>this</b> call site. <br /></td></tr>
<tr class="separator:ad8990f080a96809b347656d7331236c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c86fdb931fd085ca45ff39a091552a"><td class="memItemLeft" align="right" valign="top"><a id="ac1c86fdb931fd085ca45ff39a091552a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ac1c86fdb931fd085ca45ff39a091552a">setParamshift</a> (int4 val)</td></tr>
<tr class="memdesc:ac1c86fdb931fd085ca45ff39a091552a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a parameter shift for this call site. <br /></td></tr>
<tr class="separator:ac1c86fdb931fd085ca45ff39a091552a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc330a0897cbe51cd961095d77d7a6f0"><td class="memItemLeft" align="right" valign="top"><a id="adc330a0897cbe51cd961095d77d7a6f0"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#adc330a0897cbe51cd961095d77d7a6f0">getParamshift</a> (void) const</td></tr>
<tr class="memdesc:adc330a0897cbe51cd961095d77d7a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter shift for this call site. <br /></td></tr>
<tr class="separator:adc330a0897cbe51cd961095d77d7a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eae717564dd4884c28623d4a7a7b182"><td class="memItemLeft" align="right" valign="top"><a id="a3eae717564dd4884c28623d4a7a7b182"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a3eae717564dd4884c28623d4a7a7b182">getMatchCallCount</a> (void) const</td></tr>
<tr class="memdesc:a3eae717564dd4884c28623d4a7a7b182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of calls the caller makes to <b>this</b> sub-function. <br /></td></tr>
<tr class="separator:a3eae717564dd4884c28623d4a7a7b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfda84c2a3919927503193ce9595efd6"><td class="memItemLeft" align="right" valign="top"><a id="abfda84c2a3919927503193ce9595efd6"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#abfda84c2a3919927503193ce9595efd6">getStackPlaceholderSlot</a> (void) const</td></tr>
<tr class="memdesc:abfda84c2a3919927503193ce9595efd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the slot of the stack-pointer placeholder. <br /></td></tr>
<tr class="separator:abfda84c2a3919927503193ce9595efd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab398038b75b6f13b865384da3fd143b9"><td class="memItemLeft" align="right" valign="top"><a id="ab398038b75b6f13b865384da3fd143b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab398038b75b6f13b865384da3fd143b9">setStackPlaceholderSlot</a> (int4 slot)</td></tr>
<tr class="memdesc:ab398038b75b6f13b865384da3fd143b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the slot of the stack-pointer placeholder. <br /></td></tr>
<tr class="separator:ab398038b75b6f13b865384da3fd143b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571062bec4389e2602577b6eed10cbf5"><td class="memItemLeft" align="right" valign="top"><a id="a571062bec4389e2602577b6eed10cbf5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a571062bec4389e2602577b6eed10cbf5">clearStackPlaceholderSlot</a> (void)</td></tr>
<tr class="memdesc:a571062bec4389e2602577b6eed10cbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the stack-pointer placeholder. <br /></td></tr>
<tr class="separator:a571062bec4389e2602577b6eed10cbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="memItemLeft" align="right" valign="top"><a id="a0b481b6be0cc41e4f1b35089fc5f192b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a0b481b6be0cc41e4f1b35089fc5f192b">initActiveInput</a> (void)</td></tr>
<tr class="memdesc:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on analysis recovering input parameters. <br /></td></tr>
<tr class="separator:a0b481b6be0cc41e4f1b35089fc5f192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24a93644abe9ee56a9aa86ba4cb0c9f"><td class="memItemLeft" align="right" valign="top"><a id="af24a93644abe9ee56a9aa86ba4cb0c9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#af24a93644abe9ee56a9aa86ba4cb0c9f">clearActiveInput</a> (void)</td></tr>
<tr class="memdesc:af24a93644abe9ee56a9aa86ba4cb0c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off analysis recovering input parameters. <br /></td></tr>
<tr class="separator:af24a93644abe9ee56a9aa86ba4cb0c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87904aacb6678c8bde4c0c2c781db830"><td class="memItemLeft" align="right" valign="top"><a id="a87904aacb6678c8bde4c0c2c781db830"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a87904aacb6678c8bde4c0c2c781db830">initActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a87904aacb6678c8bde4c0c2c781db830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on analysis recovering the return value. <br /></td></tr>
<tr class="separator:a87904aacb6678c8bde4c0c2c781db830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c13854db24718357b5ce7de7802b4ed"><td class="memItemLeft" align="right" valign="top"><a id="a5c13854db24718357b5ce7de7802b4ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a5c13854db24718357b5ce7de7802b4ed">clearActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a5c13854db24718357b5ce7de7802b4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off analysis recovering the return value. <br /></td></tr>
<tr class="separator:a5c13854db24718357b5ce7de7802b4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145c5e63b80ece45a2a4f0fd5949138"><td class="memItemLeft" align="right" valign="top"><a id="a4145c5e63b80ece45a2a4f0fd5949138"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a4145c5e63b80ece45a2a4f0fd5949138">isInputActive</a> (void) const</td></tr>
<tr class="memdesc:a4145c5e63b80ece45a2a4f0fd5949138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if input parameter recovery analysis is active. <br /></td></tr>
<tr class="separator:a4145c5e63b80ece45a2a4f0fd5949138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e8386ebb901a273ef40d8e8430fb57"><td class="memItemLeft" align="right" valign="top"><a id="a81e8386ebb901a273ef40d8e8430fb57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a81e8386ebb901a273ef40d8e8430fb57">isOutputActive</a> (void) const</td></tr>
<tr class="memdesc:a81e8386ebb901a273ef40d8e8430fb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if return value recovery analysis is active. <br /></td></tr>
<tr class="separator:a81e8386ebb901a273ef40d8e8430fb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe07c5f01eaa2171a4d8c4c832910022"><td class="memItemLeft" align="right" valign="top"><a id="abe07c5f01eaa2171a4d8c4c832910022"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#abe07c5f01eaa2171a4d8c4c832910022">setBadJumpTable</a> (bool val)</td></tr>
<tr class="memdesc:abe07c5f01eaa2171a4d8c4c832910022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>call</b> site looked like an indirect jump. <br /></td></tr>
<tr class="separator:abe07c5f01eaa2171a4d8c4c832910022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f1afc18ffb30d43e25b0065823f366"><td class="memItemLeft" align="right" valign="top"><a id="ae9f1afc18ffb30d43e25b0065823f366"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ae9f1afc18ffb30d43e25b0065823f366">isBadJumpTable</a> (void) const</td></tr>
<tr class="memdesc:ae9f1afc18ffb30d43e25b0065823f366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> call site looked like an indirect jump. <br /></td></tr>
<tr class="separator:ae9f1afc18ffb30d43e25b0065823f366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32432a6c7b201dc160ae0b2480a1b8b9"><td class="memItemLeft" align="right" valign="top"><a id="a32432a6c7b201dc160ae0b2480a1b8b9"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a32432a6c7b201dc160ae0b2480a1b8b9">getActiveInput</a> (void)</td></tr>
<tr class="memdesc:a32432a6c7b201dc160ae0b2480a1b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the analysis object for input parameter recovery. <br /></td></tr>
<tr class="separator:a32432a6c7b201dc160ae0b2480a1b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e9a9406614829224612035f28d311"><td class="memItemLeft" align="right" valign="top"><a id="a866e9a9406614829224612035f28d311"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a866e9a9406614829224612035f28d311">getActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a866e9a9406614829224612035f28d311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the analysis object for return value recovery. <br /></td></tr>
<tr class="separator:a866e9a9406614829224612035f28d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808f3d0c962701b6c98bca1792e86908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a808f3d0c962701b6c98bca1792e86908">checkInputJoin</a> (int4 slot1, bool ishislot, <a class="el" href="classVarnode.html">Varnode</a> *vn1, <a class="el" href="classVarnode.html">Varnode</a> *vn2) const</td></tr>
<tr class="memdesc:a808f3d0c962701b6c98bca1792e86908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if adjacent parameter trials can be combined into a single logical parameter.  <a href="#a808f3d0c962701b6c98bca1792e86908">More...</a><br /></td></tr>
<tr class="separator:a808f3d0c962701b6c98bca1792e86908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489441d9d77d08bdf87eff937e8ef5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a489441d9d77d08bdf87eff937e8ef5b8">doInputJoin</a> (int4 slot1, bool ishislot)</td></tr>
<tr class="memdesc:a489441d9d77d08bdf87eff937e8ef5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two parameter trials.  <a href="#a489441d9d77d08bdf87eff937e8ef5b8">More...</a><br /></td></tr>
<tr class="separator:a489441d9d77d08bdf87eff937e8ef5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ceac5e8aadc51220de5db2f178f4a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a57ceac5e8aadc51220de5db2f178f4a2">lateRestriction</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;restrictedProto, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;newinput, <a class="el" href="classVarnode.html">Varnode</a> *&amp;newoutput)</td></tr>
<tr class="memdesc:a57ceac5e8aadc51220de5db2f178f4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <b>this</b> prototype to match a given (more specialized) prototype.  <a href="#a57ceac5e8aadc51220de5db2f178f4a2">More...</a><br /></td></tr>
<tr class="separator:a57ceac5e8aadc51220de5db2f178f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64d557811baf4602afcefb2746f7be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aad64d557811baf4602afcefb2746f7be">deindirect</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classFuncdata.html">Funcdata</a> *newfd)</td></tr>
<tr class="memdesc:aad64d557811baf4602afcefb2746f7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <b>this</b> call site from an indirect to a direct function call.  <a href="#aad64d557811baf4602afcefb2746f7be">More...</a><br /></td></tr>
<tr class="separator:aad64d557811baf4602afcefb2746f7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc0ef657c876530f21a6ae60458eb35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a8bc0ef657c876530f21a6ae60458eb35">forceSet</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;fp)</td></tr>
<tr class="memdesc:a8bc0ef657c876530f21a6ae60458eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a more restrictive prototype on <b>this</b> call site.  <a href="#a8bc0ef657c876530f21a6ae60458eb35">More...</a><br /></td></tr>
<tr class="separator:a8bc0ef657c876530f21a6ae60458eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6a890aaa82deca59ec7c57c92629aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aae6a890aaa82deca59ec7c57c92629aa">insertPcode</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:aae6a890aaa82deca59ec7c57c92629aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject any <em>upon-return</em> p-code at <b>this</b> call site.  <a href="#aae6a890aaa82deca59ec7c57c92629aa">More...</a><br /></td></tr>
<tr class="separator:aae6a890aaa82deca59ec7c57c92629aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2a3f374049dec6fdf0f9d20295305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a5ad2a3f374049dec6fdf0f9d20295305">resolveSpacebaseRelative</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classVarnode.html">Varnode</a> *phvn)</td></tr>
<tr class="memdesc:a5ad2a3f374049dec6fdf0f9d20295305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the stack offset of <b>this</b> call site.  <a href="#a5ad2a3f374049dec6fdf0f9d20295305">More...</a><br /></td></tr>
<tr class="separator:a5ad2a3f374049dec6fdf0f9d20295305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c3231b5c523e491d65f31ddb688cc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad3c3231b5c523e491d65f31ddb688cc1">abortSpacebaseRelative</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:ad3c3231b5c523e491d65f31ddb688cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the attempt to recover the relative stack offset for <b>this</b> function.  <a href="#ad3c3231b5c523e491d65f31ddb688cc1">More...</a><br /></td></tr>
<tr class="separator:ad3c3231b5c523e491d65f31ddb688cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48998cb808c1feedcad257f0984317ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a48998cb808c1feedcad257f0984317ed">finalInputCheck</a> (void)</td></tr>
<tr class="memdesc:a48998cb808c1feedcad257f0984317ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make final activity check on trials that might have been affected by conditional execution.  <a href="#a48998cb808c1feedcad257f0984317ed">More...</a><br /></td></tr>
<tr class="separator:a48998cb808c1feedcad257f0984317ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49917128896eb002c816e361f875943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ab49917128896eb002c816e361f875943">checkInputTrialUse</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classAliasChecker.html">AliasChecker</a> &amp;aliascheck)</td></tr>
<tr class="memdesc:ab49917128896eb002c816e361f875943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if input trials are being actively used.  <a href="#ab49917128896eb002c816e361f875943">More...</a><br /></td></tr>
<tr class="separator:ab49917128896eb002c816e361f875943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78d1aaf5bb0eaa7898003c7aa622d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad78d1aaf5bb0eaa7898003c7aa622d40">checkOutputTrialUse</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;trialvn)</td></tr>
<tr class="memdesc:ad78d1aaf5bb0eaa7898003c7aa622d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark if output trials are being actively used.  <a href="#ad78d1aaf5bb0eaa7898003c7aa622d40">More...</a><br /></td></tr>
<tr class="separator:ad78d1aaf5bb0eaa7898003c7aa622d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a1bb49b65cf036e8bc8b398e549b26a9c">buildInputFromTrials</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final input Varnodes to <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis.  <a href="#a1bb49b65cf036e8bc8b398e549b26a9c">More...</a><br /></td></tr>
<tr class="separator:a1bb49b65cf036e8bc8b398e549b26a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4e65d08439a23cad5656b9c4c71f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9f4e65d08439a23cad5656b9c4c71f4c">buildOutputFromTrials</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;trialvn)</td></tr>
<tr class="memdesc:a9f4e65d08439a23cad5656b9c4c71f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the final output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis of trials.  <a href="#a9f4e65d08439a23cad5656b9c4c71f4c">More...</a><br /></td></tr>
<tr class="separator:a9f4e65d08439a23cad5656b9c4c71f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15bd3498c19455047bf9b6b5af3df5b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#ad15bd3498c19455047bf9b6b5af3df5b">getInputBytesConsumed</a> (int4 slot) const</td></tr>
<tr class="memdesc:ad15bd3498c19455047bf9b6b5af3df5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the estimated number of bytes within the given parameter that are consumed.  <a href="#ad15bd3498c19455047bf9b6b5af3df5b">More...</a><br /></td></tr>
<tr class="separator:ad15bd3498c19455047bf9b6b5af3df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb672e7f2a55179e16d4270143580093"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#acb672e7f2a55179e16d4270143580093">setInputBytesConsumed</a> (int4 slot, int4 val) const</td></tr>
<tr class="memdesc:acb672e7f2a55179e16d4270143580093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the estimated number of bytes within the given parameter that are consumed.  <a href="#acb672e7f2a55179e16d4270143580093">More...</a><br /></td></tr>
<tr class="separator:acb672e7f2a55179e16d4270143580093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="memItemLeft" align="right" valign="top"><a id="aac7bcd5ea5ed14adbe74b4ca4c7e0814"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aac7bcd5ea5ed14adbe74b4ca4c7e0814">paramshiftModifyStart</a> (void)</td></tr>
<tr class="memdesc:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend any extra parameters if a paramshift is required. <br /></td></tr>
<tr class="separator:aac7bcd5ea5ed14adbe74b4ca4c7e0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a01e16ebebb71bdc63fb884c8d0e3b7e3">paramshiftModifyStop</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data)</td></tr>
<tr class="memdesc:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw out any paramshift parameters.  <a href="#a01e16ebebb71bdc63fb884c8d0e3b7e3">More...</a><br /></td></tr>
<tr class="separator:a01e16ebebb71bdc63fb884c8d0e3b7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a11cd8c631ed5b643eaf259b2ae49b"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a37a11cd8c631ed5b643eaf259b2ae49b">hasEffectTranslate</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a37a11cd8c631ed5b643eaf259b2ae49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate type of side-effect for a given storage location (with caller translation)  <a href="#a37a11cd8c631ed5b643eaf259b2ae49b">More...</a><br /></td></tr>
<tr class="separator:a37a11cd8c631ed5b643eaf259b2ae49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classFuncProto"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classFuncProto')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classFuncProto.html">FuncProto</a></td></tr>
<tr class="memitem:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a9c7db7dec63a18a9de97b0ba9f6f42bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9c7db7dec63a18a9de97b0ba9f6f42bd">FuncProto</a> (void)</td></tr>
<tr class="memdesc:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConstructor.html">Constructor</a>. <br /></td></tr>
<tr class="separator:a9c7db7dec63a18a9de97b0ba9f6f42bd inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a142706f5f3c9086635f812501521f3b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a142706f5f3c9086635f812501521f3b4">~FuncProto</a> (void)</td></tr>
<tr class="memdesc:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a142706f5f3c9086635f812501521f3b4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21659d866e78bb27aca67f1cb2df390 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ac21659d866e78bb27aca67f1cb2df390"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac21659d866e78bb27aca67f1cb2df390">getArch</a> (void) const</td></tr>
<tr class="memdesc:ac21659d866e78bb27aca67f1cb2df390 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> owning <b>this</b>. <br /></td></tr>
<tr class="separator:ac21659d866e78bb27aca67f1cb2df390 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">copy</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another function prototype.  <a href="classFuncProto.html#a9bd4f3bc764b11b57f4e71b9d19df27d">More...</a><br /></td></tr>
<tr class="separator:a9bd4f3bc764b11b57f4e71b9d19df27d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ace26c345cdf567de704b24cd99e8a254"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace26c345cdf567de704b24cd99e8a254">copyFlowEffects</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2)</td></tr>
<tr class="memdesc:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy properties that affect data-flow. <br /></td></tr>
<tr class="separator:ace26c345cdf567de704b24cd99e8a254 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b220dc769358d73110df5c60744566b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1b220dc769358d73110df5c60744566b">getPieces</a> (<a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces) const</td></tr>
<tr class="memdesc:a1b220dc769358d73110df5c60744566b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw pieces of the prototype.  <a href="classFuncProto.html#a1b220dc769358d73110df5c60744566b">More...</a><br /></td></tr>
<tr class="separator:a1b220dc769358d73110df5c60744566b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8e6f53c7733c8aa58d9138a8f3add2ce">setPieces</a> (const <a class="el" href="structPrototypePieces.html">PrototypePieces</a> &amp;pieces)</td></tr>
<tr class="memdesc:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> prototype based on raw pieces.  <a href="classFuncProto.html#a8e6f53c7733c8aa58d9138a8f3add2ce">More...</a><br /></td></tr>
<tr class="separator:a8e6f53c7733c8aa58d9138a8f3add2ce inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">setScope</a> (<a class="el" href="classScope.html">Scope</a> *s, const <a class="el" href="classAddress.html">Address</a> &amp;startpoint)</td></tr>
<tr class="memdesc:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a backing symbol <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> for <b>this</b>.  <a href="classFuncProto.html#adc83eddece4cb123d198ad288dfa89bd">More...</a><br /></td></tr>
<tr class="separator:adc83eddece4cb123d198ad288dfa89bd inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699">setInternal</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m, <a class="el" href="classDatatype.html">Datatype</a> *vt)</td></tr>
<tr class="memdesc:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set internal backing storage for <b>this</b>.  <a href="classFuncProto.html#af69f89b0b3c5165e521d33b658599699">More...</a><br /></td></tr>
<tr class="separator:af69f89b0b3c5165e521d33b658599699 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae8c14d15c7296c47deae3433687b1b15">setModel</a> (<a class="el" href="classProtoModel.html">ProtoModel</a> *m)</td></tr>
<tr class="memdesc:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the prototype model for <b>this</b>.  <a href="classFuncProto.html#ae8c14d15c7296c47deae3433687b1b15">More...</a><br /></td></tr>
<tr class="separator:ae8c14d15c7296c47deae3433687b1b15 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccc21837d768462cd2abca84a5ffd59 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a6ccc21837d768462cd2abca84a5ffd59"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6ccc21837d768462cd2abca84a5ffd59">hasModel</a> (void) const</td></tr>
<tr class="memdesc:a6ccc21837d768462cd2abca84a5ffd59 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> prototype have a model. <br /></td></tr>
<tr class="separator:a6ccc21837d768462cd2abca84a5ffd59 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebd3dd7e300e1361977b93c72a8eed inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="afeebd3dd7e300e1361977b93c72a8eed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afeebd3dd7e300e1361977b93c72a8eed">hasMatchingModel</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> *op2) const</td></tr>
<tr class="memdesc:afeebd3dd7e300e1361977b93c72a8eed inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> have a matching model. <br /></td></tr>
<tr class="separator:afeebd3dd7e300e1361977b93c72a8eed inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a86f7c68b557f329ab6193ffadfb768 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a6a86f7c68b557f329ab6193ffadfb768"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6a86f7c68b557f329ab6193ffadfb768">hasMatchingModel</a> (const <a class="el" href="classProtoModel.html">ProtoModel</a> *op2) const</td></tr>
<tr class="memdesc:a6a86f7c68b557f329ab6193ffadfb768 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> use the given model. <br /></td></tr>
<tr class="separator:a6a86f7c68b557f329ab6193ffadfb768 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd50bddd2379651954a05e2015ab907e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="abd50bddd2379651954a05e2015ab907e"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abd50bddd2379651954a05e2015ab907e">getModelName</a> (void) const</td></tr>
<tr class="memdesc:abd50bddd2379651954a05e2015ab907e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the prototype model name. <br /></td></tr>
<tr class="separator:abd50bddd2379651954a05e2015ab907e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36076943e0845125efffbd7d1d1e46ef inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a36076943e0845125efffbd7d1d1e46ef"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a36076943e0845125efffbd7d1d1e46ef">getModelExtraPop</a> (void) const</td></tr>
<tr class="memdesc:a36076943e0845125efffbd7d1d1e46ef inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>extrapop</em> of the prototype model. <br /></td></tr>
<tr class="separator:a36076943e0845125efffbd7d1d1e46ef inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab52f093617d8bd8a67f011ba5a0d324 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="aab52f093617d8bd8a67f011ba5a0d324"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aab52f093617d8bd8a67f011ba5a0d324">isInputLocked</a> (void) const</td></tr>
<tr class="memdesc:aab52f093617d8bd8a67f011ba5a0d324 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are input data-types locked. <br /></td></tr>
<tr class="separator:aab52f093617d8bd8a67f011ba5a0d324 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e57d21d21d08253f67cb201e83c5e4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="aa8e57d21d21d08253f67cb201e83c5e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa8e57d21d21d08253f67cb201e83c5e4">isOutputLocked</a> (void) const</td></tr>
<tr class="memdesc:aa8e57d21d21d08253f67cb201e83c5e4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the output data-type locked. <br /></td></tr>
<tr class="separator:aa8e57d21d21d08253f67cb201e83c5e4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34162359ab3bd910a376bdad196f52e0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a34162359ab3bd910a376bdad196f52e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a34162359ab3bd910a376bdad196f52e0">isModelLocked</a> (void) const</td></tr>
<tr class="memdesc:a34162359ab3bd910a376bdad196f52e0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the prototype model for <b>this</b> locked. <br /></td></tr>
<tr class="separator:a34162359ab3bd910a376bdad196f52e0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac002aea4a1495011c1a577d343755c21 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ac002aea4a1495011c1a577d343755c21"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac002aea4a1495011c1a577d343755c21">isUnknownModel</a> (void) const</td></tr>
<tr class="memdesc:ac002aea4a1495011c1a577d343755c21 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is prototype model officially "unknown". <br /></td></tr>
<tr class="separator:ac002aea4a1495011c1a577d343755c21 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662b2cce15487591fabd9632a335986c inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a662b2cce15487591fabd9632a335986c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a662b2cce15487591fabd9632a335986c">hasCustomStorage</a> (void) const</td></tr>
<tr class="memdesc:a662b2cce15487591fabd9632a335986c inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a "custom" function prototype. <br /></td></tr>
<tr class="separator:a662b2cce15487591fabd9632a335986c inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">setInputLock</a> (bool val)</td></tr>
<tr class="memdesc:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on input parameters.  <a href="classFuncProto.html#a4afe216709633a3b075111d6f1b7148f">More...</a><br /></td></tr>
<tr class="separator:a4afe216709633a3b075111d6f1b7148f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a7593a0880a632bce714a376244ef4f9a">setOutputLock</a> (bool val)</td></tr>
<tr class="memdesc:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the data-type lock on the return value.  <a href="classFuncProto.html#a7593a0880a632bce714a376244ef4f9a">More...</a><br /></td></tr>
<tr class="separator:a7593a0880a632bce714a376244ef4f9a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acc303c449c418dd875319c6f6cd9436f">setModelLock</a> (bool val)</td></tr>
<tr class="memdesc:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the lock on the prototype model for <b>this</b>.  <a href="classFuncProto.html#acc303c449c418dd875319c6f6cd9436f">More...</a><br /></td></tr>
<tr class="separator:acc303c449c418dd875319c6f6cd9436f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1195921be7caf4244970a23b0eafef67 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a1195921be7caf4244970a23b0eafef67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1195921be7caf4244970a23b0eafef67">isInline</a> (void) const</td></tr>
<tr class="memdesc:a1195921be7caf4244970a23b0eafef67 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function get <em>in-lined</em> during decompilation. <br /></td></tr>
<tr class="separator:a1195921be7caf4244970a23b0eafef67 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a843bc3ca11536028c5cb00ce5479182d">setInline</a> (bool val)</td></tr>
<tr class="memdesc:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>in-line</em> setting for functions with <b>this</b> prototype.  <a href="classFuncProto.html#a843bc3ca11536028c5cb00ce5479182d">More...</a><br /></td></tr>
<tr class="separator:a843bc3ca11536028c5cb00ce5479182d inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88af8e37c1ddb25fd9d6d8322ec436c6 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a88af8e37c1ddb25fd9d6d8322ec436c6">getInjectId</a> (void) const</td></tr>
<tr class="memdesc:a88af8e37c1ddb25fd9d6d8322ec436c6 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the injection id associated with <b>this</b>.  <a href="classFuncProto.html#a88af8e37c1ddb25fd9d6d8322ec436c6">More...</a><br /></td></tr>
<tr class="separator:a88af8e37c1ddb25fd9d6d8322ec436c6 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a764c6b7aa6f4718a38df9881666df inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a93a764c6b7aa6f4718a38df9881666df">getReturnBytesConsumed</a> (void) const</td></tr>
<tr class="memdesc:a93a764c6b7aa6f4718a38df9881666df inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an estimate of the number of bytes consumed by callers of <b>this</b> prototype.  <a href="classFuncProto.html#a93a764c6b7aa6f4718a38df9881666df">More...</a><br /></td></tr>
<tr class="separator:a93a764c6b7aa6f4718a38df9881666df inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abd05102695a39cdad0170eeb92884b3a">setReturnBytesConsumed</a> (int4 val)</td></tr>
<tr class="memdesc:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of bytes consumed by callers of <b>this</b>.  <a href="classFuncProto.html#abd05102695a39cdad0170eeb92884b3a">More...</a><br /></td></tr>
<tr class="separator:abd05102695a39cdad0170eeb92884b3a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1510914c66b2201248a6a06d282948 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a2f1510914c66b2201248a6a06d282948"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2f1510914c66b2201248a6a06d282948">isNoReturn</a> (void) const</td></tr>
<tr class="memdesc:a2f1510914c66b2201248a6a06d282948 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a function with <b>this</b> prototype never return. <br /></td></tr>
<tr class="separator:a2f1510914c66b2201248a6a06d282948 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aacaf0bda9b424dfd5c6a28d3a45fb100">setNoReturn</a> (bool val)</td></tr>
<tr class="memdesc:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>no-return</em> setting for functions with <b>this</b> prototype.  <a href="classFuncProto.html#aacaf0bda9b424dfd5c6a28d3a45fb100">More...</a><br /></td></tr>
<tr class="separator:aacaf0bda9b424dfd5c6a28d3a45fb100 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a274b3ff58e50e73e4eaa82cb08bae3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a2a274b3ff58e50e73e4eaa82cb08bae3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2a274b3ff58e50e73e4eaa82cb08bae3">hasThisPointer</a> (void) const</td></tr>
<tr class="memdesc:a2a274b3ff58e50e73e4eaa82cb08bae3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a prototype for a class method, taking a <em>this</em> pointer. <br /></td></tr>
<tr class="separator:a2a274b3ff58e50e73e4eaa82cb08bae3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4b02b22968723dcdb23ba51955e96e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4b4b02b22968723dcdb23ba51955e96e">setThisPointer</a> (bool val)</td></tr>
<tr class="memdesc:a4b4b02b22968723dcdb23ba51955e96e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the <em>this-call</em> setting for <b>this</b> prototype.  <a href="classFuncProto.html#a4b4b02b22968723dcdb23ba51955e96e">More...</a><br /></td></tr>
<tr class="separator:a4b4b02b22968723dcdb23ba51955e96e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007c1b4a9c33831738e3ac9bc283c5a4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a007c1b4a9c33831738e3ac9bc283c5a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a007c1b4a9c33831738e3ac9bc283c5a4">isConstructor</a> (void) const</td></tr>
<tr class="memdesc:a007c1b4a9c33831738e3ac9bc283c5a4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class constructor method. <br /></td></tr>
<tr class="separator:a007c1b4a9c33831738e3ac9bc283c5a4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a1ff2f80e5cf4043147ccd83a863ee83f">setConstructor</a> (bool val)</td></tr>
<tr class="memdesc:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>constructor</em> method.  <a href="classFuncProto.html#a1ff2f80e5cf4043147ccd83a863ee83f">More...</a><br /></td></tr>
<tr class="separator:a1ff2f80e5cf4043147ccd83a863ee83f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed492939de15e4ea60f9970f2ec685ac inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="aed492939de15e4ea60f9970f2ec685ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aed492939de15e4ea60f9970f2ec685ac">isDestructor</a> (void) const</td></tr>
<tr class="memdesc:aed492939de15e4ea60f9970f2ec685ac inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> prototype for a class destructor method. <br /></td></tr>
<tr class="separator:aed492939de15e4ea60f9970f2ec685ac inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa191f5c52ce98ba14ef14f63a763a7da">setDestructor</a> (bool val)</td></tr>
<tr class="memdesc:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> prototype is a <em>destructor</em> method.  <a href="classFuncProto.html#aa191f5c52ce98ba14ef14f63a763a7da">More...</a><br /></td></tr>
<tr class="separator:aa191f5c52ce98ba14ef14f63a763a7da inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeba6c216afa6ad43160d69a10433fab inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="abeba6c216afa6ad43160d69a10433fab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abeba6c216afa6ad43160d69a10433fab">hasInputErrors</a> (void) const</td></tr>
<tr class="memdesc:abeba6c216afa6ad43160d69a10433fab inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect input parameter descriptions. <br /></td></tr>
<tr class="separator:abeba6c216afa6ad43160d69a10433fab inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0306cd7ee2a040dd783bd5e7606370 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ace0306cd7ee2a040dd783bd5e7606370"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace0306cd7ee2a040dd783bd5e7606370">hasOutputErrors</a> (void) const</td></tr>
<tr class="memdesc:ace0306cd7ee2a040dd783bd5e7606370 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has <b>this</b> prototype been marked as having an incorrect return value description. <br /></td></tr>
<tr class="separator:ace0306cd7ee2a040dd783bd5e7606370 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">setInputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the input error setting for <b>this</b> prototype.  <a href="classFuncProto.html#ad5f36aaa3e2d1d7cdc90d101065abbc0">More...</a><br /></td></tr>
<tr class="separator:ad5f36aaa3e2d1d7cdc90d101065abbc0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">setOutputErrors</a> (bool val)</td></tr>
<tr class="memdesc:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the output error setting for <b>this</b> prototype.  <a href="classFuncProto.html#ac8eacd70fbc6e4cd5d694d2ae5b1ed64">More...</a><br /></td></tr>
<tr class="separator:ac8eacd70fbc6e4cd5d694d2ae5b1ed64 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256f0d04256e214c44b653501514c3e0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a256f0d04256e214c44b653501514c3e0"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a256f0d04256e214c44b653501514c3e0">getExtraPop</a> (void) const</td></tr>
<tr class="memdesc:a256f0d04256e214c44b653501514c3e0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the general <em>extrapop</em> setting for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:a256f0d04256e214c44b653501514c3e0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32fa24642ff5423ec167e6f8bca065a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="af32fa24642ff5423ec167e6f8bca065a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af32fa24642ff5423ec167e6f8bca065a">setExtraPop</a> (int4 ep)</td></tr>
<tr class="memdesc:af32fa24642ff5423ec167e6f8bca065a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the general <em>extrapop</em> for <b>this</b> prototype. <br /></td></tr>
<tr class="separator:af32fa24642ff5423ec167e6f8bca065a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68fc3fa0f616ed233026bcb415a1143 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="aa68fc3fa0f616ed233026bcb415a1143"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa68fc3fa0f616ed233026bcb415a1143">getInjectUponEntry</a> (void) const</td></tr>
<tr class="memdesc:aa68fc3fa0f616ed233026bcb415a1143 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any <em>upon-entry</em> injection id (or -1) <br /></td></tr>
<tr class="separator:aa68fc3fa0f616ed233026bcb415a1143 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c835c084a2714801d06d68631aa52ec inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a3c835c084a2714801d06d68631aa52ec"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3c835c084a2714801d06d68631aa52ec">getInjectUponReturn</a> (void) const</td></tr>
<tr class="memdesc:a3c835c084a2714801d06d68631aa52ec inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any <em>upon-return</em> injection id (or -1) <br /></td></tr>
<tr class="separator:a3c835c084a2714801d06d68631aa52ec inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a22889d3a526dce245368b8de9c889529">resolveExtraPop</a> (void)</td></tr>
<tr class="memdesc:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <b>this</b> prototype is locked, calculate the <em>extrapop</em>.  <a href="classFuncProto.html#a22889d3a526dce245368b8de9c889529">More...</a><br /></td></tr>
<tr class="separator:a22889d3a526dce245368b8de9c889529 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ae91eb49088323b42bdb38b83586eea6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ae91eb49088323b42bdb38b83586eea6f">clearUnlockedInput</a> (void)</td></tr>
<tr class="memdesc:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear input parameters that have not been locked. <br /></td></tr>
<tr class="separator:ae91eb49088323b42bdb38b83586eea6f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a3c7428f70c6c7e040b4d090f3efeee08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3c7428f70c6c7e040b4d090f3efeee08">clearUnlockedOutput</a> (void)</td></tr>
<tr class="memdesc:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the return value if it has not been locked. <br /></td></tr>
<tr class="separator:a3c7428f70c6c7e040b4d090f3efeee08 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="af8059930e66577c8906ade2f36f65cce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af8059930e66577c8906ade2f36f65cce">clearInput</a> (void)</td></tr>
<tr class="memdesc:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all input parameters regardless of lock. <br /></td></tr>
<tr class="separator:af8059930e66577c8906ade2f36f65cce inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a0bb585835251e43a5c9f644519e69dc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a0bb585835251e43a5c9f644519e69dc0">cancelInjectId</a> (void)</td></tr>
<tr class="memdesc:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn-off any in-lining for this function. <br /></td></tr>
<tr class="separator:a0bb585835251e43a5c9f644519e69dc0 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afd3b71963b55dd19755eeaccd016c4bf">resolveModel</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active)</td></tr>
<tr class="memdesc:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>this</b> has a <em>merged</em> model, pick the most likely model (from the merged set)  <a href="classFuncProto.html#afd3b71963b55dd19755eeaccd016c4bf">More...</a><br /></td></tr>
<tr class="separator:afd3b71963b55dd19755eeaccd016c4bf inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ef0c088573715372df24ef978bd610 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a06ef0c088573715372df24ef978bd610">deriveInputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const</td></tr>
<tr class="memdesc:a06ef0c088573715372df24ef978bd610 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of input <em>trials</em>, derive the most likely inputs for <b>this</b> prototype.  <a href="classFuncProto.html#a06ef0c088573715372df24ef978bd610">More...</a><br /></td></tr>
<tr class="separator:a06ef0c088573715372df24ef978bd610 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750224dcda509d76d01e3f45a3d38117 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a750224dcda509d76d01e3f45a3d38117">deriveOutputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const</td></tr>
<tr class="memdesc:a750224dcda509d76d01e3f45a3d38117 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of output <em>trials</em>, derive the most likely return value for <b>this</b> prototype.  <a href="classFuncProto.html#a750224dcda509d76d01e3f45a3d38117">More...</a><br /></td></tr>
<tr class="separator:a750224dcda509d76d01e3f45a3d38117 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961837591bf1445a8db9d7604c1e5046 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a961837591bf1445a8db9d7604c1e5046">checkInputJoin</a> (const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz) const</td></tr>
<tr class="memdesc:a961837591bf1445a8db9d7604c1e5046 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given two input storage locations can represent a single logical parameter.  <a href="classFuncProto.html#a961837591bf1445a8db9d7604c1e5046">More...</a><br /></td></tr>
<tr class="separator:a961837591bf1445a8db9d7604c1e5046 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768d557c966fc2f59c8ae0f09777b4fe inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a768d557c966fc2f59c8ae0f09777b4fe">checkInputSplit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 splitpoint) const</td></tr>
<tr class="memdesc:a768d557c966fc2f59c8ae0f09777b4fe inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if it makes sense to split a single storage location into two input parameters.  <a href="classFuncProto.html#a768d557c966fc2f59c8ae0f09777b4fe">More...</a><br /></td></tr>
<tr class="separator:a768d557c966fc2f59c8ae0f09777b4fe inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc40f8c8861c1beab31c8e82a3f1834 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#accc40f8c8861c1beab31c8e82a3f1834">updateInputTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput)</td></tr>
<tr class="memdesc:accc40f8c8861c1beab31c8e82a3f1834 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials.  <a href="classFuncProto.html#accc40f8c8861c1beab31c8e82a3f1834">More...</a><br /></td></tr>
<tr class="separator:accc40f8c8861c1beab31c8e82a3f1834 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa691279b5825bbaa5295c9bdfaa422c inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#afa691279b5825bbaa5295c9bdfaa422c">updateInputNoTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;triallist, <a class="el" href="classParamActive.html">ParamActive</a> *activeinput, <a class="el" href="classTypeFactory.html">TypeFactory</a> *factory)</td></tr>
<tr class="memdesc:afa691279b5825bbaa5295c9bdfaa422c inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update input parameters based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but do not store the data-type.  <a href="classFuncProto.html#afa691279b5825bbaa5295c9bdfaa422c">More...</a><br /></td></tr>
<tr class="separator:afa691279b5825bbaa5295c9bdfaa422c inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305311eb9c25372f66fcdfbfe7b5de98 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a305311eb9c25372f66fcdfbfe7b5de98">updateOutputTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;triallist)</td></tr>
<tr class="memdesc:a305311eb9c25372f66fcdfbfe7b5de98 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials.  <a href="classFuncProto.html#a305311eb9c25372f66fcdfbfe7b5de98">More...</a><br /></td></tr>
<tr class="separator:a305311eb9c25372f66fcdfbfe7b5de98 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593c9f2e1f999a7144f5d6de7c974f70 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a593c9f2e1f999a7144f5d6de7c974f70">updateOutputNoTypes</a> (const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;triallist, <a class="el" href="classTypeFactory.html">TypeFactory</a> *factory)</td></tr>
<tr class="memdesc:a593c9f2e1f999a7144f5d6de7c974f70 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the return value based on <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> trials, but don't store the data-type.  <a href="classFuncProto.html#a593c9f2e1f999a7144f5d6de7c974f70">More...</a><br /></td></tr>
<tr class="separator:a593c9f2e1f999a7144f5d6de7c974f70 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3642f0fc89a8cb1177de4aa230ae45 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abb3642f0fc89a8cb1177de4aa230ae45">updateAllTypes</a> (const vector&lt; string &gt; &amp;namelist, const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> *&gt; &amp;typelist, bool dtdtdt)</td></tr>
<tr class="memdesc:abb3642f0fc89a8cb1177de4aa230ae45 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <b>this</b> entire function prototype based on a list of names and data-types.  <a href="classFuncProto.html#abb3642f0fc89a8cb1177de4aa230ae45">More...</a><br /></td></tr>
<tr class="separator:abb3642f0fc89a8cb1177de4aa230ae45 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9f97f81ec970bcd40d37f093a1765e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a3c9f97f81ec970bcd40d37f093a1765e"></a>
<a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a3c9f97f81ec970bcd40d37f093a1765e">getParam</a> (int4 i) const</td></tr>
<tr class="memdesc:a3c9f97f81ec970bcd40d37f093a1765e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th input parameter. <br /></td></tr>
<tr class="separator:a3c9f97f81ec970bcd40d37f093a1765e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9a8f192846b36ba99ed0464bb10862 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="abc9a8f192846b36ba99ed0464bb10862"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abc9a8f192846b36ba99ed0464bb10862">removeParam</a> (int4 i)</td></tr>
<tr class="memdesc:abc9a8f192846b36ba99ed0464bb10862 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the i-th input parameter. <br /></td></tr>
<tr class="separator:abc9a8f192846b36ba99ed0464bb10862 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8151d0b73aa51650515ba3f26e73e903 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a8151d0b73aa51650515ba3f26e73e903"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a8151d0b73aa51650515ba3f26e73e903">numParams</a> (void) const</td></tr>
<tr class="memdesc:a8151d0b73aa51650515ba3f26e73e903 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of input parameters. <br /></td></tr>
<tr class="separator:a8151d0b73aa51650515ba3f26e73e903 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e6871d7ee764e7c5aa8b10bf47705a inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a92e6871d7ee764e7c5aa8b10bf47705a"></a>
<a class="el" href="classProtoParameter.html">ProtoParameter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a92e6871d7ee764e7c5aa8b10bf47705a">getOutput</a> (void) const</td></tr>
<tr class="memdesc:a92e6871d7ee764e7c5aa8b10bf47705a inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return value. <br /></td></tr>
<tr class="separator:a92e6871d7ee764e7c5aa8b10bf47705a inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad457e79208b6e7f4f030c2c325db1dba inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ad457e79208b6e7f4f030c2c325db1dba"></a>
<a class="el" href="classDatatype.html">Datatype</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad457e79208b6e7f4f030c2c325db1dba">getOutputType</a> (void) const</td></tr>
<tr class="memdesc:ad457e79208b6e7f4f030c2c325db1dba inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return value data-type. <br /></td></tr>
<tr class="separator:ad457e79208b6e7f4f030c2c325db1dba inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bbc6db7bc4ae8105688a0321fa1ae4 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ad8bbc6db7bc4ae8105688a0321fa1ae4"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ad8bbc6db7bc4ae8105688a0321fa1ae4">getLocalRange</a> (void) const</td></tr>
<tr class="memdesc:ad8bbc6db7bc4ae8105688a0321fa1ae4 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of potential local stack variables. <br /></td></tr>
<tr class="separator:ad8bbc6db7bc4ae8105688a0321fa1ae4 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147ea3f4d50df93a0ff16f17ea204ac9 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a147ea3f4d50df93a0ff16f17ea204ac9"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a147ea3f4d50df93a0ff16f17ea204ac9">getParamRange</a> (void) const</td></tr>
<tr class="memdesc:a147ea3f4d50df93a0ff16f17ea204ac9 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of potential stack parameters. <br /></td></tr>
<tr class="separator:a147ea3f4d50df93a0ff16f17ea204ac9 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0c5a60d2cfd70462d8e9f75aa9819 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a2cb0c5a60d2cfd70462d8e9f75aa9819"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2cb0c5a60d2cfd70462d8e9f75aa9819">isStackGrowsNegative</a> (void) const</td></tr>
<tr class="memdesc:a2cb0c5a60d2cfd70462d8e9f75aa9819 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if the stack grows toward smaller addresses. <br /></td></tr>
<tr class="separator:a2cb0c5a60d2cfd70462d8e9f75aa9819 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4e0521c603ad73b2d73ad96f8cb954 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a4f4e0521c603ad73b2d73ad96f8cb954"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4f4e0521c603ad73b2d73ad96f8cb954">isDotdotdot</a> (void) const</td></tr>
<tr class="memdesc:a4f4e0521c603ad73b2d73ad96f8cb954 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> takes a variable number of arguments. <br /></td></tr>
<tr class="separator:a4f4e0521c603ad73b2d73ad96f8cb954 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d237b521223b740d5d052b68966b556 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a6d237b521223b740d5d052b68966b556"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a6d237b521223b740d5d052b68966b556">setDotdotdot</a> (bool val)</td></tr>
<tr class="memdesc:a6d237b521223b740d5d052b68966b556 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> takes variable arguments. <br /></td></tr>
<tr class="separator:a6d237b521223b740d5d052b68966b556 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079e52c493d00604502c27fe6264fe1b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a079e52c493d00604502c27fe6264fe1b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a079e52c493d00604502c27fe6264fe1b">isOverride</a> (void) const</td></tr>
<tr class="memdesc:a079e52c493d00604502c27fe6264fe1b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> is a call site override. <br /></td></tr>
<tr class="separator:a079e52c493d00604502c27fe6264fe1b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827a8f9335cbb8587a566d8e1765d5a2 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a827a8f9335cbb8587a566d8e1765d5a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a827a8f9335cbb8587a566d8e1765d5a2">setOverride</a> (bool val)</td></tr>
<tr class="memdesc:a827a8f9335cbb8587a566d8e1765d5a2 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> is a call site override. <br /></td></tr>
<tr class="separator:a827a8f9335cbb8587a566d8e1765d5a2 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c0e176919bd0ced34e337445c2bf7 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a906c0e176919bd0ced34e337445c2bf7">hasEffect</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a906c0e176919bd0ced34e337445c2bf7 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the effect <b>this</b> has an a given storage location.  <a href="classFuncProto.html#a906c0e176919bd0ced34e337445c2bf7">More...</a><br /></td></tr>
<tr class="separator:a906c0e176919bd0ced34e337445c2bf7 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802de184a6ac675b8f4bb4c4cb47a194 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a802de184a6ac675b8f4bb4c4cb47a194"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a802de184a6ac675b8f4bb4c4cb47a194">effectBegin</a> (void) const</td></tr>
<tr class="memdesc:a802de184a6ac675b8f4bb4c4cb47a194 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to front of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:a802de184a6ac675b8f4bb4c4cb47a194 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75adeed5dd962662f85c69b6104a8d07 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a75adeed5dd962662f85c69b6104a8d07"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a75adeed5dd962662f85c69b6104a8d07">effectEnd</a> (void) const</td></tr>
<tr class="memdesc:a75adeed5dd962662f85c69b6104a8d07 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to end of <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. <br /></td></tr>
<tr class="separator:a75adeed5dd962662f85c69b6104a8d07 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af903eb699778675e96f0d3376b505732 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af903eb699778675e96f0d3376b505732">numLikelyTrash</a> (void) const</td></tr>
<tr class="memdesc:af903eb699778675e96f0d3376b505732 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <em>likely-trash</em> locations.  <a href="classFuncProto.html#af903eb699778675e96f0d3376b505732">More...</a><br /></td></tr>
<tr class="separator:af903eb699778675e96f0d3376b505732 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b7588849b80acc7c1d1ba13cda5f3 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a078b7588849b80acc7c1d1ba13cda5f3">getLikelyTrash</a> (int4 i) const</td></tr>
<tr class="memdesc:a078b7588849b80acc7c1d1ba13cda5f3 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th <em>likely-trash</em> location.  <a href="classFuncProto.html#a078b7588849b80acc7c1d1ba13cda5f3">More...</a><br /></td></tr>
<tr class="separator:a078b7588849b80acc7c1d1ba13cda5f3 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3a9b7304fda4d72942f76ef64d725b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#abb3a9b7304fda4d72942f76ef64d725b">characterizeAsInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:abb3a9b7304fda4d72942f76ef64d725b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be, or could hold, an input parameter.  <a href="classFuncProto.html#abb3a9b7304fda4d72942f76ef64d725b">More...</a><br /></td></tr>
<tr class="separator:abb3a9b7304fda4d72942f76ef64d725b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ed6ca81a4b601ae81f4080a5bf89fa inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a59ed6ca81a4b601ae81f4080a5bf89fa">possibleInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a59ed6ca81a4b601ae81f4080a5bf89fa inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be an input parameter.  <a href="classFuncProto.html#a59ed6ca81a4b601ae81f4080a5bf89fa">More...</a><br /></td></tr>
<tr class="separator:a59ed6ca81a4b601ae81f4080a5bf89fa inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c37f6adddd70f3fd17500dcacd0c92 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a65c37f6adddd70f3fd17500dcacd0c92">possibleOutputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a65c37f6adddd70f3fd17500dcacd0c92 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a given storage location could be a return value.  <a href="classFuncProto.html#a65c37f6adddd70f3fd17500dcacd0c92">More...</a><br /></td></tr>
<tr class="separator:a65c37f6adddd70f3fd17500dcacd0c92 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b4705cc5b9695e8c96e1e9294f0cfb inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a07b4705cc5b9695e8c96e1e9294f0cfb">getMaxInputDelay</a> (void) const</td></tr>
<tr class="memdesc:a07b4705cc5b9695e8c96e1e9294f0cfb inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible input parameters.  <a href="classFuncProto.html#a07b4705cc5b9695e8c96e1e9294f0cfb">More...</a><br /></td></tr>
<tr class="separator:a07b4705cc5b9695e8c96e1e9294f0cfb inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cb1fac9b0d2d2c55d3ff4fa7db5c27 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a79cb1fac9b0d2d2c55d3ff4fa7db5c27">getMaxOutputDelay</a> (void) const</td></tr>
<tr class="memdesc:a79cb1fac9b0d2d2c55d3ff4fa7db5c27 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible return values.  <a href="classFuncProto.html#a79cb1fac9b0d2d2c55d3ff4fa7db5c27">More...</a><br /></td></tr>
<tr class="separator:a79cb1fac9b0d2d2c55d3ff4fa7db5c27 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fe71f261f3593c98efe396973d5775 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#af0fe71f261f3593c98efe396973d5775">unjustifiedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:af0fe71f261f3593c98efe396973d5775 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given storage location looks like an <em>unjustified</em> input parameter.  <a href="classFuncProto.html#af0fe71f261f3593c98efe396973d5775">More...</a><br /></td></tr>
<tr class="separator:af0fe71f261f3593c98efe396973d5775 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a73b8df1756f6945df97319270508 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ace1a73b8df1756f6945df97319270508">assumedInputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:ace1a73b8df1756f6945df97319270508 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing input parameter for the given storage.  <a href="classFuncProto.html#ace1a73b8df1756f6945df97319270508">More...</a><br /></td></tr>
<tr class="separator:ace1a73b8df1756f6945df97319270508 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2550a272235e295512ee5eb7a2674638 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a2550a272235e295512ee5eb7a2674638">assumedOutputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:a2550a272235e295512ee5eb7a2674638 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing return value location for the given storage.  <a href="classFuncProto.html#a2550a272235e295512ee5eb7a2674638">More...</a><br /></td></tr>
<tr class="separator:a2550a272235e295512ee5eb7a2674638 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e92071dcc850f3dc74cd3e5ce85123 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ac2e92071dcc850f3dc74cd3e5ce85123">getBiggestContainedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:ac2e92071dcc850f3dc74cd3e5ce85123 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the biggest potential input parameter contained within the given range.  <a href="classFuncProto.html#ac2e92071dcc850f3dc74cd3e5ce85123">More...</a><br /></td></tr>
<tr class="separator:ac2e92071dcc850f3dc74cd3e5ce85123 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee60788e6d8b4de304e2c5955a393b inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aa5ee60788e6d8b4de304e2c5955a393b">isCompatible</a> (const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;op2) const</td></tr>
<tr class="memdesc:aa5ee60788e6d8b4de304e2c5955a393b inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if <b>this</b> can be safely restricted to match another prototype.  <a href="classFuncProto.html#aa5ee60788e6d8b4de304e2c5955a393b">More...</a><br /></td></tr>
<tr class="separator:aa5ee60788e6d8b4de304e2c5955a393b inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf46f20373d37b4a7cf22201112abb inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="a41cf46f20373d37b4a7cf22201112abb"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a41cf46f20373d37b4a7cf22201112abb">getSpacebase</a> (void) const</td></tr>
<tr class="memdesc:a41cf46f20373d37b4a7cf22201112abb inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>stack</em> address space. <br /></td></tr>
<tr class="separator:a41cf46f20373d37b4a7cf22201112abb inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8d609764a4fd6c38cb0c284f225180 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#acf8d609764a4fd6c38cb0c284f225180">printRaw</a> (const string &amp;funcname, ostream &amp;s) const</td></tr>
<tr class="memdesc:acf8d609764a4fd6c38cb0c284f225180 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <b>this</b> prototype as a single line of text.  <a href="classFuncProto.html#acf8d609764a4fd6c38cb0c284f225180">More...</a><br /></td></tr>
<tr class="separator:acf8d609764a4fd6c38cb0c284f225180 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1c9aa013921f2738ad28dce59867e6 inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#aeb1c9aa013921f2738ad28dce59867e6">getComparableFlags</a> (void) const</td></tr>
<tr class="memdesc:aeb1c9aa013921f2738ad28dce59867e6 inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comparable properties of <b>this</b> prototype.  <a href="classFuncProto.html#aeb1c9aa013921f2738ad28dce59867e6">More...</a><br /></td></tr>
<tr class="separator:aeb1c9aa013921f2738ad28dce59867e6 inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da5ce755480a4eded9bedff2c6e274f inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4da5ce755480a4eded9bedff2c6e274f">saveXml</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a4da5ce755480a4eded9bedff2c6e274f inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <b>this</b> to an XML stream as a &lt;prototype&gt; tag.  <a href="classFuncProto.html#a4da5ce755480a4eded9bedff2c6e274f">More...</a><br /></td></tr>
<tr class="separator:a4da5ce755480a4eded9bedff2c6e274f inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el, <a class="el" href="classArchitecture.html">Architecture</a> *glb)</td></tr>
<tr class="memdesc:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> from an XML stream.  <a href="classFuncProto.html#a4c4f9da74ee904e6abfa195bd843521e">More...</a><br /></td></tr>
<tr class="separator:a4c4f9da74ee904e6abfa195bd843521e inherit pub_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9a59b9321b66bc9f23e69d2ef729258c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a9a59b9321b66bc9f23e69d2ef729258c">findPreexistingWhole</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn1, <a class="el" href="classVarnode.html">Varnode</a> *vn2)</td></tr>
<tr class="memdesc:a9a59b9321b66bc9f23e69d2ef729258c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given two Varnodes are merged into a whole.  <a href="#a9a59b9321b66bc9f23e69d2ef729258c">More...</a><br /></td></tr>
<tr class="separator:a9a59b9321b66bc9f23e69d2ef729258c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#aa1d084c81a9ae8656d7ef79c84398dc8">getFspecFromConst</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="classFspecSpace.html" title="A special space for encoding FuncCallSpecs. ">FspecSpace</a> addresses to the underlying <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> object.  <a href="#aa1d084c81a9ae8656d7ef79c84398dc8">More...</a><br /></td></tr>
<tr class="separator:aa1d084c81a9ae8656d7ef79c84398dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a57f3844d92136d3ab6b67ea9ea316aa7">compareByEntryAddress</a> (const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *a, const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *b)</td></tr>
<tr class="memdesc:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> by function entry address.  <a href="#a57f3844d92136d3ab6b67ea9ea316aa7">More...</a><br /></td></tr>
<tr class="separator:a57f3844d92136d3ab6b67ea9ea316aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f54afae4c596fdde19e8902e3beff71"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncCallSpecs.html#a6f54afae4c596fdde19e8902e3beff71">countMatchingCalls</a> (const vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&gt; &amp;qlst)</td></tr>
<tr class="memdesc:a6f54afae4c596fdde19e8902e3beff71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of times an individual sub-function is called.  <a href="#a6f54afae4c596fdde19e8902e3beff71">More...</a><br /></td></tr>
<tr class="separator:a6f54afae4c596fdde19e8902e3beff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classFuncProto"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classFuncProto')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classFuncProto.html">FuncProto</a></td></tr>
<tr class="memitem:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">paramShift</a> (int4 paramshift)</td></tr>
<tr class="memdesc:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add parameters to the front of the input parameter list.  <a href="classFuncProto.html#a75f9569f65cd6472f80d3e85d8453ced">More...</a><br /></td></tr>
<tr class="separator:a75f9569f65cd6472f80d3e85d8453ced inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a58bea827081d275ae6112df7dce5 inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#a7b7a58bea827081d275ae6112df7dce5">isParamshiftApplied</a> (void) const</td></tr>
<tr class="separator:a7b7a58bea827081d275ae6112df7dce5 inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="memItemLeft" align="right" valign="top"><a id="ab1a494d8691b68a76a56495907ab9f6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncProto.html#ab1a494d8691b68a76a56495907ab9f6d">setParamshiftApplied</a> (bool val)</td></tr>
<tr class="memdesc:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether a parameter shift has been applied. <br /></td></tr>
<tr class="separator:ab1a494d8691b68a76a56495907ab9f6d inherit pro_methods_classFuncProto"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for analyzing parameters to a sub-function call. </p>
<p>This can be viewed as a function prototype that evolves over the course of analysis. It derives off of <a class="el" href="classFuncProto.html" title="A function prototype. ">FuncProto</a> and includes facilities for analyzing data-flow for parameter information. This is the high-level object managing the examination of data-flow to recover a working prototype (<a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a>), holding a stack-pointer placeholder to facilitate stack analysis, and deciding on the working <em>extrapop</em> for the CALL.</p>
<p>A <b>stack-pointer</b> <b>placeholder</b> is a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the input operands of the CALL or CALLIND that is defined by a LOAD from the stack-pointer. By examining the pointer, the exact value of the stack-pointer (relative to its incoming value) can be computed at the point of the CALL. The temporary can arise naturally if stack parameters are a possibility, otherwise a placeholder temporary is artificially inserted into the CALL input. At the time heritage of the stack space is computed, the placeholder is examined to read off the active stack-pointer offset for the CALL and the placeholder is removed. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5f7aaec10dc1e68d73a07eaf4cac2542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7aaec10dc1e68d73a07eaf4cac2542">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f7aaec10dc1e68d73a07eaf4cac2542a584ec7401809588c22798803bff5b796"></a>offset_unknown&#160;</td><td class="fielddoc"><p>"Magic" stack offset indicating the offset is unknown </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a96cbd6a1b0311883aeb840f47e4a0ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cbd6a1b0311883aeb840f47e4a0ec7">&#9670;&nbsp;</a></span>FuncCallSpecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncCallSpecs::FuncCallSpecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>call_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct based on CALL or CALLIND. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_op</td><td>is the representative call site within the data-flow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3c3231b5c523e491d65f31ddb688cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c3231b5c523e491d65f31ddb688cc1">&#9670;&nbsp;</a></span>abortSpacebaseRelative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::abortSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the attempt to recover the relative stack offset for <b>this</b> function. </p>
<p>Any stack-pointer <em>placeholder</em> is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb49b65cf036e8bc8b398e549b26a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb49b65cf036e8bc8b398e549b26a9c">&#9670;&nbsp;</a></span>buildInputFromTrials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::buildInputFromTrials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final input Varnodes to <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis. </p>
<p>Varnodes that don't look like parameters are removed. Parameters that are unreferenced are filled in. Other <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs may be truncated or extended. This prototype itself is unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f4e65d08439a23cad5656b9c4c71f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4e65d08439a23cad5656b9c4c71f4c">&#9670;&nbsp;</a></span>buildOutputFromTrials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::buildOutputFromTrials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the final output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of <b>this</b> CALL based on <a class="el" href="classParamActive.html" title="Container class for ParamTrial objects. ">ParamActive</a> analysis of trials. </p>
<p>If it exists, the active output trial is moved to be the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> of <b>this</b> CALL. If there are two active trials, they are merged as a single output of the CALL. Any INDIRECT ops that were holding the active trials are removed. This prototype itself is unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">trialvn</td><td>is the list of Varnodes associated with trials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a808f3d0c962701b6c98bca1792e86908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808f3d0c962701b6c98bca1792e86908">&#9670;&nbsp;</a></span>checkInputJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::checkInputJoin </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ishislot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if adjacent parameter trials can be combined into a single logical parameter. </p>
<p>A slot must be provided indicating the trial and the only following it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot1</td><td>is the first trial slot </td></tr>
    <tr><td class="paramname">ishislot</td><td>is <b>true</b> if the first slot will be the most significant piece </td></tr>
    <tr><td class="paramname">vn1</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> corresponding to the first trial </td></tr>
    <tr><td class="paramname">vn2</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> corresponding to the second trial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the trials can be combined </dd></dl>

</div>
</div>
<a id="ab49917128896eb002c816e361f875943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49917128896eb002c816e361f875943">&#9670;&nbsp;</a></span>checkInputTrialUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::checkInputTrialUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAliasChecker.html">AliasChecker</a> &amp;&#160;</td>
          <td class="paramname"><em>aliascheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if input trials are being actively used. </p>
<p>Run through each input trial and try to make a determination if the trial is <em>active</em> or not, meaning basically that a write has occurred on the trial with no intervening reads between the write and the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">aliascheck</td><td>holds local aliasing information about the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad78d1aaf5bb0eaa7898003c7aa622d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78d1aaf5bb0eaa7898003c7aa622d40">&#9670;&nbsp;</a></span>checkOutputTrialUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::checkOutputTrialUse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>trialvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark if output trials are being actively used. </p>
<p>Run through each output trial and try to make a determination if the trial is <em>active</em> or not, meaning basically that the first occurrence of a trial after the call is a read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">trialvn</td><td>will hold Varnodes corresponding to the trials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac649b58eb85cf052096ac32e5ced8607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649b58eb85cf052096ac32e5ced8607">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> * FuncCallSpecs::clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>newop</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone <b>this</b> given the mirrored p-code CALL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newop</td><td>replaces the CALL or CALLIND op in the clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> </dd></dl>

</div>
</div>
<a id="a57f3844d92136d3ab6b67ea9ea316aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f3844d92136d3ab6b67ea9ea316aa7">&#9670;&nbsp;</a></span>compareByEntryAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool FuncCallSpecs::compareByEntryAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> by function entry address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td>is the second to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first should be ordered before the second </dd></dl>

</div>
</div>
<a id="a6f54afae4c596fdde19e8902e3beff71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f54afae4c596fdde19e8902e3beff71">&#9670;&nbsp;</a></span>countMatchingCalls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::countMatchingCalls </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>qlst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of times an individual sub-function is called. </p>
<p>Provided a list of all call sites for a calling function, tally the number of calls to the same sub-function. Update the <b>matchCallCount</b> field of each <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qlst</td><td>is the list of call sites (<a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a>) for the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad64d557811baf4602afcefb2746f7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad64d557811baf4602afcefb2746f7be">&#9670;&nbsp;</a></span>deindirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::deindirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>newfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert <b>this</b> call site from an indirect to a direct function call. </p>
<p>This call site must be a CALLIND, and the function that it is actually calling must be provided. The method makes a determination if the current state of data-flow allows converting to the prototype of the new function without dropping information due to inaccurate dead-code elimination. If conversion is safe, it is performed immediately. Otherwise a <em>restart</em> directive issued to force decompilation to restart from scratch (now with the direct function in hand) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">newfd</td><td>is the <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object that we know is the destination of <b>this</b> CALLIND </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489441d9d77d08bdf87eff937e8ef5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489441d9d77d08bdf87eff937e8ef5b8">&#9670;&nbsp;</a></span>doInputJoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::doInputJoin </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ishislot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join two parameter trials. </p>
<p>We assume <a class="el" href="classFuncCallSpecs.html#a808f3d0c962701b6c98bca1792e86908" title="Check if adjacent parameter trials can be combined into a single logical parameter. ">checkInputJoin()</a> has returned <b>true</b>. Perform the join, replacing the given adjacent trials with a single merged parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot1</td><td>is the trial slot of the first trial </td></tr>
    <tr><td class="paramname">ishislot</td><td>is <b>true</b> if the first slot will be the most significant piece </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48998cb808c1feedcad257f0984317ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48998cb808c1feedcad257f0984317ed">&#9670;&nbsp;</a></span>finalInputCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::finalInputCheck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make final activity check on trials that might have been affected by conditional execution. </p>
<p>The activity level a trial may change once conditional execution has been analyzed. This routine (re)checks trials that might be affected by this, which may then be converted to <em>not</em> <em>used</em>. </p>

</div>
</div>
<a id="a9a59b9321b66bc9f23e69d2ef729258c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a59b9321b66bc9f23e69d2ef729258c">&#9670;&nbsp;</a></span>findPreexistingWhole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * FuncCallSpecs::findPreexistingWhole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if given two Varnodes are merged into a whole. </p>
<p>If the Varnodes are merged immediately into a common whole and aren't used for anything else, return the whole <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn1</td><td>is the first given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">vn2</td><td>is the second given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

</div>
</div>
<a id="a8bc0ef657c876530f21a6ae60458eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc0ef657c876530f21a6ae60458eb35">&#9670;&nbsp;</a></span>forceSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::forceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a more restrictive prototype on <b>this</b> call site. </p>
<p>A new prototype must be given, typically recovered from a function pointer data-type that has been propagated to <b>this</b> call site. The method makes a determination if the current state of data-flow allows converting to the new prototype without dropping information due to inaccurate dead-code elimination. If conversion is safe, it is performed immediately. Otherwise a <em>restart</em> directive issued to force decompilation to restart from scratch (now with the new prototype in hand) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">fp</td><td>is the new (more restrictive) function prototype </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d084c81a9ae8656d7ef79c84398dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d084c81a9ae8656d7ef79c84398dc8">&#9670;&nbsp;</a></span>getFspecFromConst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a>* FuncCallSpecs::getFspecFromConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="classFspecSpace.html" title="A special space for encoding FuncCallSpecs. ">FspecSpace</a> addresses to the underlying <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given <em>fspec</em> address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a> object </dd></dl>

</div>
</div>
<a id="ad15bd3498c19455047bf9b6b5af3df5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15bd3498c19455047bf9b6b5af3df5b">&#9670;&nbsp;</a></span>getInputBytesConsumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 FuncCallSpecs::getInputBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the estimated number of bytes within the given parameter that are consumed. </p>
<p>As a function is decompiled, there may hints about how many of the bytes, within the storage location used to pass the parameter, are used by <b>this</b> sub-function. A non-zero value means that that many least significant bytes of the storage location are used. A value of zero means all bytes are presumed used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the slot of the given input parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes used (or 0) </dd></dl>

</div>
</div>
<a id="a37a11cd8c631ed5b643eaf259b2ae49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a11cd8c631ed5b643eaf259b2ae49b">&#9670;&nbsp;</a></span>hasEffectTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint4 FuncCallSpecs::hasEffectTranslate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate type of side-effect for a given storage location (with caller translation) </p>
<p>Stack locations should be provided from the caller's perspective. They are automatically translated to the callee's perspective before making the underlying query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the effect type </dd></dl>

</div>
</div>
<a id="aae6a890aaa82deca59ec7c57c92629aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6a890aaa82deca59ec7c57c92629aa">&#9670;&nbsp;</a></span>insertPcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::insertPcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject any <em>upon-return</em> p-code at <b>this</b> call site. </p>
<p>This function prototype may trigger injection of p-code immediately after the CALL or CALLIND to mimic a portion of the callee that decompilation of the caller otherwise wouldn't see. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ceac5e8aadc51220de5db2f178f4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ceac5e8aadc51220de5db2f178f4a2">&#9670;&nbsp;</a></span>lateRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::lateRestriction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td>
          <td class="paramname"><em>restrictedProto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>newinput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>newoutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <b>this</b> prototype to match a given (more specialized) prototype. </p>
<p>This method assumes that <b>this</b> prototype is in some intermediate state during the parameter recovery process and that a new definitive (locked) prototype is discovered for <b>this</b> call site. This method checks to see if <b>this</b> can be updated to match the new prototype without missing any data-flow. If so, <b>this</b> is updated, and new input and output Varnodes for the CALL are passed back. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restrictedProto</td><td>is the new definitive function prototype </td></tr>
    <tr><td class="paramname">newinput</td><td>will hold the new list of input Varnodes for the CALL </td></tr>
    <tr><td class="paramname">newoutput</td><td>will hold the new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>this</b> can be fully converted </dd></dl>

</div>
</div>
<a id="a01e16ebebb71bdc63fb884c8d0e3b7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e16ebebb71bdc63fb884c8d0e3b7e3">&#9670;&nbsp;</a></span>paramshiftModifyStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::paramshiftModifyStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw out any paramshift parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made </dd></dl>

</div>
</div>
<a id="a5ad2a3f374049dec6fdf0f9d20295305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad2a3f374049dec6fdf0f9d20295305">&#9670;&nbsp;</a></span>resolveSpacebaseRelative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FuncCallSpecs::resolveSpacebaseRelative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>phvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the stack offset of <b>this</b> call site. </p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> must be the input to the CALL in the <em>placeholder</em> slot and must be defined by a COPY from a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the stack space. Calculate the offset of the stack-pointer at the point of <b>this</b> CALL, relative to the incoming stack-pointer value. This can be obtained either be looking at a stack parameter, or if there is no stack parameter, the stack-pointer <em>placeholder</em> can be used. If the <em>placeholder</em> has no other purpose, remove it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the calling function </td></tr>
    <tr><td class="paramname">phvn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the <em>placeholder</em> slot for <b>this</b> CALL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb672e7f2a55179e16d4270143580093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb672e7f2a55179e16d4270143580093">&#9670;&nbsp;</a></span>setInputBytesConsumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FuncCallSpecs::setInputBytesConsumed </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the estimated number of bytes within the given parameter that are consumed. </p>
<p>This provides a hint to the dead code <em>consume</em> algorithm, while examining the calling function, about how the given parameter within the subfunction is used. A non-zero value means that that many least significant bytes of the storage location are used. A value of zero means all bytes are presumed used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the slot of the given input parameter </td></tr>
    <tr><td class="paramname">val</td><td>is the number of bytes consumed (or 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there was a change in the estimate </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fspec_8hh_source.html">fspec.hh</a></li>
<li>fspec.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
