<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Funcdata Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classFuncdata-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Funcdata Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container for data structures associated with a single function.  
 <a href="classFuncdata.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="funcdata_8hh_source.html">funcdata.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aacdd409dd207aaa412afc5726bc86f6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aacdd409dd207aaa412afc5726bc86f6d">Funcdata</a> (const string &amp;nm, <a class="el" href="classScope.html">Scope</a> *conf, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 sz=0)</td></tr>
<tr class="memdesc:aacdd409dd207aaa412afc5726bc86f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConstructor.html">Constructor</a>.  <a href="#aacdd409dd207aaa412afc5726bc86f6d">More...</a><br /></td></tr>
<tr class="separator:aacdd409dd207aaa412afc5726bc86f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4fb40eeb52f948ca7a14187a21c7db"><td class="memItemLeft" align="right" valign="top"><a id="a0b4fb40eeb52f948ca7a14187a21c7db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0b4fb40eeb52f948ca7a14187a21c7db">~Funcdata</a> (void)</td></tr>
<tr class="memdesc:a0b4fb40eeb52f948ca7a14187a21c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a0b4fb40eeb52f948ca7a14187a21c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6ed264ff7e018a4948045186e4af1f"><td class="memItemLeft" align="right" valign="top"><a id="a8c6ed264ff7e018a4948045186e4af1f"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8c6ed264ff7e018a4948045186e4af1f">getName</a> (void) const</td></tr>
<tr class="memdesc:a8c6ed264ff7e018a4948045186e4af1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function's local symbol name. <br /></td></tr>
<tr class="separator:a8c6ed264ff7e018a4948045186e4af1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3357db0b73196679a798903f28cd798"><td class="memItemLeft" align="right" valign="top"><a id="ae3357db0b73196679a798903f28cd798"></a>
const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae3357db0b73196679a798903f28cd798">getAddress</a> (void) const</td></tr>
<tr class="memdesc:ae3357db0b73196679a798903f28cd798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the entry point address. <br /></td></tr>
<tr class="separator:ae3357db0b73196679a798903f28cd798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a1dc8e5675b2d47d085f89c0b97df8"><td class="memItemLeft" align="right" valign="top"><a id="a14a1dc8e5675b2d47d085f89c0b97df8"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a14a1dc8e5675b2d47d085f89c0b97df8">getSize</a> (void) const</td></tr>
<tr class="memdesc:a14a1dc8e5675b2d47d085f89c0b97df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function body size in bytes. <br /></td></tr>
<tr class="separator:a14a1dc8e5675b2d47d085f89c0b97df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b9d753da3c1caf025981ced51c1e96"><td class="memItemLeft" align="right" valign="top"><a id="a47b9d753da3c1caf025981ced51c1e96"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a47b9d753da3c1caf025981ced51c1e96">getArch</a> (void) const</td></tr>
<tr class="memdesc:a47b9d753da3c1caf025981ced51c1e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the program/architecture owning the function. <br /></td></tr>
<tr class="separator:a47b9d753da3c1caf025981ced51c1e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624dc32b7a1a0563bae734de63378139"><td class="memItemLeft" align="right" valign="top"><a id="a624dc32b7a1a0563bae734de63378139"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a624dc32b7a1a0563bae734de63378139">isHighOn</a> (void) const</td></tr>
<tr class="memdesc:a624dc32b7a1a0563bae734de63378139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are high-level variables assigned to Varnodes. <br /></td></tr>
<tr class="separator:a624dc32b7a1a0563bae734de63378139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb26084299205063c0a3d37ddfcc54f"><td class="memItemLeft" align="right" valign="top"><a id="aecb26084299205063c0a3d37ddfcc54f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aecb26084299205063c0a3d37ddfcc54f">isProcStarted</a> (void) const</td></tr>
<tr class="memdesc:aecb26084299205063c0a3d37ddfcc54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has processing of the function started. <br /></td></tr>
<tr class="separator:aecb26084299205063c0a3d37ddfcc54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67b670f722fcb5aa113746f972ab1b7"><td class="memItemLeft" align="right" valign="top"><a id="ac67b670f722fcb5aa113746f972ab1b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac67b670f722fcb5aa113746f972ab1b7">isProcComplete</a> (void) const</td></tr>
<tr class="memdesc:ac67b670f722fcb5aa113746f972ab1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is processing of the function complete. <br /></td></tr>
<tr class="separator:ac67b670f722fcb5aa113746f972ab1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7daf83122a6a2ffff93774466baab26"><td class="memItemLeft" align="right" valign="top"><a id="ae7daf83122a6a2ffff93774466baab26"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae7daf83122a6a2ffff93774466baab26">hasUnreachableBlocks</a> (void) const</td></tr>
<tr class="memdesc:ae7daf83122a6a2ffff93774466baab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did this function exhibit unreachable code. <br /></td></tr>
<tr class="separator:ae7daf83122a6a2ffff93774466baab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddd307891ab537b02195847a5c0cd5"><td class="memItemLeft" align="right" valign="top"><a id="ad1ddd307891ab537b02195847a5c0cd5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad1ddd307891ab537b02195847a5c0cd5">isTypeRecoveryOn</a> (void) const</td></tr>
<tr class="memdesc:ad1ddd307891ab537b02195847a5c0cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has data-type recovery processes started. <br /></td></tr>
<tr class="separator:ad1ddd307891ab537b02195847a5c0cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7d46a9a41bb6057d2ad5334103ebb9"><td class="memItemLeft" align="right" valign="top"><a id="aca7d46a9a41bb6057d2ad5334103ebb9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aca7d46a9a41bb6057d2ad5334103ebb9">hasNoCode</a> (void) const</td></tr>
<tr class="memdesc:aca7d46a9a41bb6057d2ad5334103ebb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> function has no code body. <br /></td></tr>
<tr class="separator:aca7d46a9a41bb6057d2ad5334103ebb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac206ee7731d8f4db960f6daadc8b4"><td class="memItemLeft" align="right" valign="top"><a id="aa9ac206ee7731d8f4db960f6daadc8b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa9ac206ee7731d8f4db960f6daadc8b4">setNoCode</a> (bool val)</td></tr>
<tr class="memdesc:aa9ac206ee7731d8f4db960f6daadc8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> has a body. <br /></td></tr>
<tr class="separator:aa9ac206ee7731d8f4db960f6daadc8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb35795a0a76c0318b5837e6d1d94dc1"><td class="memItemLeft" align="right" valign="top"><a id="acb35795a0a76c0318b5837e6d1d94dc1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#acb35795a0a76c0318b5837e6d1d94dc1">isLanedRegComplete</a> (void) const</td></tr>
<tr class="memdesc:acb35795a0a76c0318b5837e6d1d94dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have potential laned registers been generated. <br /></td></tr>
<tr class="separator:acb35795a0a76c0318b5837e6d1d94dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a0ab8b2257db49bf4aef9cb259c4d"><td class="memItemLeft" align="right" valign="top"><a id="a793a0ab8b2257db49bf4aef9cb259c4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a793a0ab8b2257db49bf4aef9cb259c4d">setLanedRegGenerated</a> (void)</td></tr>
<tr class="memdesc:a793a0ab8b2257db49bf4aef9cb259c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that laned registers have been collected. <br /></td></tr>
<tr class="separator:a793a0ab8b2257db49bf4aef9cb259c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33bb4d59a0125d36710fe80453b9526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac33bb4d59a0125d36710fe80453b9526">setJumptableRecovery</a> (bool val)</td></tr>
<tr class="memdesc:ac33bb4d59a0125d36710fe80453b9526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether <b>this</b> is being used for jump-table recovery.  <a href="#ac33bb4d59a0125d36710fe80453b9526">More...</a><br /></td></tr>
<tr class="separator:ac33bb4d59a0125d36710fe80453b9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4f50447bca9f83a2a8923ff78f9983"><td class="memItemLeft" align="right" valign="top"><a id="a0f4f50447bca9f83a2a8923ff78f9983"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0f4f50447bca9f83a2a8923ff78f9983">isJumptableRecoveryOn</a> (void) const</td></tr>
<tr class="memdesc:a0f4f50447bca9f83a2a8923ff78f9983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> used for jump-table recovery. <br /></td></tr>
<tr class="separator:a0f4f50447bca9f83a2a8923ff78f9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bcddc7a3b959812f9a1660b39cc6ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a23bcddc7a3b959812f9a1660b39cc6ef">setDoublePrecisRecovery</a> (bool val)</td></tr>
<tr class="memdesc:a23bcddc7a3b959812f9a1660b39cc6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether double precision analysis is used.  <a href="#a23bcddc7a3b959812f9a1660b39cc6ef">More...</a><br /></td></tr>
<tr class="separator:a23bcddc7a3b959812f9a1660b39cc6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f5244a2b3edcf7276f0084f7b48281"><td class="memItemLeft" align="right" valign="top"><a id="a34f5244a2b3edcf7276f0084f7b48281"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a34f5244a2b3edcf7276f0084f7b48281">isDoublePrecisOn</a> (void) const</td></tr>
<tr class="memdesc:a34f5244a2b3edcf7276f0084f7b48281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is double precision analysis enabled. <br /></td></tr>
<tr class="separator:a34f5244a2b3edcf7276f0084f7b48281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6840fba2eb01394e02fed1d4b9f77b04"><td class="memItemLeft" align="right" valign="top"><a id="a6840fba2eb01394e02fed1d4b9f77b04"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6840fba2eb01394e02fed1d4b9f77b04">hasNoStructBlocks</a> (void) const</td></tr>
<tr class="memdesc:a6840fba2eb01394e02fed1d4b9f77b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if no block structuring was performed. <br /></td></tr>
<tr class="separator:a6840fba2eb01394e02fed1d4b9f77b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b616d10d9514eda69dd9d974c62eb8"><td class="memItemLeft" align="right" valign="top"><a id="a25b616d10d9514eda69dd9d974c62eb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a25b616d10d9514eda69dd9d974c62eb8">clear</a> (void)</td></tr>
<tr class="memdesc:a25b616d10d9514eda69dd9d974c62eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear out old disassembly. <br /></td></tr>
<tr class="separator:a25b616d10d9514eda69dd9d974c62eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19698f34a432f84d8cbe94f8e0ad20d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a19698f34a432f84d8cbe94f8e0ad20d4">warning</a> (const string &amp;txt, const <a class="el" href="classAddress.html">Address</a> &amp;ad) const</td></tr>
<tr class="memdesc:a19698f34a432f84d8cbe94f8e0ad20d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a warning comment in the function body.  <a href="#a19698f34a432f84d8cbe94f8e0ad20d4">More...</a><br /></td></tr>
<tr class="separator:a19698f34a432f84d8cbe94f8e0ad20d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87967b12187406a7fdf311cc4b836118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a87967b12187406a7fdf311cc4b836118">warningHeader</a> (const string &amp;txt) const</td></tr>
<tr class="memdesc:a87967b12187406a7fdf311cc4b836118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a warning comment as part of the function header.  <a href="#a87967b12187406a7fdf311cc4b836118">More...</a><br /></td></tr>
<tr class="separator:a87967b12187406a7fdf311cc4b836118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0637a2c7f6a1e511284cfeecb4b0d475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0637a2c7f6a1e511284cfeecb4b0d475">startProcessing</a> (void)</td></tr>
<tr class="memdesc:a0637a2c7f6a1e511284cfeecb4b0d475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start processing for this function.  <a href="#a0637a2c7f6a1e511284cfeecb4b0d475">More...</a><br /></td></tr>
<tr class="separator:a0637a2c7f6a1e511284cfeecb4b0d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b7bf9f9ad6a3c56968f4daa9ca27d5"><td class="memItemLeft" align="right" valign="top"><a id="a36b7bf9f9ad6a3c56968f4daa9ca27d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a36b7bf9f9ad6a3c56968f4daa9ca27d5">stopProcessing</a> (void)</td></tr>
<tr class="memdesc:a36b7bf9f9ad6a3c56968f4daa9ca27d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that processing has completed for this function. <br /></td></tr>
<tr class="separator:a36b7bf9f9ad6a3c56968f4daa9ca27d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0add0ec99a303d6cdfc5187bb2c768f7"><td class="memItemLeft" align="right" valign="top"><a id="a0add0ec99a303d6cdfc5187bb2c768f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0add0ec99a303d6cdfc5187bb2c768f7">startTypeRecovery</a> (void)</td></tr>
<tr class="memdesc:a0add0ec99a303d6cdfc5187bb2c768f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that data-type analysis has started. <br /></td></tr>
<tr class="separator:a0add0ec99a303d6cdfc5187bb2c768f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f04b2e649dafbd6384d6a5ad7417290"><td class="memItemLeft" align="right" valign="top"><a id="a5f04b2e649dafbd6384d6a5ad7417290"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5f04b2e649dafbd6384d6a5ad7417290">startCastPhase</a> (void)</td></tr>
<tr class="memdesc:a5f04b2e649dafbd6384d6a5ad7417290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the <b>cast</b> insertion phase. <br /></td></tr>
<tr class="separator:a5f04b2e649dafbd6384d6a5ad7417290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6eb70553bc51e0ed7d2acde1b080ad"><td class="memItemLeft" align="right" valign="top"><a id="a4a6eb70553bc51e0ed7d2acde1b080ad"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4a6eb70553bc51e0ed7d2acde1b080ad">getCastPhaseIndex</a> (void) const</td></tr>
<tr class="memdesc:a4a6eb70553bc51e0ed7d2acde1b080ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation index at the start of <b>cast</b> insertion. <br /></td></tr>
<tr class="separator:a4a6eb70553bc51e0ed7d2acde1b080ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336622e6dcb32a1539d3d98c4115ead8"><td class="memItemLeft" align="right" valign="top"><a id="a336622e6dcb32a1539d3d98c4115ead8"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a336622e6dcb32a1539d3d98c4115ead8">getHighLevelIndex</a> (void) const</td></tr>
<tr class="memdesc:a336622e6dcb32a1539d3d98c4115ead8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation index at the start of <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> creation. <br /></td></tr>
<tr class="separator:a336622e6dcb32a1539d3d98c4115ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e446945c2081176890607173cbb461"><td class="memItemLeft" align="right" valign="top"><a id="a29e446945c2081176890607173cbb461"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a29e446945c2081176890607173cbb461">startCleanUp</a> (void)</td></tr>
<tr class="memdesc:a29e446945c2081176890607173cbb461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start <em>clean-up</em> phase. <br /></td></tr>
<tr class="separator:a29e446945c2081176890607173cbb461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960bb129d667590b2f3eb73b99984954"><td class="memItemLeft" align="right" valign="top"><a id="a960bb129d667590b2f3eb73b99984954"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a960bb129d667590b2f3eb73b99984954">getCleanUpIndex</a> (void) const</td></tr>
<tr class="memdesc:a960bb129d667590b2f3eb73b99984954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creation index at the start of <b>clean-up</b> phase. <br /></td></tr>
<tr class="separator:a960bb129d667590b2f3eb73b99984954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b3b1d1d751868c394eda804afa0bc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a91b3b1d1d751868c394eda804afa0bc8">followFlow</a> (const <a class="el" href="classAddress.html">Address</a> &amp;baddr, const <a class="el" href="classAddress.html">Address</a> &amp;eadddr, uint4 insn_max)</td></tr>
<tr class="memdesc:a91b3b1d1d751868c394eda804afa0bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate raw p-code for the function.  <a href="#a91b3b1d1d751868c394eda804afa0bc8">More...</a><br /></td></tr>
<tr class="separator:a91b3b1d1d751868c394eda804afa0bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122718ad87c13b714676c61050461388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a122718ad87c13b714676c61050461388">truncatedFlow</a> (const <a class="el" href="classFuncdata.html">Funcdata</a> *fd, const <a class="el" href="classFlowInfo.html">FlowInfo</a> *flow)</td></tr>
<tr class="memdesc:a122718ad87c13b714676c61050461388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a clone with truncated control-flow given a partial function.  <a href="#a122718ad87c13b714676c61050461388">More...</a><br /></td></tr>
<tr class="separator:a122718ad87c13b714676c61050461388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc11dc2a2eefa48bc4b244094a521f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3bcc11dc2a2eefa48bc4b244094a521f">inlineFlow</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *inlinefd, <a class="el" href="classFlowInfo.html">FlowInfo</a> &amp;flow, <a class="el" href="classPcodeOp.html">PcodeOp</a> *callop)</td></tr>
<tr class="memdesc:a3bcc11dc2a2eefa48bc4b244094a521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-line the p-code from another function into <b>this</b> function.  <a href="#a3bcc11dc2a2eefa48bc4b244094a521f">More...</a><br /></td></tr>
<tr class="separator:a3bcc11dc2a2eefa48bc4b244094a521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb83719ca201b5d57283058e2bcadee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aafb83719ca201b5d57283058e2bcadee">overrideFlow</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, uint4 type)</td></tr>
<tr class="memdesc:aafb83719ca201b5d57283058e2bcadee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> the control-flow p-code for a particular instruction.  <a href="#aafb83719ca201b5d57283058e2bcadee">More...</a><br /></td></tr>
<tr class="separator:aafb83719ca201b5d57283058e2bcadee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f9cac25647eca390a509d98f76b9ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a08f9cac25647eca390a509d98f76b9ac">doLiveInject</a> (<a class="el" href="classInjectPayload.html">InjectPayload</a> *payload, const <a class="el" href="classAddress.html">Address</a> &amp;addr, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> *&gt;::iterator pos)</td></tr>
<tr class="memdesc:a08f9cac25647eca390a509d98f76b9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject p-code from a <em>payload</em> into <b>this</b> live function.  <a href="#a08f9cac25647eca390a509d98f76b9ac">More...</a><br /></td></tr>
<tr class="separator:a08f9cac25647eca390a509d98f76b9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3cdbf385c382c10fc5b48f5842b418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9a3cdbf385c382c10fc5b48f5842b418">printRaw</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a9a3cdbf385c382c10fc5b48f5842b418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print raw p-code op descriptions to a stream.  <a href="#a9a3cdbf385c382c10fc5b48f5842b418">More...</a><br /></td></tr>
<tr class="separator:a9a3cdbf385c382c10fc5b48f5842b418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac150948163b641a4d138ef82bf213f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac150948163b641a4d138ef82bf213f4e">printVarnodeTree</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:ac150948163b641a4d138ef82bf213f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of all Varnodes to a stream.  <a href="#ac150948163b641a4d138ef82bf213f4e">More...</a><br /></td></tr>
<tr class="separator:ac150948163b641a4d138ef82bf213f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c86861b22f4beb1cac5ab3ab43db6ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8c86861b22f4beb1cac5ab3ab43db6ae">printBlockTree</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a8c86861b22f4beb1cac5ab3ab43db6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a description of control-flow structuring to a stream.  <a href="#a8c86861b22f4beb1cac5ab3ab43db6ae">More...</a><br /></td></tr>
<tr class="separator:a8c86861b22f4beb1cac5ab3ab43db6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b52d8ec8b53529b02881977971067ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2b52d8ec8b53529b02881977971067ce">printLocalRange</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a2b52d8ec8b53529b02881977971067ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print description of memory ranges associated with local scopes.  <a href="#a2b52d8ec8b53529b02881977971067ce">More...</a><br /></td></tr>
<tr class="separator:a2b52d8ec8b53529b02881977971067ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e7664bd70368066f7ad70a8922795e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac8e7664bd70368066f7ad70a8922795e">saveXml</a> (ostream &amp;s, uint8 id, bool savetree) const</td></tr>
<tr class="memdesc:ac8e7664bd70368066f7ad70a8922795e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an XML description of <b>this</b> function to stream.  <a href="#ac8e7664bd70368066f7ad70a8922795e">More...</a><br /></td></tr>
<tr class="separator:ac8e7664bd70368066f7ad70a8922795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7419de8057421b8e9300c4a26c60ecef"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7419de8057421b8e9300c4a26c60ecef">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a7419de8057421b8e9300c4a26c60ecef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the state of <b>this</b> function from an XML description.  <a href="#a7419de8057421b8e9300c4a26c60ecef">More...</a><br /></td></tr>
<tr class="separator:a7419de8057421b8e9300c4a26c60ecef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2d5d66f0ae7c5c4eae20d60ad30897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5f2d5d66f0ae7c5c4eae20d60ad30897">saveXmlJumpTable</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a5f2d5d66f0ae7c5c4eae20d60ad30897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an XML description of jump-tables to stream.  <a href="#a5f2d5d66f0ae7c5c4eae20d60ad30897">More...</a><br /></td></tr>
<tr class="separator:a5f2d5d66f0ae7c5c4eae20d60ad30897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a41bb91dd51c9a76d8f6d1e2f09328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a07a41bb91dd51c9a76d8f6d1e2f09328">restoreXmlJumpTable</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a07a41bb91dd51c9a76d8f6d1e2f09328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore jump-tables from an XML description.  <a href="#a07a41bb91dd51c9a76d8f6d1e2f09328">More...</a><br /></td></tr>
<tr class="separator:a07a41bb91dd51c9a76d8f6d1e2f09328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7630153130424a56fac5a4b4a4792b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7630153130424a56fac5a4b4a4792b60">saveXmlTree</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:a7630153130424a56fac5a4b4a4792b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an XML description of the p-code tree to stream.  <a href="#a7630153130424a56fac5a4b4a4792b60">More...</a><br /></td></tr>
<tr class="separator:a7630153130424a56fac5a4b4a4792b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accde64f2642f6e86545df826e2751f8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#accde64f2642f6e86545df826e2751f8b">saveXmlHigh</a> (ostream &amp;s) const</td></tr>
<tr class="memdesc:accde64f2642f6e86545df826e2751f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an XML description of all HighVariables to stream.  <a href="#accde64f2642f6e86545df826e2751f8b">More...</a><br /></td></tr>
<tr class="separator:accde64f2642f6e86545df826e2751f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48d087ed5fbf901cfa608d8f44b6d5c"><td class="memItemLeft" align="right" valign="top"><a id="ac48d087ed5fbf901cfa608d8f44b6d5c"></a>
<a class="el" href="classOverride.html">Override</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac48d087ed5fbf901cfa608d8f44b6d5c">getOverride</a> (void)</td></tr>
<tr class="memdesc:ac48d087ed5fbf901cfa608d8f44b6d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> object for <b>this</b> function. <br /></td></tr>
<tr class="separator:ac48d087ed5fbf901cfa608d8f44b6d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21c852eb9f606c5cd19fb2456927ecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af21c852eb9f606c5cd19fb2456927ecd">setRestartPending</a> (bool val)</td></tr>
<tr class="memdesc:af21c852eb9f606c5cd19fb2456927ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle whether analysis needs to be restarted for <b>this</b> function.  <a href="#af21c852eb9f606c5cd19fb2456927ecd">More...</a><br /></td></tr>
<tr class="separator:af21c852eb9f606c5cd19fb2456927ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae349f4a44febd9dd27ca63f7f8840103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae349f4a44febd9dd27ca63f7f8840103">hasRestartPending</a> (void) const</td></tr>
<tr class="memdesc:ae349f4a44febd9dd27ca63f7f8840103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> function need to restart its analysis.  <a href="#ae349f4a44febd9dd27ca63f7f8840103">More...</a><br /></td></tr>
<tr class="separator:ae349f4a44febd9dd27ca63f7f8840103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef27da9040d28296accaaa1c1982401"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afef27da9040d28296accaaa1c1982401">hasUnimplemented</a> (void) const</td></tr>
<tr class="memdesc:afef27da9040d28296accaaa1c1982401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> function have instructions marked as <em>unimplemented</em>.  <a href="#afef27da9040d28296accaaa1c1982401">More...</a><br /></td></tr>
<tr class="separator:afef27da9040d28296accaaa1c1982401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1556d4d7cd4c30e0f8b009fc90a50e"><td class="memItemLeft" align="right" valign="top"><a id="a4d1556d4d7cd4c30e0f8b009fc90a50e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4d1556d4d7cd4c30e0f8b009fc90a50e">hasBadData</a> (void) const</td></tr>
<tr class="memdesc:a4d1556d4d7cd4c30e0f8b009fc90a50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <b>this</b> function flow into bad data. <br /></td></tr>
<tr class="separator:a4d1556d4d7cd4c30e0f8b009fc90a50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96433773ee0126ce9a25b0970a6ef513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a96433773ee0126ce9a25b0970a6ef513">spacebase</a> (void)</td></tr>
<tr class="memdesc:a96433773ee0126ce9a25b0970a6ef513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark registers that map to a virtual address space.  <a href="#a96433773ee0126ce9a25b0970a6ef513">More...</a><br /></td></tr>
<tr class="separator:a96433773ee0126ce9a25b0970a6ef513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac083b7d6637a5883ef8cbd38e7756837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac083b7d6637a5883ef8cbd38e7756837">newSpacebasePtr</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id)</td></tr>
<tr class="memdesc:ac083b7d6637a5883ef8cbd38e7756837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <em>spacebase</em> register for a given address space.  <a href="#ac083b7d6637a5883ef8cbd38e7756837">More...</a><br /></td></tr>
<tr class="separator:ac083b7d6637a5883ef8cbd38e7756837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eee1ea3fa8e72d17549a936567c97bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1eee1ea3fa8e72d17549a936567c97bf">findSpacebaseInput</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id) const</td></tr>
<tr class="separator:a1eee1ea3fa8e72d17549a936567c97bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4a89f4e3da37a4107992689f7b89ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aaf4a89f4e3da37a4107992689f7b89ff">spacebaseConstant</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot, <a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, const <a class="el" href="classAddress.html">Address</a> &amp;rampoint, uintb origval, int4 origsize)</td></tr>
<tr class="memdesc:aaf4a89f4e3da37a4107992689f7b89ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a constant pointer into a <em>ram</em> CPUI_PTRSUB.  <a href="#aaf4a89f4e3da37a4107992689f7b89ff">More...</a><br /></td></tr>
<tr class="separator:aaf4a89f4e3da37a4107992689f7b89ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363bd02cb2f20cf1583951d5429a057b"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a363bd02cb2f20cf1583951d5429a057b">numHeritagePasses</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a363bd02cb2f20cf1583951d5429a057b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of heritage passes performed for the given address space.  <a href="#a363bd02cb2f20cf1583951d5429a057b">More...</a><br /></td></tr>
<tr class="separator:a363bd02cb2f20cf1583951d5429a057b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0c8b4dab63367913749e68fbd33789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adc0c8b4dab63367913749e68fbd33789">seenDeadcode</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:adc0c8b4dab63367913749e68fbd33789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that dead Varnodes have been seen in a specific address space.  <a href="#adc0c8b4dab63367913749e68fbd33789">More...</a><br /></td></tr>
<tr class="separator:adc0c8b4dab63367913749e68fbd33789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40aef88ca7a101e4697df5e0ec5f605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac40aef88ca7a101e4697df5e0ec5f605">setDeadCodeDelay</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 delay)</td></tr>
<tr class="memdesc:ac40aef88ca7a101e4697df5e0ec5f605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a delay before removing dead code for a specific address space.  <a href="#ac40aef88ca7a101e4697df5e0ec5f605">More...</a><br /></td></tr>
<tr class="separator:ac40aef88ca7a101e4697df5e0ec5f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf432bbbd299e976c8f02fc97fb3dbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adaf432bbbd299e976c8f02fc97fb3dbe">deadRemovalAllowed</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const</td></tr>
<tr class="memdesc:adaf432bbbd299e976c8f02fc97fb3dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if dead code removal is allowed for a specific address space.  <a href="#adaf432bbbd299e976c8f02fc97fb3dbe">More...</a><br /></td></tr>
<tr class="separator:adaf432bbbd299e976c8f02fc97fb3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba7696040378f0eaa679e684b72bf96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adba7696040378f0eaa679e684b72bf96">deadRemovalAllowedSeen</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:adba7696040378f0eaa679e684b72bf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if dead Varnodes have been removed for a specific address space.  <a href="#adba7696040378f0eaa679e684b72bf96">More...</a><br /></td></tr>
<tr class="separator:adba7696040378f0eaa679e684b72bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803cbb38fe59825f59858a16afa54b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a803cbb38fe59825f59858a16afa54b7d">isHeritaged</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a803cbb38fe59825f59858a16afa54b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has been linked in fully to the syntax tree (SSA)  <a href="#a803cbb38fe59825f59858a16afa54b7d">More...</a><br /></td></tr>
<tr class="separator:a803cbb38fe59825f59858a16afa54b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef841d752b09ce83f1cd067dffe87729"><td class="memItemLeft" align="right" valign="top"><a id="aef841d752b09ce83f1cd067dffe87729"></a>
const list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aef841d752b09ce83f1cd067dffe87729">getLoadGuards</a> (void) const</td></tr>
<tr class="memdesc:aef841d752b09ce83f1cd067dffe87729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of guarded LOADs. <br /></td></tr>
<tr class="separator:aef841d752b09ce83f1cd067dffe87729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efef6da7ffd4650137c7837b87c9293"><td class="memItemLeft" align="right" valign="top"><a id="a5efef6da7ffd4650137c7837b87c9293"></a>
const list&lt; <a class="el" href="classLoadGuard.html">LoadGuard</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5efef6da7ffd4650137c7837b87c9293">getStoreGuards</a> (void) const</td></tr>
<tr class="memdesc:a5efef6da7ffd4650137c7837b87c9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of guarded STOREs. <br /></td></tr>
<tr class="separator:a5efef6da7ffd4650137c7837b87c9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461483b6b8ef8c0c5f6fb52ed288e58"><td class="memItemLeft" align="right" valign="top"><a id="ad461483b6b8ef8c0c5f6fb52ed288e58"></a>
const <a class="el" href="classLoadGuard.html">LoadGuard</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad461483b6b8ef8c0c5f6fb52ed288e58">getStoreGuard</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const</td></tr>
<tr class="memdesc:ad461483b6b8ef8c0c5f6fb52ed288e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classLoadGuard.html" title="Description of a LOAD operation that needs to be guarded. ">LoadGuard</a> associated with STORE op. <br /></td></tr>
<tr class="separator:ad461483b6b8ef8c0c5f6fb52ed288e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0901453d881b28305cb071a3cc8a7fe9"><td class="memItemLeft" align="right" valign="top"><a id="a0901453d881b28305cb071a3cc8a7fe9"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0901453d881b28305cb071a3cc8a7fe9">numCalls</a> (void) const</td></tr>
<tr class="memdesc:a0901453d881b28305cb071a3cc8a7fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of calls made by <b>this</b> function. <br /></td></tr>
<tr class="separator:a0901453d881b28305cb071a3cc8a7fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc1d922d37c04236c4f7db44930b4fc"><td class="memItemLeft" align="right" valign="top"><a id="a8bc1d922d37c04236c4f7db44930b4fc"></a>
<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8bc1d922d37c04236c4f7db44930b4fc">getCallSpecs</a> (int4 i) const</td></tr>
<tr class="memdesc:a8bc1d922d37c04236c4f7db44930b4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th call specification. <br /></td></tr>
<tr class="separator:a8bc1d922d37c04236c4f7db44930b4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952f07a6db222c00cc243917767dcdc1"><td class="memItemLeft" align="right" valign="top"><a id="a952f07a6db222c00cc243917767dcdc1"></a>
<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a952f07a6db222c00cc243917767dcdc1">getCallSpecs</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const</td></tr>
<tr class="memdesc:a952f07a6db222c00cc243917767dcdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the call specification associated with a CALL op. <br /></td></tr>
<tr class="separator:a952f07a6db222c00cc243917767dcdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bea7abaa0ea3ade9d04cb78a521aac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae4bea7abaa0ea3ade9d04cb78a521aac">updateOpFromSpec</a> (<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *fc)</td></tr>
<tr class="memdesc:ae4bea7abaa0ea3ade9d04cb78a521aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update CALL <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> properties based on its corresponding call specification.  <a href="#ae4bea7abaa0ea3ade9d04cb78a521aac">More...</a><br /></td></tr>
<tr class="separator:ae4bea7abaa0ea3ade9d04cb78a521aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142938fffbfd5add2b6679a6b9b0d7fa"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a142938fffbfd5add2b6679a6b9b0d7fa">fillinExtrapop</a> (void)</td></tr>
<tr class="memdesc:a142938fffbfd5add2b6679a6b9b0d7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover and return the <em>extrapop</em> for this function.  <a href="#a142938fffbfd5add2b6679a6b9b0d7fa">More...</a><br /></td></tr>
<tr class="separator:a142938fffbfd5add2b6679a6b9b0d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3390320b74e47d309f27fe6fd1d7e4"><td class="memItemLeft" align="right" valign="top"><a id="a4a3390320b74e47d309f27fe6fd1d7e4"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4a3390320b74e47d309f27fe6fd1d7e4">numVarnodes</a> (void) const</td></tr>
<tr class="memdesc:a4a3390320b74e47d309f27fe6fd1d7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of Varnodes. <br /></td></tr>
<tr class="separator:a4a3390320b74e47d309f27fe6fd1d7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e6704e4c245e076170268d31b47ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a100e6704e4c245e076170268d31b47ec">newVarnodeOut</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;m, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a100e6704e4c245e076170268d31b47ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a100e6704e4c245e076170268d31b47ec">More...</a><br /></td></tr>
<tr class="separator:a100e6704e4c245e076170268d31b47ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af189a9a5b390332c6e87c8faa334cd68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af189a9a5b390332c6e87c8faa334cd68">newUniqueOut</a> (int4 s, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:af189a9a5b390332c6e87c8faa334cd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>temporary</em> output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#af189a9a5b390332c6e87c8faa334cd68">More...</a><br /></td></tr>
<tr class="separator:af189a9a5b390332c6e87c8faa334cd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22894e1c7b0f30a5391993924cd96d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a22894e1c7b0f30a5391993924cd96d3d">newVarnode</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;m, <a class="el" href="classDatatype.html">Datatype</a> *ct=(<a class="el" href="classDatatype.html">Datatype</a> *) 0)</td></tr>
<tr class="memdesc:a22894e1c7b0f30a5391993924cd96d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new unattached <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object.  <a href="#a22894e1c7b0f30a5391993924cd96d3d">More...</a><br /></td></tr>
<tr class="separator:a22894e1c7b0f30a5391993924cd96d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58542dbcc89f4b84ffc8834b023125b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af58542dbcc89f4b84ffc8834b023125b">newConstant</a> (int4 s, uintb constant_val)</td></tr>
<tr class="memdesc:af58542dbcc89f4b84ffc8834b023125b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>constant</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#af58542dbcc89f4b84ffc8834b023125b">More...</a><br /></td></tr>
<tr class="separator:af58542dbcc89f4b84ffc8834b023125b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6888d1606fd8ed6372355995bc7887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0d6888d1606fd8ed6372355995bc7887">newVarnode</a> (int4 s, <a class="el" href="classAddrSpace.html">AddrSpace</a> *base, uintb off)</td></tr>
<tr class="memdesc:a0d6888d1606fd8ed6372355995bc7887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> given an address space and offset.  <a href="#a0d6888d1606fd8ed6372355995bc7887">More...</a><br /></td></tr>
<tr class="separator:a0d6888d1606fd8ed6372355995bc7887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee39fe2d1f2f4702864e78dc06e6bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8ee39fe2d1f2f4702864e78dc06e6bb8">newVarnodeIop</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a8ee39fe2d1f2f4702864e78dc06e6bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a8ee39fe2d1f2f4702864e78dc06e6bb8">More...</a><br /></td></tr>
<tr class="separator:a8ee39fe2d1f2f4702864e78dc06e6bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f6fb3e8a36e0e1e633660fc05fdbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#acc9f6fb3e8a36e0e1e633660fc05fdbf">newVarnodeSpace</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:acc9f6fb3e8a36e0e1e633660fc05fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> referring to an address space.  <a href="#acc9f6fb3e8a36e0e1e633660fc05fdbf">More...</a><br /></td></tr>
<tr class="separator:acc9f6fb3e8a36e0e1e633660fc05fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13da637294b7cae252ffc6c9e2116da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a13da637294b7cae252ffc6c9e2116da2">newVarnodeCallSpecs</a> (<a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *fc)</td></tr>
<tr class="memdesc:a13da637294b7cae252ffc6c9e2116da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a call specification <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a13da637294b7cae252ffc6c9e2116da2">More...</a><br /></td></tr>
<tr class="separator:a13da637294b7cae252ffc6c9e2116da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f6fd415269577b7bb1943315b8a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a731f6fd415269577b7bb1943315b8a76">newUnique</a> (int4 s, <a class="el" href="classDatatype.html">Datatype</a> *ct=(<a class="el" href="classDatatype.html">Datatype</a> *) 0)</td></tr>
<tr class="memdesc:a731f6fd415269577b7bb1943315b8a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <em>temporary</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a731f6fd415269577b7bb1943315b8a76">More...</a><br /></td></tr>
<tr class="separator:a731f6fd415269577b7bb1943315b8a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e80f56ef371a0010a9e67ae8510086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a24e80f56ef371a0010a9e67ae8510086">newCodeRef</a> (const <a class="el" href="classAddress.html">Address</a> &amp;m)</td></tr>
<tr class="memdesc:a24e80f56ef371a0010a9e67ae8510086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a code address <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a24e80f56ef371a0010a9e67ae8510086">More...</a><br /></td></tr>
<tr class="separator:a24e80f56ef371a0010a9e67ae8510086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a9880613a03f3aea65acf3dd1343d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a84a9880613a03f3aea65acf3dd1343d6">setInputVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a84a9880613a03f3aea65acf3dd1343d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as an input to the function.  <a href="#a84a9880613a03f3aea65acf3dd1343d6">More...</a><br /></td></tr>
<tr class="separator:a84a9880613a03f3aea65acf3dd1343d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c51952540dbda3f11962b22c3064a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a35c51952540dbda3f11962b22c3064a3">adjustInputVarnodes</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:a35c51952540dbda3f11962b22c3064a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust input Varnodes contained in the given range.  <a href="#a35c51952540dbda3f11962b22c3064a3">More...</a><br /></td></tr>
<tr class="separator:a35c51952540dbda3f11962b22c3064a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8657c4c04279316593adc6d2f389be5"><td class="memItemLeft" align="right" valign="top"><a id="aa8657c4c04279316593adc6d2f389be5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa8657c4c04279316593adc6d2f389be5">deleteVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:aa8657c4c04279316593adc6d2f389be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given varnode. <br /></td></tr>
<tr class="separator:aa8657c4c04279316593adc6d2f389be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa3242779be4a766a37227deb728836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8fa3242779be4a766a37227deb728836">findCoveredInput</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc) const</td></tr>
<tr class="memdesc:a8fa3242779be4a766a37227deb728836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> covered by the given range.  <a href="#a8fa3242779be4a766a37227deb728836">More...</a><br /></td></tr>
<tr class="separator:a8fa3242779be4a766a37227deb728836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6461d0bee74dda24aafa2caa40d0fee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6461d0bee74dda24aafa2caa40d0fee7">findCoveringInput</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc) const</td></tr>
<tr class="memdesc:a6461d0bee74dda24aafa2caa40d0fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that contains the given range.  <a href="#a6461d0bee74dda24aafa2caa40d0fee7">More...</a><br /></td></tr>
<tr class="separator:a6461d0bee74dda24aafa2caa40d0fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718cc133e6ade757ee532f0d704c04d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a718cc133e6ade757ee532f0d704c04d4">findVarnodeInput</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc) const</td></tr>
<tr class="memdesc:a718cc133e6ade757ee532f0d704c04d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with the given size and storage address.  <a href="#a718cc133e6ade757ee532f0d704c04d4">More...</a><br /></td></tr>
<tr class="separator:a718cc133e6ade757ee532f0d704c04d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7ae831db646e2f9d64ffb2b51fa7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#acb7ae831db646e2f9d64ffb2b51fa7f1">findVarnodeWritten</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;loc, const <a class="el" href="classAddress.html">Address</a> &amp;pc, uintm uniq=~((uintm) 0)) const</td></tr>
<tr class="memdesc:acb7ae831db646e2f9d64ffb2b51fa7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a defined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> via its storage address and its definition address.  <a href="#acb7ae831db646e2f9d64ffb2b51fa7f1">More...</a><br /></td></tr>
<tr class="separator:acb7ae831db646e2f9d64ffb2b51fa7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34a257742ad827bd278d0b35e15af74"><td class="memItemLeft" align="right" valign="top"><a id="ac34a257742ad827bd278d0b35e15af74"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac34a257742ad827bd278d0b35e15af74">beginLoc</a> (void) const</td></tr>
<tr class="memdesc:ac34a257742ad827bd278d0b35e15af74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all Varnodes sorted by storage. <br /></td></tr>
<tr class="separator:ac34a257742ad827bd278d0b35e15af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f4e57094c47d431d81545f28172c1f"><td class="memItemLeft" align="right" valign="top"><a id="a49f4e57094c47d431d81545f28172c1f"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a49f4e57094c47d431d81545f28172c1f">endLoc</a> (void) const</td></tr>
<tr class="memdesc:a49f4e57094c47d431d81545f28172c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all Varnodes sorted by storage. <br /></td></tr>
<tr class="separator:a49f4e57094c47d431d81545f28172c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8fa3ac2bdccfd83dd3eba870ef3b09"><td class="memItemLeft" align="right" valign="top"><a id="a6d8fa3ac2bdccfd83dd3eba870ef3b09"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6d8fa3ac2bdccfd83dd3eba870ef3b09">beginLoc</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spaceid) const</td></tr>
<tr class="memdesc:a6d8fa3ac2bdccfd83dd3eba870ef3b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes stored in a given address space. <br /></td></tr>
<tr class="separator:a6d8fa3ac2bdccfd83dd3eba870ef3b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bcf948b0b6306696e595b2464c746b"><td class="memItemLeft" align="right" valign="top"><a id="a23bcf948b0b6306696e595b2464c746b"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a23bcf948b0b6306696e595b2464c746b">endLoc</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spaceid) const</td></tr>
<tr class="memdesc:a23bcf948b0b6306696e595b2464c746b"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes stored in a given address space. <br /></td></tr>
<tr class="separator:a23bcf948b0b6306696e595b2464c746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bcc9eaf90591b9200db7cfd1c2fce5"><td class="memItemLeft" align="right" valign="top"><a id="a04bcc9eaf90591b9200db7cfd1c2fce5"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a04bcc9eaf90591b9200db7cfd1c2fce5">beginLoc</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a04bcc9eaf90591b9200db7cfd1c2fce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes at a storage address. <br /></td></tr>
<tr class="separator:a04bcc9eaf90591b9200db7cfd1c2fce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4417d6ddefad162550e3abdbe8424d76"><td class="memItemLeft" align="right" valign="top"><a id="a4417d6ddefad162550e3abdbe8424d76"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4417d6ddefad162550e3abdbe8424d76">endLoc</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a4417d6ddefad162550e3abdbe8424d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes at a storage address. <br /></td></tr>
<tr class="separator:a4417d6ddefad162550e3abdbe8424d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b7ea0975c8f7022f14158d3bb9e9d5"><td class="memItemLeft" align="right" valign="top"><a id="ad2b7ea0975c8f7022f14158d3bb9e9d5"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad2b7ea0975c8f7022f14158d3bb9e9d5">beginLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:ad2b7ea0975c8f7022f14158d3bb9e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes with given storage. <br /></td></tr>
<tr class="separator:ad2b7ea0975c8f7022f14158d3bb9e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac026cfb35c8a407c50d21837510d78f7"><td class="memItemLeft" align="right" valign="top"><a id="ac026cfb35c8a407c50d21837510d78f7"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac026cfb35c8a407c50d21837510d78f7">endLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:ac026cfb35c8a407c50d21837510d78f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes with given storage. <br /></td></tr>
<tr class="separator:ac026cfb35c8a407c50d21837510d78f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1213896328c86680dc05c9c5daa7c5"><td class="memItemLeft" align="right" valign="top"><a id="afc1213896328c86680dc05c9c5daa7c5"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afc1213896328c86680dc05c9c5daa7c5">beginLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, uint4 fl) const</td></tr>
<tr class="memdesc:afc1213896328c86680dc05c9c5daa7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes matching storage and properties. <br /></td></tr>
<tr class="separator:afc1213896328c86680dc05c9c5daa7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b418941dce53af9e8ac8dcbd453a44f"><td class="memItemLeft" align="right" valign="top"><a id="a9b418941dce53af9e8ac8dcbd453a44f"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9b418941dce53af9e8ac8dcbd453a44f">endLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, uint4 fl) const</td></tr>
<tr class="memdesc:a9b418941dce53af9e8ac8dcbd453a44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes matching storage and properties. <br /></td></tr>
<tr class="separator:a9b418941dce53af9e8ac8dcbd453a44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad396df61c154668d1f768918b46254"><td class="memItemLeft" align="right" valign="top"><a id="a1ad396df61c154668d1f768918b46254"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1ad396df61c154668d1f768918b46254">beginLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, uintm uniq=~((uintm) 0)) const</td></tr>
<tr class="memdesc:a1ad396df61c154668d1f768918b46254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes matching storage and definition address. <br /></td></tr>
<tr class="separator:a1ad396df61c154668d1f768918b46254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfc7faf2c1793283d70d16a2313416e"><td class="memItemLeft" align="right" valign="top"><a id="addfc7faf2c1793283d70d16a2313416e"></a>
VarnodeLocSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#addfc7faf2c1793283d70d16a2313416e">endLoc</a> (int4 s, const <a class="el" href="classAddress.html">Address</a> &amp;addr, const <a class="el" href="classAddress.html">Address</a> &amp;pc, uintm uniq=~((uintm) 0)) const</td></tr>
<tr class="memdesc:addfc7faf2c1793283d70d16a2313416e"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes matching storage and definition address. <br /></td></tr>
<tr class="separator:addfc7faf2c1793283d70d16a2313416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9350996f6f24052be034b59bfd383b2"><td class="memItemLeft" align="right" valign="top"><a id="af9350996f6f24052be034b59bfd383b2"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af9350996f6f24052be034b59bfd383b2">beginDef</a> (void) const</td></tr>
<tr class="memdesc:af9350996f6f24052be034b59bfd383b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all Varnodes sorted by definition address. <br /></td></tr>
<tr class="separator:af9350996f6f24052be034b59bfd383b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fba46eb4e585463bafe3461d415fd4"><td class="memItemLeft" align="right" valign="top"><a id="ad5fba46eb4e585463bafe3461d415fd4"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad5fba46eb4e585463bafe3461d415fd4">endDef</a> (void) const</td></tr>
<tr class="memdesc:ad5fba46eb4e585463bafe3461d415fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all Varnodes sorted by definition address. <br /></td></tr>
<tr class="separator:ad5fba46eb4e585463bafe3461d415fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721c960a75b9ac5652a620b6195e33f5"><td class="memItemLeft" align="right" valign="top"><a id="a721c960a75b9ac5652a620b6195e33f5"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a721c960a75b9ac5652a620b6195e33f5">beginDef</a> (uint4 fl) const</td></tr>
<tr class="memdesc:a721c960a75b9ac5652a620b6195e33f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of Varnodes with a given definition property. <br /></td></tr>
<tr class="separator:a721c960a75b9ac5652a620b6195e33f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa192d156e74fef2a22c274b86f3e73"><td class="memItemLeft" align="right" valign="top"><a id="a5fa192d156e74fef2a22c274b86f3e73"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5fa192d156e74fef2a22c274b86f3e73">endDef</a> (uint4 fl) const</td></tr>
<tr class="memdesc:a5fa192d156e74fef2a22c274b86f3e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Varnodes with a given definition property. <br /></td></tr>
<tr class="separator:a5fa192d156e74fef2a22c274b86f3e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52feb85441fe82ca75ec8334244d0426"><td class="memItemLeft" align="right" valign="top"><a id="a52feb85441fe82ca75ec8334244d0426"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a52feb85441fe82ca75ec8334244d0426">beginDef</a> (uint4 fl, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a52feb85441fe82ca75ec8334244d0426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of (input or free) Varnodes at a given storage address. <br /></td></tr>
<tr class="separator:a52feb85441fe82ca75ec8334244d0426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab112eb1f47f8e32c0018c7af989f519c"><td class="memItemLeft" align="right" valign="top"><a id="ab112eb1f47f8e32c0018c7af989f519c"></a>
VarnodeDefSet::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab112eb1f47f8e32c0018c7af989f519c">endDef</a> (uint4 fl, const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:ab112eb1f47f8e32c0018c7af989f519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of (input or free) Varnodes at a given storage address. <br /></td></tr>
<tr class="separator:ab112eb1f47f8e32c0018c7af989f519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3a408927e4fe3324d7c589a2fa1e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4a3a408927e4fe3324d7c589a2fa1e2c">markLanedVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classLanedRegister.html">LanedRegister</a> *lanedReg)</td></tr>
<tr class="memdesc:a4a3a408927e4fe3324d7c589a2fa1e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as potential laned register.  <a href="#a4a3a408927e4fe3324d7c589a2fa1e2c">More...</a><br /></td></tr>
<tr class="separator:a4a3a408927e4fe3324d7c589a2fa1e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441cf1bd2cc536993b71258e597c1c9c"><td class="memItemLeft" align="right" valign="top"><a id="a441cf1bd2cc536993b71258e597c1c9c"></a>
map&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a>, const <a class="el" href="classLanedRegister.html">LanedRegister</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a441cf1bd2cc536993b71258e597c1c9c">beginLaneAccess</a> (void) const</td></tr>
<tr class="memdesc:a441cf1bd2cc536993b71258e597c1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning iterator over laned accesses. <br /></td></tr>
<tr class="separator:a441cf1bd2cc536993b71258e597c1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bff22c36a1404be33bd8d53b5d59b99"><td class="memItemLeft" align="right" valign="top"><a id="a6bff22c36a1404be33bd8d53b5d59b99"></a>
map&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a>, const <a class="el" href="classLanedRegister.html">LanedRegister</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6bff22c36a1404be33bd8d53b5d59b99">endLaneAccess</a> (void) const</td></tr>
<tr class="memdesc:a6bff22c36a1404be33bd8d53b5d59b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending iterator over laned accesses. <br /></td></tr>
<tr class="separator:a6bff22c36a1404be33bd8d53b5d59b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833bad69ef5a58c8171d8839fa627960"><td class="memItemLeft" align="right" valign="top"><a id="a833bad69ef5a58c8171d8839fa627960"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a833bad69ef5a58c8171d8839fa627960">clearLanedAccessMap</a> (void)</td></tr>
<tr class="memdesc:a833bad69ef5a58c8171d8839fa627960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear records from the laned access list. <br /></td></tr>
<tr class="separator:a833bad69ef5a58c8171d8839fa627960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34c7b2d0d5f4cb28e0a2602d3cba033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa34c7b2d0d5f4cb28e0a2602d3cba033">findHigh</a> (const string &amp;name) const</td></tr>
<tr class="memdesc:aa34c7b2d0d5f4cb28e0a2602d3cba033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a high-level variable by name.  <a href="#aa34c7b2d0d5f4cb28e0a2602d3cba033">More...</a><br /></td></tr>
<tr class="separator:aa34c7b2d0d5f4cb28e0a2602d3cba033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6aefa7321e887e3b759de94e4d3d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f">mapGlobals</a> (void)</td></tr>
<tr class="memdesc:aed6aefa7321e887e3b759de94e4d3d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure there is a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry for all global Varnodes.  <a href="#aed6aefa7321e887e3b759de94e4d3d4f">More...</a><br /></td></tr>
<tr class="separator:aed6aefa7321e887e3b759de94e4d3d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add076d930ec2ceb66453451e478ca7d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#add076d930ec2ceb66453451e478ca7d4">checkCallDoubleUse</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *opmatch, const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, const <a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;trial) const</td></tr>
<tr class="memdesc:add076d930ec2ceb66453451e478ca7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for legitimate double use of a parameter trial.  <a href="#add076d930ec2ceb66453451e478ca7d4">More...</a><br /></td></tr>
<tr class="separator:add076d930ec2ceb66453451e478ca7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ddc6cd232b4a101968d960fda9b965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a07ddc6cd232b4a101968d960fda9b965">onlyOpUse</a> (const <a class="el" href="classVarnode.html">Varnode</a> *invn, const <a class="el" href="classPcodeOp.html">PcodeOp</a> *opmatch, const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;trial) const</td></tr>
<tr class="memdesc:a07ddc6cd232b4a101968d960fda9b965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> seems to only be used by a CALL.  <a href="#a07ddc6cd232b4a101968d960fda9b965">More...</a><br /></td></tr>
<tr class="separator:a07ddc6cd232b4a101968d960fda9b965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa02a817ac34b428cac2a327d1891c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adfa02a817ac34b428cac2a327d1891c0">ancestorOpUse</a> (int4 maxlevel, const <a class="el" href="classVarnode.html">Varnode</a> *invn, const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;trial) const</td></tr>
<tr class="memdesc:adfa02a817ac34b428cac2a327d1891c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given trial <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is likely only used for parameter passing.  <a href="#adfa02a817ac34b428cac2a327d1891c0">More...</a><br /></td></tr>
<tr class="separator:adfa02a817ac34b428cac2a327d1891c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca583e76acc0a61bc30bd32461d25aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aca583e76acc0a61bc30bd32461d25aee">syncVarnodesWithSymbols</a> (const <a class="el" href="classScopeLocal.html">ScopeLocal</a> *lm, bool typesyes)</td></tr>
<tr class="memdesc:aca583e76acc0a61bc30bd32461d25aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties based on (new) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> information.  <a href="#aca583e76acc0a61bc30bd32461d25aee">More...</a><br /></td></tr>
<tr class="separator:aca583e76acc0a61bc30bd32461d25aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070edf06c2d300a7d6d1bda21189b477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a070edf06c2d300a7d6d1bda21189b477">transferVarnodeProperties</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classVarnode.html">Varnode</a> *newVn, int4 lsbOffset)</td></tr>
<tr class="memdesc:a070edf06c2d300a7d6d1bda21189b477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy properties from an existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a070edf06c2d300a7d6d1bda21189b477">More...</a><br /></td></tr>
<tr class="separator:a070edf06c2d300a7d6d1bda21189b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47b9524aee42c71c7dbe260a4052485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af47b9524aee42c71c7dbe260a4052485">fillinReadOnly</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:af47b9524aee42c71c7dbe260a4052485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with its (constant) value in the load image.  <a href="#af47b9524aee42c71c7dbe260a4052485">More...</a><br /></td></tr>
<tr class="separator:af47b9524aee42c71c7dbe260a4052485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754fe8bd5805e6d9fd8041365e7747eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a754fe8bd5805e6d9fd8041365e7747eb">replaceVolatile</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a754fe8bd5805e6d9fd8041365e7747eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace accesses of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with <em>volatile</em> operations.  <a href="#a754fe8bd5805e6d9fd8041365e7747eb">More...</a><br /></td></tr>
<tr class="separator:a754fe8bd5805e6d9fd8041365e7747eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dc1e061256c4cc55e7afcf5995f435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a41dc1e061256c4cc55e7afcf5995f435">markIndirectOnly</a> (void)</td></tr>
<tr class="memdesc:a41dc1e061256c4cc55e7afcf5995f435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <em>illegal</em> <em>input</em> Varnodes used only in INDIRECTs.  <a href="#a41dc1e061256c4cc55e7afcf5995f435">More...</a><br /></td></tr>
<tr class="separator:a41dc1e061256c4cc55e7afcf5995f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f940f85609d395283520eca3a71f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aab7f940f85609d395283520eca3a71f0">totalReplace</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classVarnode.html">Varnode</a> *newvn)</td></tr>
<tr class="memdesc:aab7f940f85609d395283520eca3a71f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all read references to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#aab7f940f85609d395283520eca3a71f0">More...</a><br /></td></tr>
<tr class="separator:aab7f940f85609d395283520eca3a71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934e1e4246d41a5e28f6fcb56acc937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2934e1e4246d41a5e28f6fcb56acc937">totalReplaceConstant</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, uintb val)</td></tr>
<tr class="memdesc:a2934e1e4246d41a5e28f6fcb56acc937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every read reference of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a constant value.  <a href="#a2934e1e4246d41a5e28f6fcb56acc937">More...</a><br /></td></tr>
<tr class="separator:a2934e1e4246d41a5e28f6fcb56acc937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa28789a086c52edd04c41e265818bbb"><td class="memItemLeft" align="right" valign="top"><a id="aaa28789a086c52edd04c41e265818bbb"></a>
<a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aaa28789a086c52edd04c41e265818bbb">getScopeLocal</a> (void)</td></tr>
<tr class="memdesc:aaa28789a086c52edd04c41e265818bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local function scope. <br /></td></tr>
<tr class="separator:aaa28789a086c52edd04c41e265818bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119d29273d0e896ee16d7581f7548a80"><td class="memItemLeft" align="right" valign="top"><a id="a119d29273d0e896ee16d7581f7548a80"></a>
const <a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a119d29273d0e896ee16d7581f7548a80">getScopeLocal</a> (void) const</td></tr>
<tr class="memdesc:a119d29273d0e896ee16d7581f7548a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local function scope. <br /></td></tr>
<tr class="separator:a119d29273d0e896ee16d7581f7548a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1961c6d9c58e9a0a20f74c6e49853f"><td class="memItemLeft" align="right" valign="top"><a id="a1b1961c6d9c58e9a0a20f74c6e49853f"></a>
<a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1b1961c6d9c58e9a0a20f74c6e49853f">getFuncProto</a> (void)</td></tr>
<tr class="memdesc:a1b1961c6d9c58e9a0a20f74c6e49853f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function's prototype object. <br /></td></tr>
<tr class="separator:a1b1961c6d9c58e9a0a20f74c6e49853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99d6aeaee949a45ec935756a93b99da"><td class="memItemLeft" align="right" valign="top"><a id="af99d6aeaee949a45ec935756a93b99da"></a>
const <a class="el" href="classFuncProto.html">FuncProto</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af99d6aeaee949a45ec935756a93b99da">getFuncProto</a> (void) const</td></tr>
<tr class="memdesc:af99d6aeaee949a45ec935756a93b99da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function's prototype object. <br /></td></tr>
<tr class="separator:af99d6aeaee949a45ec935756a93b99da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae454fbd3566fbd43103dcabdf2681fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae454fbd3566fbd43103dcabdf2681fd8">initActiveOutput</a> (void)</td></tr>
<tr class="separator:ae454fbd3566fbd43103dcabdf2681fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f29c20e2a01d0cbf600b613e929e88c"><td class="memItemLeft" align="right" valign="top"><a id="a8f29c20e2a01d0cbf600b613e929e88c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8f29c20e2a01d0cbf600b613e929e88c">clearActiveOutput</a> (void)</td></tr>
<tr class="memdesc:a8f29c20e2a01d0cbf600b613e929e88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear any analysis of the function's <em>return</em> prototype. <br /></td></tr>
<tr class="separator:a8f29c20e2a01d0cbf600b613e929e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a711cda20fb99632665753918c03a65"><td class="memItemLeft" align="right" valign="top"><a id="a4a711cda20fb99632665753918c03a65"></a>
<a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4a711cda20fb99632665753918c03a65">getActiveOutput</a> (void) const</td></tr>
<tr class="memdesc:a4a711cda20fb99632665753918c03a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>return</em> prototype recovery object. <br /></td></tr>
<tr class="separator:a4a711cda20fb99632665753918c03a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadeeb585ee8728c427fd6914b8bb7b1"><td class="memItemLeft" align="right" valign="top"><a id="afadeeb585ee8728c427fd6914b8bb7b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afadeeb585ee8728c427fd6914b8bb7b1">setHighLevel</a> (void)</td></tr>
<tr class="memdesc:afadeeb585ee8728c427fd6914b8bb7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> objects for all Varnodes. <br /></td></tr>
<tr class="separator:afadeeb585ee8728c427fd6914b8bb7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4096b0e76e9015f9aa61fa56cb85d79c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4096b0e76e9015f9aa61fa56cb85d79c">clearDeadVarnodes</a> (void)</td></tr>
<tr class="memdesc:a4096b0e76e9015f9aa61fa56cb85d79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any dead Varnodes.  <a href="#a4096b0e76e9015f9aa61fa56cb85d79c">More...</a><br /></td></tr>
<tr class="separator:a4096b0e76e9015f9aa61fa56cb85d79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b338d2b2d1a72db73369e8631125ffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5b338d2b2d1a72db73369e8631125ffd">calcNZMask</a> (void)</td></tr>
<tr class="memdesc:a5b338d2b2d1a72db73369e8631125ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <em>non-zero</em> masks for all Varnodes.  <a href="#a5b338d2b2d1a72db73369e8631125ffd">More...</a><br /></td></tr>
<tr class="separator:a5b338d2b2d1a72db73369e8631125ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb872f99bf69e4101034da41cdebd84"><td class="memItemLeft" align="right" valign="top"><a id="adbb872f99bf69e4101034da41cdebd84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adbb872f99bf69e4101034da41cdebd84">clearDeadOps</a> (void)</td></tr>
<tr class="memdesc:adbb872f99bf69e4101034da41cdebd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any dead PcodeOps. <br /></td></tr>
<tr class="separator:adbb872f99bf69e4101034da41cdebd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acc07e00146316532a3806cd19815bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5acc07e00146316532a3806cd19815bb">clearSymbolLinks</a> (<a class="el" href="classHighVariable.html">HighVariable</a> *high)</td></tr>
<tr class="memdesc:a5acc07e00146316532a3806cd19815bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Symbols attached to Varnodes in the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>.  <a href="#a5acc07e00146316532a3806cd19815bb">More...</a><br /></td></tr>
<tr class="separator:a5acc07e00146316532a3806cd19815bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6145d643e13a072975e34255a06f4e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6145d643e13a072975e34255a06f4e84">remapVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint)</td></tr>
<tr class="memdesc:a6145d643e13a072975e34255a06f4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a static mapping.  <a href="#a6145d643e13a072975e34255a06f4e84">More...</a><br /></td></tr>
<tr class="separator:a6145d643e13a072975e34255a06f4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cbb6375e48cddaedf5e55e40119c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a73cbb6375e48cddaedf5e55e40119c84">remapDynamicVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, <a class="el" href="classSymbol.html">Symbol</a> *sym, const <a class="el" href="classAddress.html">Address</a> &amp;usepoint, uint8 hash)</td></tr>
<tr class="memdesc:a73cbb6375e48cddaedf5e55e40119c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a new dynamic mapping.  <a href="#a73cbb6375e48cddaedf5e55e40119c84">More...</a><br /></td></tr>
<tr class="separator:a73cbb6375e48cddaedf5e55e40119c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3bc5ac9e2c09eda544db34b8f5879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#afbb3bc5ac9e2c09eda544db34b8f5879">linkSymbol</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:afbb3bc5ac9e2c09eda544db34b8f5879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find or create <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#afbb3bc5ac9e2c09eda544db34b8f5879">More...</a><br /></td></tr>
<tr class="separator:afbb3bc5ac9e2c09eda544db34b8f5879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736351e8eb6c044fe00deb0cf7e6b5c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a736351e8eb6c044fe00deb0cf7e6b5c5">linkSymbolReference</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a736351e8eb6c044fe00deb0cf7e6b5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover and attach <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a constant reference.  <a href="#a736351e8eb6c044fe00deb0cf7e6b5c5">More...</a><br /></td></tr>
<tr class="separator:a736351e8eb6c044fe00deb0cf7e6b5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9debba02fdd2a35a5bc5d7cd57fbcd5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9debba02fdd2a35a5bc5d7cd57fbcd5f">findLinkedVarnode</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry) const</td></tr>
<tr class="memdesc:a9debba02fdd2a35a5bc5d7cd57fbcd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> matching the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> mapping.  <a href="#a9debba02fdd2a35a5bc5d7cd57fbcd5f">More...</a><br /></td></tr>
<tr class="separator:a9debba02fdd2a35a5bc5d7cd57fbcd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03500cc804152adff478e961fdfc8ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae03500cc804152adff478e961fdfc8ec">findLinkedVarnodes</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;res) const</td></tr>
<tr class="memdesc:ae03500cc804152adff478e961fdfc8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Varnodes that map to the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>.  <a href="#ae03500cc804152adff478e961fdfc8ec">More...</a><br /></td></tr>
<tr class="separator:ae03500cc804152adff478e961fdfc8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15db3d569027578de69c065fc607c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa15db3d569027578de69c065fc607c63">buildDynamicSymbol</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:aa15db3d569027578de69c065fc607c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <em>dynamic</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#aa15db3d569027578de69c065fc607c63">More...</a><br /></td></tr>
<tr class="separator:aa15db3d569027578de69c065fc607c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeee32fc648486d26cd17ebb37bb118f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#adeee32fc648486d26cd17ebb37bb118f">attemptDynamicMapping</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, <a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;dhash)</td></tr>
<tr class="memdesc:adeee32fc648486d26cd17ebb37bb118f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map properties of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#adeee32fc648486d26cd17ebb37bb118f">More...</a><br /></td></tr>
<tr class="separator:adeee32fc648486d26cd17ebb37bb118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dddb637a6e322632f9a4bb10c5c36e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a69dddb637a6e322632f9a4bb10c5c36e">attemptDynamicMappingLate</a> (<a class="el" href="classSymbolEntry.html">SymbolEntry</a> *entry, <a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;dhash)</td></tr>
<tr class="memdesc:a69dddb637a6e322632f9a4bb10c5c36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the name of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a69dddb637a6e322632f9a4bb10c5c36e">More...</a><br /></td></tr>
<tr class="separator:a69dddb637a6e322632f9a4bb10c5c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7716a2ee4e91b0b91ac0487264673ca"><td class="memItemLeft" align="right" valign="top"><a id="ad7716a2ee4e91b0b91ac0487264673ca"></a>
<a class="el" href="classMerge.html">Merge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad7716a2ee4e91b0b91ac0487264673ca">getMerge</a> (void)</td></tr>
<tr class="memdesc:ad7716a2ee4e91b0b91ac0487264673ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> object for <b>this</b> function. <br /></td></tr>
<tr class="separator:ad7716a2ee4e91b0b91ac0487264673ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1e9831bb4b1c65df6950ae1f15e0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1b1e9831bb4b1c65df6950ae1f15e0be">newOp</a> (int4 inputs, const <a class="el" href="classAddress.html">Address</a> &amp;pc)</td></tr>
<tr class="separator:a1b1e9831bb4b1c65df6950ae1f15e0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d122aa09d739e59a5107338f8ecd8ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0d122aa09d739e59a5107338f8ecd8ab">newOp</a> (int4 inputs, const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;sq)</td></tr>
<tr class="memdesc:a0d122aa09d739e59a5107338f8ecd8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>.  <a href="#a0d122aa09d739e59a5107338f8ecd8ab">More...</a><br /></td></tr>
<tr class="separator:a0d122aa09d739e59a5107338f8ecd8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1126d213d88120c9e55b5779d746859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae1126d213d88120c9e55b5779d746859">newOpBefore</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *follow, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, <a class="el" href="classVarnode.html">Varnode</a> *in1, <a class="el" href="classVarnode.html">Varnode</a> *in2, <a class="el" href="classVarnode.html">Varnode</a> *in3=(<a class="el" href="classVarnode.html">Varnode</a> *) 0)</td></tr>
<tr class="memdesc:ae1126d213d88120c9e55b5779d746859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with sequence number.  <a href="#ae1126d213d88120c9e55b5779d746859">More...</a><br /></td></tr>
<tr class="separator:ae1126d213d88120c9e55b5779d746859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8e9506c5b37fce86d165974a4cafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1da8e9506c5b37fce86d165974a4cafb">cloneOp</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;seq)</td></tr>
<tr class="separator:a1da8e9506c5b37fce86d165974a4cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f6152575b9b9cbe1c5c447a78efcd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a97f6152575b9b9cbe1c5c447a78efcd3">getFirstReturnOp</a> (void) const</td></tr>
<tr class="memdesc:a97f6152575b9b9cbe1c5c447a78efcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> into <b>this</b> function.  <a href="#a97f6152575b9b9cbe1c5c447a78efcd3">More...</a><br /></td></tr>
<tr class="separator:a97f6152575b9b9cbe1c5c447a78efcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008246c0350878f3d312b174a227b676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a008246c0350878f3d312b174a227b676">newIndirectOp</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indeffect, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, uint4 extraFlags)</td></tr>
<tr class="memdesc:a008246c0350878f3d312b174a227b676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a representative CPUI_RETURN op for <b>this</b> function.  <a href="#a008246c0350878f3d312b174a227b676">More...</a><br /></td></tr>
<tr class="separator:a008246c0350878f3d312b174a227b676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1098b768d9a176cf59e4f4c9e27cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#add1098b768d9a176cf59e4f4c9e27cb5">newIndirectCreation</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indeffect, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, bool possibleout)</td></tr>
<tr class="memdesc:add1098b768d9a176cf59e4f4c9e27cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a CPUI_INDIRECT op that <em>indirectly</em> <em>creates</em> a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#add1098b768d9a176cf59e4f4c9e27cb5">More...</a><br /></td></tr>
<tr class="separator:add1098b768d9a176cf59e4f4c9e27cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af6702bb2cf33ecc7dee059b6e3eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a90af6702bb2cf33ecc7dee059b6e3eb9">markIndirectCreation</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *indop, bool possibleOutput)</td></tr>
<tr class="memdesc:a90af6702bb2cf33ecc7dee059b6e3eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert CPUI_INDIRECT into an <em>indirect</em> <em>creation</em>.  <a href="#a90af6702bb2cf33ecc7dee059b6e3eb9">More...</a><br /></td></tr>
<tr class="separator:a90af6702bb2cf33ecc7dee059b6e3eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910ebb4d08eba9ee2f68965b6ef0898c"><td class="memItemLeft" align="right" valign="top"><a id="a910ebb4d08eba9ee2f68965b6ef0898c"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a910ebb4d08eba9ee2f68965b6ef0898c">findOp</a> (const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;sq)</td></tr>
<tr class="memdesc:a910ebb4d08eba9ee2f68965b6ef0898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with given sequence number. <br /></td></tr>
<tr class="separator:a910ebb4d08eba9ee2f68965b6ef0898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd86e17a47020d06ac8dfd3bb732fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9dd86e17a47020d06ac8dfd3bb732fe5">opInsertBefore</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *follow)</td></tr>
<tr class="memdesc:a9dd86e17a47020d06ac8dfd3bb732fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> before a specific op.  <a href="#a9dd86e17a47020d06ac8dfd3bb732fe5">More...</a><br /></td></tr>
<tr class="separator:a9dd86e17a47020d06ac8dfd3bb732fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3320ad92e11a48a06e21b8a55395a56b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3320ad92e11a48a06e21b8a55395a56b">opInsertAfter</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *prev)</td></tr>
<tr class="memdesc:a3320ad92e11a48a06e21b8a55395a56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> after a specific op.  <a href="#a3320ad92e11a48a06e21b8a55395a56b">More...</a><br /></td></tr>
<tr class="separator:a3320ad92e11a48a06e21b8a55395a56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6341eb8ca8a8004f1c77a8e8147a286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae6341eb8ca8a8004f1c77a8e8147a286">opInsertBegin</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl)</td></tr>
<tr class="memdesc:ae6341eb8ca8a8004f1c77a8e8147a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the beginning of a basic block.  <a href="#ae6341eb8ca8a8004f1c77a8e8147a286">More...</a><br /></td></tr>
<tr class="separator:ae6341eb8ca8a8004f1c77a8e8147a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad544a6136ff019bbd18c45043e9b6900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad544a6136ff019bbd18c45043e9b6900">opInsertEnd</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl)</td></tr>
<tr class="memdesc:ad544a6136ff019bbd18c45043e9b6900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the end of a basic block.  <a href="#ad544a6136ff019bbd18c45043e9b6900">More...</a><br /></td></tr>
<tr class="separator:ad544a6136ff019bbd18c45043e9b6900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cda5e2de1725ebf3fb885e375ea1a9d"><td class="memItemLeft" align="right" valign="top"><a id="a9cda5e2de1725ebf3fb885e375ea1a9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9cda5e2de1725ebf3fb885e375ea1a9d">opDeadInsertAfter</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classPcodeOp.html">PcodeOp</a> *prev)</td></tr>
<tr class="memdesc:a9cda5e2de1725ebf3fb885e375ea1a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moved given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to specified point in the <em>dead</em> list. <br /></td></tr>
<tr class="separator:a9cda5e2de1725ebf3fb885e375ea1a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d243f1e771d6e220330feb534a3fee"><td class="memItemLeft" align="right" valign="top"><a id="a99d243f1e771d6e220330feb534a3fee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a99d243f1e771d6e220330feb534a3fee">opHeritage</a> (void)</td></tr>
<tr class="memdesc:a99d243f1e771d6e220330feb534a3fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an entire heritage pass linking <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> reads to writes. <br /></td></tr>
<tr class="separator:a99d243f1e771d6e220330feb534a3fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dbf52668db4a1923537e2128719181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad9dbf52668db4a1923537e2128719181">opSetOpcode</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc)</td></tr>
<tr class="memdesc:ad9dbf52668db4a1923537e2128719181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the op-code for a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ad9dbf52668db4a1923537e2128719181">More...</a><br /></td></tr>
<tr class="separator:ad9dbf52668db4a1923537e2128719181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbfab2362e4d4945c3feb7d3f2c42f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#acdbfab2362e4d4945c3feb7d3f2c42f2">opMarkHalt</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, uint4 flag)</td></tr>
<tr class="memdesc:acdbfab2362e4d4945c3feb7d3f2c42f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark given CPUI_RETURN op as a <em>special</em> halt.  <a href="#acdbfab2362e4d4945c3feb7d3f2c42f2">More...</a><br /></td></tr>
<tr class="separator:acdbfab2362e4d4945c3feb7d3f2c42f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bd3523c574c5b303728ef4d880ec3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab2bd3523c574c5b303728ef4d880ec3a">opSetOutput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:ab2bd3523c574c5b303728ef4d880ec3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ab2bd3523c574c5b303728ef4d880ec3a">More...</a><br /></td></tr>
<tr class="separator:ab2bd3523c574c5b303728ef4d880ec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91b54da6501e12d4ad1e81ab5d0e5c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab91b54da6501e12d4ad1e81ab5d0e5c4">opUnsetOutput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:ab91b54da6501e12d4ad1e81ab5d0e5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ab91b54da6501e12d4ad1e81ab5d0e5c4">More...</a><br /></td></tr>
<tr class="separator:ab91b54da6501e12d4ad1e81ab5d0e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa079e2bd26e92671be79601535236a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63">opSetInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *vn, int4 slot)</td></tr>
<tr class="memdesc:aa079e2bd26e92671be79601535236a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a specific input operand for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#aa079e2bd26e92671be79601535236a63">More...</a><br /></td></tr>
<tr class="separator:aa079e2bd26e92671be79601535236a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae30fdfbe33ecfa6668b5579ae3e82a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1ae30fdfbe33ecfa6668b5579ae3e82a">opSwapInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot1, int4 slot2)</td></tr>
<tr class="memdesc:a1ae30fdfbe33ecfa6668b5579ae3e82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two input operands in the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a1ae30fdfbe33ecfa6668b5579ae3e82a">More...</a><br /></td></tr>
<tr class="separator:a1ae30fdfbe33ecfa6668b5579ae3e82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f821f09d862b3c908d2bce7530b90a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a16f821f09d862b3c908d2bce7530b90a">opUnsetInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot)</td></tr>
<tr class="memdesc:a16f821f09d862b3c908d2bce7530b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an input operand slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a16f821f09d862b3c908d2bce7530b90a">More...</a><br /></td></tr>
<tr class="separator:a16f821f09d862b3c908d2bce7530b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cad82485a53f428fdff619a2e523f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9cad82485a53f428fdff619a2e523f6f">opInsert</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> *&gt;::iterator iter)</td></tr>
<tr class="memdesc:a9cad82485a53f428fdff619a2e523f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at specific point in a basic block.  <a href="#a9cad82485a53f428fdff619a2e523f6f">More...</a><br /></td></tr>
<tr class="separator:a9cad82485a53f428fdff619a2e523f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0cf87976170d62df42411ffe1e10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aacf0cf87976170d62df42411ffe1e10a">opUninsert</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:aacf0cf87976170d62df42411ffe1e10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> from its basic block.  <a href="#aacf0cf87976170d62df42411ffe1e10a">More...</a><br /></td></tr>
<tr class="separator:aacf0cf87976170d62df42411ffe1e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495ebac694bc98d041e29ce05eece6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a495ebac694bc98d041e29ce05eece6f9">opUnlink</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a495ebac694bc98d041e29ce05eece6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset inputs/output and remove given PcodeOP from its basic block.  <a href="#a495ebac694bc98d041e29ce05eece6f9">More...</a><br /></td></tr>
<tr class="separator:a495ebac694bc98d041e29ce05eece6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6976625d7b40efca0bc9941cb199ee44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6976625d7b40efca0bc9941cb199ee44">opDestroy</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a6976625d7b40efca0bc9941cb199ee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and destroy its <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> operands.  <a href="#a6976625d7b40efca0bc9941cb199ee44">More...</a><br /></td></tr>
<tr class="separator:a6976625d7b40efca0bc9941cb199ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef2a6be0e9c641f72bf4e87020ddf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aeef2a6be0e9c641f72bf4e87020ddf37">opDestroyRaw</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:aeef2a6be0e9c641f72bf4e87020ddf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given <em>raw</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#aeef2a6be0e9c641f72bf4e87020ddf37">More...</a><br /></td></tr>
<tr class="separator:aeef2a6be0e9c641f72bf4e87020ddf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa062c200c86923b0f1032d4ab563e716"><td class="memItemLeft" align="right" valign="top"><a id="aa062c200c86923b0f1032d4ab563e716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa062c200c86923b0f1032d4ab563e716">opDeadAndGone</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:aa062c200c86923b0f1032d4ab563e716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources for the given <em>dead</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. <br /></td></tr>
<tr class="separator:aa062c200c86923b0f1032d4ab563e716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aee1f3697913d19bc3fb40dadf75912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8aee1f3697913d19bc3fb40dadf75912">opSetAllInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;vvec)</td></tr>
<tr class="memdesc:a8aee1f3697913d19bc3fb40dadf75912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all input Varnodes for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> simultaneously.  <a href="#a8aee1f3697913d19bc3fb40dadf75912">More...</a><br /></td></tr>
<tr class="separator:a8aee1f3697913d19bc3fb40dadf75912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84937c2241ea5679280223cc0ec8b202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a84937c2241ea5679280223cc0ec8b202">opRemoveInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, int4 slot)</td></tr>
<tr class="memdesc:a84937c2241ea5679280223cc0ec8b202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a specific input slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a84937c2241ea5679280223cc0ec8b202">More...</a><br /></td></tr>
<tr class="separator:a84937c2241ea5679280223cc0ec8b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34e641f5ee6f2ebf4aa708e21f2b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ab34e641f5ee6f2ebf4aa708e21f2b24c">opInsertInput</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *vn, int4 slot)</td></tr>
<tr class="memdesc:ab34e641f5ee6f2ebf4aa708e21f2b24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into the operand list for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#ab34e641f5ee6f2ebf4aa708e21f2b24c">More...</a><br /></td></tr>
<tr class="separator:ab34e641f5ee6f2ebf4aa708e21f2b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748e9e70a815362925e711abad0347d7"><td class="memItemLeft" align="right" valign="top"><a id="a748e9e70a815362925e711abad0347d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a748e9e70a815362925e711abad0347d7">opMarkStartBasic</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a748e9e70a815362925e711abad0347d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as starting a basic block. <br /></td></tr>
<tr class="separator:a748e9e70a815362925e711abad0347d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ad72e4b98e066287d881a6c08840a4"><td class="memItemLeft" align="right" valign="top"><a id="a71ad72e4b98e066287d881a6c08840a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a71ad72e4b98e066287d881a6c08840a4">opMarkStartInstruction</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a71ad72e4b98e066287d881a6c08840a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as starting its instruction. <br /></td></tr>
<tr class="separator:a71ad72e4b98e066287d881a6c08840a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4bb58638be599fe4f356ab934b66a6"><td class="memItemLeft" align="right" valign="top"><a id="a4f4bb58638be599fe4f356ab934b66a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4f4bb58638be599fe4f356ab934b66a6">opMarkNonPrinting</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a4f4bb58638be599fe4f356ab934b66a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as not being printed. <br /></td></tr>
<tr class="separator:a4f4bb58638be599fe4f356ab934b66a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c5af4460fc722cc49f9f499fc91c1b"><td class="memItemLeft" align="right" valign="top"><a id="ac8c5af4460fc722cc49f9f499fc91c1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac8c5af4460fc722cc49f9f499fc91c1b">opMarkSpecialPrint</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:ac8c5af4460fc722cc49f9f499fc91c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as needing special printing. <br /></td></tr>
<tr class="separator:ac8c5af4460fc722cc49f9f499fc91c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcf40584363a47d2fd79720a02f8917"><td class="memItemLeft" align="right" valign="top"><a id="affcf40584363a47d2fd79720a02f8917"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#affcf40584363a47d2fd79720a02f8917">opMarkNoCollapse</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:affcf40584363a47d2fd79720a02f8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as not collapsible. <br /></td></tr>
<tr class="separator:affcf40584363a47d2fd79720a02f8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df9afc093cf0c227bd79e1c39a7ba02"><td class="memItemLeft" align="right" valign="top"><a id="a1df9afc093cf0c227bd79e1c39a7ba02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1df9afc093cf0c227bd79e1c39a7ba02">opMarkCpoolTransformed</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a1df9afc093cf0c227bd79e1c39a7ba02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark cpool record was visited. <br /></td></tr>
<tr class="separator:a1df9afc093cf0c227bd79e1c39a7ba02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0bb4b937364f649d5d1e4e84d9a601"><td class="memItemLeft" align="right" valign="top"><a id="a0c0bb4b937364f649d5d1e4e84d9a601"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0c0bb4b937364f649d5d1e4e84d9a601">opMarkCalculatedBool</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a0c0bb4b937364f649d5d1e4e84d9a601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as having boolean output. <br /></td></tr>
<tr class="separator:a0c0bb4b937364f649d5d1e4e84d9a601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a94741d3a9e68d25cc09299d0b90656"><td class="memItemLeft" align="right" valign="top"><a id="a7a94741d3a9e68d25cc09299d0b90656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7a94741d3a9e68d25cc09299d0b90656">opMarkSpacebasePtr</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a7a94741d3a9e68d25cc09299d0b90656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as LOAD/STORE from spacebase ptr. <br /></td></tr>
<tr class="separator:a7a94741d3a9e68d25cc09299d0b90656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5cf4952800d9b8072266b67d320dcc"><td class="memItemLeft" align="right" valign="top"><a id="a6a5cf4952800d9b8072266b67d320dcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a6a5cf4952800d9b8072266b67d320dcc">opClearSpacebasePtr</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a6a5cf4952800d9b8072266b67d320dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmark <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> as using spacebase ptr. <br /></td></tr>
<tr class="separator:a6a5cf4952800d9b8072266b67d320dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635b6d2cf1ce4fdc7aa5aac967072f2e"><td class="memItemLeft" align="right" valign="top"><a id="a635b6d2cf1ce4fdc7aa5aac967072f2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a635b6d2cf1ce4fdc7aa5aac967072f2e">opFlipCondition</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a635b6d2cf1ce4fdc7aa5aac967072f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip output condition of given CBRANCH. <br /></td></tr>
<tr class="separator:a635b6d2cf1ce4fdc7aa5aac967072f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15b1cdeaad3e020a732fc31015f4547"><td class="memItemLeft" align="right" valign="top"><a id="ae15b1cdeaad3e020a732fc31015f4547"></a>
<a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae15b1cdeaad3e020a732fc31015f4547">target</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:ae15b1cdeaad3e020a732fc31015f4547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> by an instruction <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. <br /></td></tr>
<tr class="separator:ae15b1cdeaad3e020a732fc31015f4547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e8837c811e309578d2828486bcafb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a65e8837c811e309578d2828486bcafb5">createStackRef</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb off, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *stackptr, bool insertafter)</td></tr>
<tr class="memdesc:a65e8837c811e309578d2828486bcafb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an INT_ADD <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> calculating an offset to the <em>spacebase</em> register.  <a href="#a65e8837c811e309578d2828486bcafb5">More...</a><br /></td></tr>
<tr class="separator:a65e8837c811e309578d2828486bcafb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b36505bab6f7c5676157288e65d5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a37b36505bab6f7c5676157288e65d5c6">opStackLoad</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb off, uint4 sz, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classVarnode.html">Varnode</a> *stackptr, bool insertafter)</td></tr>
<tr class="memdesc:a37b36505bab6f7c5676157288e65d5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LOAD expression at an offset relative to a <em>spacebase</em> register for a given address space.  <a href="#a37b36505bab6f7c5676157288e65d5c6">More...</a><br /></td></tr>
<tr class="separator:a37b36505bab6f7c5676157288e65d5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4582ad34b4e7c851d92db8544999eaf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4582ad34b4e7c851d92db8544999eaf3">opStackStore</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb off, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op, bool insertafter)</td></tr>
<tr class="memdesc:a4582ad34b4e7c851d92db8544999eaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a STORE expression at an offset relative to a <em>spacebase</em> register for a given address space.  <a href="#a4582ad34b4e7c851d92db8544999eaf3">More...</a><br /></td></tr>
<tr class="separator:a4582ad34b4e7c851d92db8544999eaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74d3baa2516f448e7ab5f9a8151b572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad74d3baa2516f448e7ab5f9a8151b572">opUndoPtradd</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, bool finalize)</td></tr>
<tr class="memdesc:ad74d3baa2516f448e7ab5f9a8151b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a CPUI_PTRADD back into a CPUI_INT_ADD.  <a href="#ad74d3baa2516f448e7ab5f9a8151b572">More...</a><br /></td></tr>
<tr class="separator:ad74d3baa2516f448e7ab5f9a8151b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47de4c82b4a74b356153eb8e4215f639"><td class="memItemLeft" align="right" valign="top"><a id="a47de4c82b4a74b356153eb8e4215f639"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a47de4c82b4a74b356153eb8e4215f639">beginOp</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc) const</td></tr>
<tr class="memdesc:a47de4c82b4a74b356153eb8e4215f639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects with the given op-code. <br /></td></tr>
<tr class="separator:a47de4c82b4a74b356153eb8e4215f639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24461680d41c61349b3717283d8b854"><td class="memItemLeft" align="right" valign="top"><a id="ad24461680d41c61349b3717283d8b854"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad24461680d41c61349b3717283d8b854">endOp</a> (<a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc) const</td></tr>
<tr class="memdesc:ad24461680d41c61349b3717283d8b854"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects with the given op-code. <br /></td></tr>
<tr class="separator:ad24461680d41c61349b3717283d8b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a4f058ff4886d7ae4ceb8160c6f3e0"><td class="memItemLeft" align="right" valign="top"><a id="ae1a4f058ff4886d7ae4ceb8160c6f3e0"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ae1a4f058ff4886d7ae4ceb8160c6f3e0">beginOpAlive</a> (void) const</td></tr>
<tr class="memdesc:ae1a4f058ff4886d7ae4ceb8160c6f3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>alive</em> list. <br /></td></tr>
<tr class="separator:ae1a4f058ff4886d7ae4ceb8160c6f3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a64130db5cbaaa972eed4509933870"><td class="memItemLeft" align="right" valign="top"><a id="a01a64130db5cbaaa972eed4509933870"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a01a64130db5cbaaa972eed4509933870">endOpAlive</a> (void) const</td></tr>
<tr class="memdesc:a01a64130db5cbaaa972eed4509933870"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>alive</em> list. <br /></td></tr>
<tr class="separator:a01a64130db5cbaaa972eed4509933870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f98b1b212ede713c3fe936bc2c7e2ea"><td class="memItemLeft" align="right" valign="top"><a id="a2f98b1b212ede713c3fe936bc2c7e2ea"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2f98b1b212ede713c3fe936bc2c7e2ea">beginOpDead</a> (void) const</td></tr>
<tr class="memdesc:a2f98b1b212ede713c3fe936bc2c7e2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>dead</em> list. <br /></td></tr>
<tr class="separator:a2f98b1b212ede713c3fe936bc2c7e2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5974d38341f528cce4878658d11b4d0f"><td class="memItemLeft" align="right" valign="top"><a id="a5974d38341f528cce4878658d11b4d0f"></a>
list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5974d38341f528cce4878658d11b4d0f">endOpDead</a> (void) const</td></tr>
<tr class="memdesc:a5974d38341f528cce4878658d11b4d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects in the <em>dead</em> list. <br /></td></tr>
<tr class="separator:a5974d38341f528cce4878658d11b4d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbd4329856ff0c1ae80672dfbc79d83"><td class="memItemLeft" align="right" valign="top"><a id="a1bbd4329856ff0c1ae80672dfbc79d83"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a1bbd4329856ff0c1ae80672dfbc79d83">beginOpAll</a> (void) const</td></tr>
<tr class="memdesc:a1bbd4329856ff0c1ae80672dfbc79d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects sorted by sequence number. <br /></td></tr>
<tr class="separator:a1bbd4329856ff0c1ae80672dfbc79d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51e10ff92ea150cb4fe73d4fdd64dd"><td class="memItemLeft" align="right" valign="top"><a id="a7e51e10ff92ea150cb4fe73d4fdd64dd"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a7e51e10ff92ea150cb4fe73d4fdd64dd">endOpAll</a> (void) const</td></tr>
<tr class="memdesc:a7e51e10ff92ea150cb4fe73d4fdd64dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects sorted by sequence number. <br /></td></tr>
<tr class="separator:a7e51e10ff92ea150cb4fe73d4fdd64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dbd8a5ef4e19cd8e8c445cf8e43282"><td class="memItemLeft" align="right" valign="top"><a id="a07dbd8a5ef4e19cd8e8c445cf8e43282"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a07dbd8a5ef4e19cd8e8c445cf8e43282">beginOp</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:a07dbd8a5ef4e19cd8e8c445cf8e43282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects attached to a specific <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. <br /></td></tr>
<tr class="separator:a07dbd8a5ef4e19cd8e8c445cf8e43282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ddbda57c4b42954ad64ddfdc0b251"><td class="memItemLeft" align="right" valign="top"><a id="abd4ddbda57c4b42954ad64ddfdc0b251"></a>
PcodeOpTree::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#abd4ddbda57c4b42954ad64ddfdc0b251">endOp</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr) const</td></tr>
<tr class="memdesc:abd4ddbda57c4b42954ad64ddfdc0b251"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of all (alive) <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects attached to a specific <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. <br /></td></tr>
<tr class="separator:abd4ddbda57c4b42954ad64ddfdc0b251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512f5823b1a33e9430584067d77a52c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a512f5823b1a33e9430584067d77a52c5">linkJumpTable</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a512f5823b1a33e9430584067d77a52c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link jump-table with a given BRANCHIND.  <a href="#a512f5823b1a33e9430584067d77a52c5">More...</a><br /></td></tr>
<tr class="separator:a512f5823b1a33e9430584067d77a52c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a314cd3b9e823c436ac47e356da8a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9a314cd3b9e823c436ac47e356da8a39">findJumpTable</a> (const <a class="el" href="classPcodeOp.html">PcodeOp</a> *op) const</td></tr>
<tr class="memdesc:a9a314cd3b9e823c436ac47e356da8a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a jump-table associated with a given BRANCHIND.  <a href="#a9a314cd3b9e823c436ac47e356da8a39">More...</a><br /></td></tr>
<tr class="separator:a9a314cd3b9e823c436ac47e356da8a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337a544e372368eb5c41b1bb5e410932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a337a544e372368eb5c41b1bb5e410932">installJumpTable</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:a337a544e372368eb5c41b1bb5e410932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a new jump-table for the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>.  <a href="#a337a544e372368eb5c41b1bb5e410932">More...</a><br /></td></tr>
<tr class="separator:a337a544e372368eb5c41b1bb5e410932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d58c33cdc77c663fceb7de1f6aadeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a38d58c33cdc77c663fceb7de1f6aadeb">recoverJumpTable</a> (<a class="el" href="classPcodeOp.html">PcodeOp</a> *op, <a class="el" href="classFlowInfo.html">FlowInfo</a> *flow, int4 &amp;failuremode)</td></tr>
<tr class="memdesc:a38d58c33cdc77c663fceb7de1f6aadeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover destinations for a BRANCHIND by analyzing nearby data and control-flow.  <a href="#a38d58c33cdc77c663fceb7de1f6aadeb">More...</a><br /></td></tr>
<tr class="separator:a38d58c33cdc77c663fceb7de1f6aadeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30603a803c816264c105023c3456bcd7"><td class="memItemLeft" align="right" valign="top"><a id="a30603a803c816264c105023c3456bcd7"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a30603a803c816264c105023c3456bcd7">numJumpTables</a> (void) const</td></tr>
<tr class="memdesc:a30603a803c816264c105023c3456bcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of jump-tables for <b>this</b> function. <br /></td></tr>
<tr class="separator:a30603a803c816264c105023c3456bcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475047d15d64d653871facd75f7244ed"><td class="memItemLeft" align="right" valign="top"><a id="a475047d15d64d653871facd75f7244ed"></a>
<a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a475047d15d64d653871facd75f7244ed">getJumpTable</a> (int4 i)</td></tr>
<tr class="memdesc:a475047d15d64d653871facd75f7244ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th jump-table. <br /></td></tr>
<tr class="separator:a475047d15d64d653871facd75f7244ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e75df713649c7bba52b17b1b84bbcf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a2e75df713649c7bba52b17b1b84bbcf6">removeJumpTable</a> (<a class="el" href="classJumpTable.html">JumpTable</a> *jt)</td></tr>
<tr class="memdesc:a2e75df713649c7bba52b17b1b84bbcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove/delete the given jump-table.  <a href="#a2e75df713649c7bba52b17b1b84bbcf6">More...</a><br /></td></tr>
<tr class="separator:a2e75df713649c7bba52b17b1b84bbcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8010b1f0044fd3a03f8f717279ffc0b1"><td class="memItemLeft" align="right" valign="top"><a id="a8010b1f0044fd3a03f8f717279ffc0b1"></a>
<a class="el" href="classBlockGraph.html">BlockGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8010b1f0044fd3a03f8f717279ffc0b1">getStructure</a> (void)</td></tr>
<tr class="memdesc:a8010b1f0044fd3a03f8f717279ffc0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current control-flow structuring hierarchy. <br /></td></tr>
<tr class="separator:a8010b1f0044fd3a03f8f717279ffc0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036b9724068d4c5b319858e98854f31c"><td class="memItemLeft" align="right" valign="top"><a id="a036b9724068d4c5b319858e98854f31c"></a>
const <a class="el" href="classBlockGraph.html">BlockGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a036b9724068d4c5b319858e98854f31c">getStructure</a> (void) const</td></tr>
<tr class="memdesc:a036b9724068d4c5b319858e98854f31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current control-flow structuring hierarchy. <br /></td></tr>
<tr class="separator:a036b9724068d4c5b319858e98854f31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add21153afa5eb571406d1f64b8b344db"><td class="memItemLeft" align="right" valign="top"><a id="add21153afa5eb571406d1f64b8b344db"></a>
const <a class="el" href="classBlockGraph.html">BlockGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#add21153afa5eb571406d1f64b8b344db">getBasicBlocks</a> (void) const</td></tr>
<tr class="memdesc:add21153afa5eb571406d1f64b8b344db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basic blocks container. <br /></td></tr>
<tr class="separator:add21153afa5eb571406d1f64b8b344db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15885a8369e2c43c8c7883a4fabd533e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a15885a8369e2c43c8c7883a4fabd533e">setBasicBlockRange</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, const <a class="el" href="classAddress.html">Address</a> &amp;beg, const <a class="el" href="classAddress.html">Address</a> &amp;end)</td></tr>
<tr class="memdesc:a15885a8369e2c43c8c7883a4fabd533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial ownership range for the given basic block.  <a href="#a15885a8369e2c43c8c7883a4fabd533e">More...</a><br /></td></tr>
<tr class="separator:a15885a8369e2c43c8c7883a4fabd533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa486c5f0556919686a9fdad4ebc2dcc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa486c5f0556919686a9fdad4ebc2dcc1">removeDoNothingBlock</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb)</td></tr>
<tr class="memdesc:aa486c5f0556919686a9fdad4ebc2dcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block from control-flow that performs no operations.  <a href="#aa486c5f0556919686a9fdad4ebc2dcc1">More...</a><br /></td></tr>
<tr class="separator:aa486c5f0556919686a9fdad4ebc2dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fca3088c3d01a584aef0db49dfccc63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a0fca3088c3d01a584aef0db49dfccc63">removeUnreachableBlocks</a> (bool issuewarning, bool checkexistence)</td></tr>
<tr class="memdesc:a0fca3088c3d01a584aef0db49dfccc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any unreachable basic blocks.  <a href="#a0fca3088c3d01a584aef0db49dfccc63">More...</a><br /></td></tr>
<tr class="separator:a0fca3088c3d01a584aef0db49dfccc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d635570305e3ea710ade3cf090ba8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#aa2d635570305e3ea710ade3cf090ba8c">pushBranch</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, int4 slot, <a class="el" href="classBlockBasic.html">BlockBasic</a> *bbnew)</td></tr>
<tr class="memdesc:aa2d635570305e3ea710ade3cf090ba8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a control-flow edge from one block to another.  <a href="#aa2d635570305e3ea710ade3cf090ba8c">More...</a><br /></td></tr>
<tr class="separator:aa2d635570305e3ea710ade3cf090ba8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a53162bf9a1756c4f2f4d7d1d7bbcec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3a53162bf9a1756c4f2f4d7d1d7bbcec">removeBranch</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bb, int4 num)</td></tr>
<tr class="memdesc:a3a53162bf9a1756c4f2f4d7d1d7bbcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the indicated branch from a basic block.  <a href="#a3a53162bf9a1756c4f2f4d7d1d7bbcec">More...</a><br /></td></tr>
<tr class="separator:a3a53162bf9a1756c4f2f4d7d1d7bbcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad810c24ce5fb16a95de1f7d27c8856d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ad810c24ce5fb16a95de1f7d27c8856d8">nodeJoinCreateBlock</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *block1, <a class="el" href="classBlockBasic.html">BlockBasic</a> *block2, <a class="el" href="classBlockBasic.html">BlockBasic</a> *exita, <a class="el" href="classBlockBasic.html">BlockBasic</a> *exitb, bool fora_block1ishigh, bool forb_block1ishigh, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:ad810c24ce5fb16a95de1f7d27c8856d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new basic block for holding a merged CBRANCH.  <a href="#ad810c24ce5fb16a95de1f7d27c8856d8">More...</a><br /></td></tr>
<tr class="separator:ad810c24ce5fb16a95de1f7d27c8856d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e19baf8aa1db2ecde4fd12075da0694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a3e19baf8aa1db2ecde4fd12075da0694">nodeSplit</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *b, int4 inedge)</td></tr>
<tr class="memdesc:a3e19baf8aa1db2ecde4fd12075da0694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split control-flow into a basic block, duplicating its p-code into a new block.  <a href="#a3e19baf8aa1db2ecde4fd12075da0694">More...</a><br /></td></tr>
<tr class="separator:a3e19baf8aa1db2ecde4fd12075da0694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b35091642dc7527a537d01db5ad7e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#ac9b35091642dc7527a537d01db5ad7e1">forceGoto</a> (const <a class="el" href="classAddress.html">Address</a> &amp;pcop, const <a class="el" href="classAddress.html">Address</a> &amp;pcdest)</td></tr>
<tr class="memdesc:ac9b35091642dc7527a537d01db5ad7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a specific control-flow edge to be marked as <em>unstructured</em>.  <a href="#ac9b35091642dc7527a537d01db5ad7e1">More...</a><br /></td></tr>
<tr class="separator:ac9b35091642dc7527a537d01db5ad7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83619924b5d0fed25d0563b0f243262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#af83619924b5d0fed25d0563b0f243262">removeFromFlowSplit</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bl, bool swap)</td></tr>
<tr class="memdesc:af83619924b5d0fed25d0563b0f243262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a basic block splitting its control-flow into two distinct paths.  <a href="#af83619924b5d0fed25d0563b0f243262">More...</a><br /></td></tr>
<tr class="separator:af83619924b5d0fed25d0563b0f243262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba1555023c49006ed39936b9a40aba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a5ba1555023c49006ed39936b9a40aba4">switchEdge</a> (<a class="el" href="classFlowBlock.html">FlowBlock</a> *inblock, <a class="el" href="classBlockBasic.html">BlockBasic</a> *outbefore, <a class="el" href="classFlowBlock.html">FlowBlock</a> *outafter)</td></tr>
<tr class="memdesc:a5ba1555023c49006ed39936b9a40aba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch an outgoing edge from the given <em>source</em> block to flow into another block.  <a href="#a5ba1555023c49006ed39936b9a40aba4">More...</a><br /></td></tr>
<tr class="separator:a5ba1555023c49006ed39936b9a40aba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c9d7c7fb4217731ae45f7848e4034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9f0c9d7c7fb4217731ae45f7848e4034">spliceBlockBasic</a> (<a class="el" href="classBlockBasic.html">BlockBasic</a> *bl)</td></tr>
<tr class="memdesc:a9f0c9d7c7fb4217731ae45f7848e4034"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> the given basic block with the block it flows into.  <a href="#a9f0c9d7c7fb4217731ae45f7848e4034">More...</a><br /></td></tr>
<tr class="separator:a9f0c9d7c7fb4217731ae45f7848e4034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9021f01b57f8704db66341bc7f65f39f"><td class="memItemLeft" align="right" valign="top"><a id="a9021f01b57f8704db66341bc7f65f39f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a9021f01b57f8704db66341bc7f65f39f">installSwitchDefaults</a> (void)</td></tr>
<tr class="memdesc:a9021f01b57f8704db66341bc7f65f39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure default switch cases are properly labeled. <br /></td></tr>
<tr class="separator:a9021f01b57f8704db66341bc7f65f39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8af7249a90794ba6001046e28c0aeb5c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a8af7249a90794ba6001046e28c0aeb5c">replaceLessequal</a> (<a class="el" href="classFuncdata.html">Funcdata</a> &amp;data, <a class="el" href="classPcodeOp.html">PcodeOp</a> *op)</td></tr>
<tr class="memdesc:a8af7249a90794ba6001046e28c0aeb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace INT_LESSEQUAL and INT_SLESSEQUAL expressions.  <a href="#a8af7249a90794ba6001046e28c0aeb5c">More...</a><br /></td></tr>
<tr class="separator:a8af7249a90794ba6001046e28c0aeb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4456bfc523a4527c9fd924ecadacec63"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFuncdata.html#a4456bfc523a4527c9fd924ecadacec63">compareCallspecs</a> (const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *a, const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *b)</td></tr>
<tr class="memdesc:a4456bfc523a4527c9fd924ecadacec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare call specification objects by call site address.  <a href="#a4456bfc523a4527c9fd924ecadacec63">More...</a><br /></td></tr>
<tr class="separator:a4456bfc523a4527c9fd924ecadacec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Container for data structures associated with a single function. </p>
<p>This class holds the primary data structures for decompiling a function. In particular it holds control-flow, data-flow, and prototype information, plus class instances to help with constructing SSA form, structure control-flow, recover jump-tables, recover parameters, and merge Varnodes. In most cases it acts as the main API for querying and accessing these structures.</p>
<p>Some important groups of public methods include:</p><ul>
<li><a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> manipulation (mostly starting with 'op')</li>
<li><a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> search and traversal ('beginOp*' and 'endOp*')</li>
<li><a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> creation ('new*' methods)</li>
<li><a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> search and traversal ('beginLoc' 'endLoc' 'beginDef' and 'endDef')</li>
<li>Basic block access and block structuring</li>
<li>Access to subfunction prototypes</li>
<li>Access to jump-tables (within the body of the function) </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aacdd409dd207aaa412afc5726bc86f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdd409dd207aaa412afc5726bc86f6d">&#9670;&nbsp;</a></span>Funcdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Funcdata::Funcdata </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classScope.html">Scope</a> *&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classConstructor.html">Constructor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the (base) name of the function </td></tr>
    <tr><td class="paramname">scope</td><td>is <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> scope associated with the function </td></tr>
    <tr><td class="paramname">addr</td><td>is the entry address for the function </td></tr>
    <tr><td class="paramname">sz</td><td>is the number of bytes (of code) in the function body </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35c51952540dbda3f11962b22c3064a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c51952540dbda3f11962b22c3064a3">&#9670;&nbsp;</a></span>adjustInputVarnodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::adjustInputVarnodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust input Varnodes contained in the given range. </p>
<p>After this call, a single <em>input</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will exist that fills the given range. Any previous input Varnodes contained in this range are redefined using a SUBPIECE op off of the new single input. If an overlapping <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> isn't fully contained an exception is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfa02a817ac34b428cac2a327d1891c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa02a817ac34b428cac2a327d1891c0">&#9670;&nbsp;</a></span>ancestorOpUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::ancestorOpUse </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>maxlevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>invn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParamTrial.html">ParamTrial</a> &amp;&#160;</td>
          <td class="paramname"><em>trial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given trial <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is likely only used for parameter passing. </p>
<p>Flow is followed from the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> itself and from ancestors the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was copied from to see if it hits anything other than the given CALL or RETURN operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlevel</td><td>is the maximum number of times to recurse through ancestor copies </td></tr>
    <tr><td class="paramname">invn</td><td>is the given trial <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to test </td></tr>
    <tr><td class="paramname">op</td><td>is the given CALL or RETURN </td></tr>
    <tr><td class="paramname">trial</td><td>is the associated parameter trial object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is only used for the CALL/RETURN </dd></dl>

</div>
</div>
<a id="adeee32fc648486d26cd17ebb37bb118f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeee32fc648486d26cd17ebb37bb118f">&#9670;&nbsp;</a></span>attemptDynamicMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::attemptDynamicMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;&#160;</td>
          <td class="paramname"><em>dhash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map properties of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a dynamic mapping, try to find the mapped <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, then adjust (type and flags) to reflect this mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the (dynamic) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry </td></tr>
    <tr><td class="paramname">dhash</td><td>is the dynamic mapping information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was adjusted </dd></dl>

</div>
</div>
<a id="a69dddb637a6e322632f9a4bb10c5c36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dddb637a6e322632f9a4bb10c5c36e">&#9670;&nbsp;</a></span>attemptDynamicMappingLate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::attemptDynamicMappingLate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicHash.html">DynamicHash</a> &amp;&#160;</td>
          <td class="paramname"><em>dhash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the name of a dynamic symbol to a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a dynamic mapping, try to find the mapped <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, then attach the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The name of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is used, but the data-type and possibly other properties are not put on the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the (dynamic) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry </td></tr>
    <tr><td class="paramname">dhash</td><td>is the dynamic mapping information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was adjusted </dd></dl>

</div>
</div>
<a id="aa15db3d569027578de69c065fc607c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15db3d569027578de69c065fc607c63">&#9670;&nbsp;</a></span>buildDynamicSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::buildDynamicSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <em>dynamic</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>If a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is already attached, no change is made. Otherwise a special <em>dynamic</em> <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is created that is associated with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> via a hash of its local data-flow (rather than its storage address). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b338d2b2d1a72db73369e8631125ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b338d2b2d1a72db73369e8631125ffd">&#9670;&nbsp;</a></span>calcNZMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::calcNZMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <em>non-zero</em> masks for all Varnodes. </p>
<p>All Varnodes are initialized assuming that all its bits are possibly non-zero. This method looks for situations where a p-code produces a value that is known to have some bits that are guaranteed to be zero. It updates the state of the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> then tries to push the information forward through the data-flow until additional changes are apparent. </p>

</div>
</div>
<a id="add076d930ec2ceb66453451e478ca7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add076d930ec2ceb66453451e478ca7d4">&#9670;&nbsp;</a></span>checkCallDoubleUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::checkCallDoubleUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>opmatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;&#160;</td>
          <td class="paramname"><em>trial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for legitimate double use of a parameter trial. </p>
<p>The given trial is a <em>putative</em> input to first CALL, but can also trace its data-flow into a second CALL. Return <b>false</b> if this leads us to conclude that the trial is not a likely parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opmatch</td><td>is the first CALL linked to the trial </td></tr>
    <tr><td class="paramname">op</td><td>is the second CALL </td></tr>
    <tr><td class="paramname">vn</td><td>is the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> parameter for the second CALL </td></tr>
    <tr><td class="paramname">trial</td><td>is the given parameter trial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> for a legitimate double use </dd></dl>

</div>
</div>
<a id="a4096b0e76e9015f9aa61fa56cb85d79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4096b0e76e9015f9aa61fa56cb85d79c">&#9670;&nbsp;</a></span>clearDeadVarnodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::clearDeadVarnodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete any dead Varnodes. </p>
<p>Free any Varnodes not attached to anything. This is only performed at fixed times so that editing operations can detach (and then reattach) Varnodes without losing them. </p>

</div>
</div>
<a id="a5acc07e00146316532a3806cd19815bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acc07e00146316532a3806cd19815bb">&#9670;&nbsp;</a></span>clearSymbolLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::clearSymbolLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHighVariable.html">HighVariable</a> *&#160;</td>
          <td class="paramname"><em>high</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Symbols attached to Varnodes in the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>. </p>
<p>For each instance <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, remove any <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> reference and associated properties. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>is the given <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1da8e9506c5b37fce86d165974a4cafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da8e9506c5b37fce86d165974a4cafb">&#9670;&nbsp;</a></span>cloneOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::cloneOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a clone of the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>, copying control-flow properties as well. The data-type is <em>not</em> cloned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to clone </td></tr>
    <tr><td class="paramname">seq</td><td>is the (possibly custom) sequence number to associate with the clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cloned <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

</div>
</div>
<a id="a4456bfc523a4527c9fd924ecadacec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4456bfc523a4527c9fd924ecadacec63">&#9670;&nbsp;</a></span>compareCallspecs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::compareCallspecs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare call specification objects by call site address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first call specification to compare </td></tr>
    <tr><td class="paramname">b</td><td>is the second call specification </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first call specification should come before the second </dd></dl>

</div>
</div>
<a id="a65e8837c811e309578d2828486bcafb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e8837c811e309578d2828486bcafb5">&#9670;&nbsp;</a></span>createStackRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::createStackRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an INT_ADD <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> calculating an offset to the <em>spacebase</em> register. </p>
<p>The <em>spacebase</em> register is looked up for the given address space, or an optional previously existing register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be provided. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">off</td><td>is the offset to calculate relative to the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">op</td><td>is the insertion point <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">stackptr</td><td>is the <em>spacebase</em> register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (if available) </td></tr>
    <tr><td class="paramname">insertafter</td><td>is <b>true</b> if new ops are inserted <em>after</em> the insertion point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>unique</em> space <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the calculated offset </dd></dl>

</div>
</div>
<a id="adaf432bbbd299e976c8f02fc97fb3dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf432bbbd299e976c8f02fc97fb3dbe">&#9670;&nbsp;</a></span>deadRemovalAllowed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::deadRemovalAllowed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if dead code removal is allowed for a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the specific address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if dead code removal is allowed </dd></dl>

</div>
</div>
<a id="adba7696040378f0eaa679e684b72bf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba7696040378f0eaa679e684b72bf96">&#9670;&nbsp;</a></span>deadRemovalAllowedSeen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::deadRemovalAllowedSeen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if dead Varnodes have been removed for a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the specific address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if dead code removal has happened in the space </dd></dl>

</div>
</div>
<a id="a08f9cac25647eca390a509d98f76b9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f9cac25647eca390a509d98f76b9ac">&#9670;&nbsp;</a></span>doLiveInject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::doLiveInject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classInjectPayload.html">InjectPayload</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> *&gt;::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject p-code from a <em>payload</em> into <b>this</b> live function. </p>
<p>Raw PcodeOps are generated from the payload within a given basic block at a specific position in <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>is the injection payload </td></tr>
    <tr><td class="paramname">addr</td><td>is the address at the point of injection </td></tr>
    <tr><td class="paramname">bl</td><td>is the given basic block holding the new ops </td></tr>
    <tr><td class="paramname">iter</td><td>indicates the point of insertion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a142938fffbfd5add2b6679a6b9b0d7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142938fffbfd5add2b6679a6b9b0d7fa">&#9670;&nbsp;</a></span>fillinExtrapop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Funcdata::fillinExtrapop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover and return the <em>extrapop</em> for this function. </p>
<p>If <em>extrapop</em> is unknown, recover it from what we know about this function and set the value permanently for <b>this</b> <a class="el" href="classFuncdata.html" title="Container for data structures associated with a single function. ">Funcdata</a> object. If there is no function body it may be impossible to know the value, in which case this returns the reserved value indicating <em>extrapop</em> is unknown.</p>
<dl class="section return"><dt>Returns</dt><dd>the recovered value </dd></dl>

</div>
</div>
<a id="af47b9524aee42c71c7dbe260a4052485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47b9524aee42c71c7dbe260a4052485">&#9670;&nbsp;</a></span>fillinReadOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::fillinReadOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with its (constant) value in the load image. </p>
<p>Treat the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as read-only, look up its value in <a class="el" href="classLoadImage.html" title="An interface into a particular binary executable image. ">LoadImage</a> and replace read references with the value as a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if any change was made </dd></dl>

</div>
</div>
<a id="a8fa3242779be4a766a37227deb728836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa3242779be4a766a37227deb728836">&#9670;&nbsp;</a></span>findCoveredInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findCoveredInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> covered by the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the range in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the starting address of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

</div>
</div>
<a id="a6461d0bee74dda24aafa2caa40d0fee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6461d0bee74dda24aafa2caa40d0fee7">&#9670;&nbsp;</a></span>findCoveringInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findCoveringInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that contains the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the range in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the starting address of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

</div>
</div>
<a id="aa34c7b2d0d5f4cb28e0a2602d3cba033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34c7b2d0d5f4cb28e0a2602d3cba033">&#9670;&nbsp;</a></span>findHigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHighVariable.html">HighVariable</a> * Funcdata::findHigh </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a high-level variable by name. </p>
<p>Look up the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> visible in <b>this</b> function's <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a> and return the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> associated with it. If the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> doesn't exist or there is no <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding at least part of the value of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, NULL is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> or NULL </dd></dl>

</div>
</div>
<a id="a9a314cd3b9e823c436ac47e356da8a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a314cd3b9e823c436ac47e356da8a39">&#9670;&nbsp;</a></span>findJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::findJumpTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a jump-table associated with a given BRANCHIND. </p>
<p>Look up the jump-table object with the matching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> address </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching jump-table object or NULL </dd></dl>

</div>
</div>
<a id="a9debba02fdd2a35a5bc5d7cd57fbcd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9debba02fdd2a35a5bc5d7cd57fbcd5f">&#9670;&nbsp;</a></span>findLinkedVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::findLinkedVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> matching the given <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> mapping. </p>
<p>Return the (first) <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that matches the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or null </dd></dl>

</div>
</div>
<a id="ae03500cc804152adff478e961fdfc8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03500cc804152adff478e961fdfc8ec">&#9670;&nbsp;</a></span>findLinkedVarnodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::findLinkedVarnodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Varnodes that map to the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a>. </p>
<p>Look for Varnodes that are (should be) mapped to the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> and add them to the end of the result list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>is the given <a class="el" href="classSymbolEntry.html" title="A storage location for a particular Symbol. ">SymbolEntry</a> to match </td></tr>
    <tr><td class="paramname">res</td><td>is the container holding the result list of matching Varnodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eee1ea3fa8e72d17549a936567c97bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eee1ea3fa8e72d17549a936567c97bf">&#9670;&nbsp;</a></span>findSpacebaseInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::findSpacebaseInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an address space, like <em>stack</em>, that is known to have a base register pointing to it, try to locate the unique <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that holds the input value of this register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the <em>stack</em> like address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (or NULL if it doesn't exist) </dd></dl>

</div>
</div>
<a id="a718cc133e6ade757ee532f0d704c04d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718cc133e6ade757ee532f0d704c04d4">&#9670;&nbsp;</a></span>findVarnodeInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findVarnodeInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with the given size and storage address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the storage address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

</div>
</div>
<a id="acb7ae831db646e2f9d64ffb2b51fa7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7ae831db646e2f9d64ffb2b51fa7f1">&#9670;&nbsp;</a></span>findVarnodeWritten()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a>* Funcdata::findVarnodeWritten </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintm&#160;</td>
          <td class="paramname"><em>uniq</em> = <code>~((uintm)0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a defined <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> via its storage address and its definition address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size in bytes </td></tr>
    <tr><td class="paramname">loc</td><td>is the storage address </td></tr>
    <tr><td class="paramname">pc</td><td>is the address where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is defined </td></tr>
    <tr><td class="paramname">uniq</td><td>is an (optional) sequence number to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> or NULL </dd></dl>

</div>
</div>
<a id="a91b3b1d1d751868c394eda804afa0bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b3b1d1d751868c394eda804afa0bc8">&#9670;&nbsp;</a></span>followFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::followFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>baddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>eaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>insn_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate raw p-code for the function. </p>
<p>Follow flow from the entry point generating PcodeOps for each instruction encountered. The caller can provide a bounding range that constrains where control can flow to and can also provide a maximum number of instructions that will be followed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baddr</td><td>is the beginning of the constraining range </td></tr>
    <tr><td class="paramname">eaddr</td><td>is the end of the constraining range </td></tr>
    <tr><td class="paramname">insn_max</td><td>is the maximum number of instructions to follow </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b35091642dc7527a537d01db5ad7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b35091642dc7527a537d01db5ad7e1">&#9670;&nbsp;</a></span>forceGoto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::forceGoto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pcop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pcdest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a specific control-flow edge to be marked as <em>unstructured</em>. </p>
<p>The edge is specified by a source and destination <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> (of the branch). The resulting control-flow structure will have a <em>goto</em> statement modeling the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcop</td><td>is the source <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">pcdest</td><td>is the destination <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a control-flow edge was successfully labeled </dd></dl>

</div>
</div>
<a id="a97f6152575b9b9cbe1c5c447a78efcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f6152575b9b9cbe1c5c447a78efcd3">&#9670;&nbsp;</a></span>getFirstReturnOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::getFirstReturnOp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> into <b>this</b> function. </p>
<p>Return the first CPUI_RETURN operation that is not dead or an artificial halt </p><dl class="section return"><dt>Returns</dt><dd>a representative CPUI_RETURN op or NULL if there are none </dd></dl>

</div>
</div>
<a id="ae349f4a44febd9dd27ca63f7f8840103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae349f4a44febd9dd27ca63f7f8840103">&#9670;&nbsp;</a></span>hasRestartPending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::hasRestartPending </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does <b>this</b> function need to restart its analysis. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if analysis should be restarted </dd></dl>

</div>
</div>
<a id="afef27da9040d28296accaaa1c1982401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef27da9040d28296accaaa1c1982401">&#9670;&nbsp;</a></span>hasUnimplemented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::hasUnimplemented </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does <b>this</b> function have instructions marked as <em>unimplemented</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the function's body contains at least one unimplemented instruction </dd></dl>

</div>
</div>
<a id="ae454fbd3566fbd43103dcabdf2681fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae454fbd3566fbd43103dcabdf2681fd8">&#9670;&nbsp;</a></span>initActiveOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::initActiveOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize <em>return</em> prototype recovery analysis </p>

</div>
</div>
<a id="a3bcc11dc2a2eefa48bc4b244094a521f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcc11dc2a2eefa48bc4b244094a521f">&#9670;&nbsp;</a></span>inlineFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::inlineFlow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>inlinefd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowInfo.html">FlowInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>callop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-line the p-code from another function into <b>this</b> function. </p>
<p>Raw PcodeOps for the in-line function are generated and then cloned into <b>this</b> function. Depending on the control-flow complexity of the in-line function, the PcodeOps are injected as if they are all part of the call site address (EZModel), or the PcodeOps preserve their address and extra branch instructions are inserted to integrate control-flow of the in-line into the calling function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inlinefd</td><td>is the function to in-line </td></tr>
    <tr><td class="paramname">flow</td><td>is the flow object being injected </td></tr>
    <tr><td class="paramname">callop</td><td>is the site of the injection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the injection was successful </dd></dl>

</div>
</div>
<a id="a337a544e372368eb5c41b1bb5e410932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337a544e372368eb5c41b1bb5e410932">&#9670;&nbsp;</a></span>installJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::installJumpTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a new jump-table for the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<p>The given address must have a BRANCHIND op attached to it. This is suitable for installing an override and must be called before flow has been traced. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new jump-table object </dd></dl>

</div>
</div>
<a id="a803cbb38fe59825f59858a16afa54b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803cbb38fe59825f59858a16afa54b7d">&#9670;&nbsp;</a></span>isHeritaged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::isHeritaged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has been linked in fully to the syntax tree (SSA) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the specific <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is fully linked </dd></dl>

</div>
</div>
<a id="a512f5823b1a33e9430584067d77a52c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512f5823b1a33e9430584067d77a52c5">&#9670;&nbsp;</a></span>linkJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::linkJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link jump-table with a given BRANCHIND. </p>
<p>Look up the jump-table object with the matching <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> address, then attach the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching jump-table object or NULL </dd></dl>

</div>
</div>
<a id="afbb3bc5ac9e2c09eda544db34b8f5879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb3bc5ac9e2c09eda544db34b8f5879">&#9670;&nbsp;</a></span>linkSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Funcdata::linkSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find or create <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> associated with given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>The <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> is really attached to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>'s <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> (which must exist). The only reason a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> doesn't get set is if, the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> is global and there is no pre-existing <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>. (see <a class="el" href="classFuncdata.html#aed6aefa7321e887e3b759de94e4d3d4f" title="Make sure there is a Symbol entry for all global Varnodes. ">mapGlobals()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> or NULL </dd></dl>

</div>
</div>
<a id="a736351e8eb6c044fe00deb0cf7e6b5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736351e8eb6c044fe00deb0cf7e6b5c5">&#9670;&nbsp;</a></span>linkSymbolReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymbol.html">Symbol</a> * Funcdata::linkSymbolReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover and attach <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a constant reference. </p>
<p>A reference to a symbol (i.e. &amp;varname) is typically stored as a PTRSUB operation, where the first input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a <em>spacebase</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> indicating whether the symbol is on the <em>stack</em> or at a <em>global</em> RAM location. The second input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is a constant encoding the address of the symbol. This method takes this constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, recovers the symbol it is referring to, and stores on the <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> object attached to the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (second input) to a PTRSUB operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the symbol being referred to or null </dd></dl>

</div>
</div>
<a id="aed6aefa7321e887e3b759de94e4d3d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6aefa7321e887e3b759de94e4d3d4f">&#9670;&nbsp;</a></span>mapGlobals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::mapGlobals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure there is a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> entry for all global Varnodes. </p>
<p>Search for <em>addrtied</em> Varnodes whose storage falls in the global <a class="el" href="classScope.html" title="A collection of Symbol objects within a single (namespace or functional) scope. ">Scope</a>, then build a new global <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> if one didn't exist before. </p>

</div>
</div>
<a id="a90af6702bb2cf33ecc7dee059b6e3eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90af6702bb2cf33ecc7dee059b6e3eb9">&#9670;&nbsp;</a></span>markIndirectCreation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::markIndirectCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>possibleOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert CPUI_INDIRECT into an <em>indirect</em> <em>creation</em>. </p>
<p>Data-flow through the given CPUI_INDIRECT op is marked so that the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is considered <em>indirectly</em> <em>created</em>. An <em>indirectly</em> <em>created</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> effectively has no data-flow before the INDIRECT op that defines it, and the value contained by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not explicitly calculable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indop</td><td>is the given CPUI_INDIRECT op </td></tr>
    <tr><td class="paramname">possibleOutput</td><td>is <b>true</b> if INDIRECT should be marked as a possible call output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41dc1e061256c4cc55e7afcf5995f435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dc1e061256c4cc55e7afcf5995f435">&#9670;&nbsp;</a></span>markIndirectOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::markIndirectOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark <em>illegal</em> <em>input</em> Varnodes used only in INDIRECTs. </p>
<p>The illegal inputs are additionally marked as <b>indirectonly</b> and isIndirectOnly() returns <b>true</b>. </p>

</div>
</div>
<a id="a4a3a408927e4fe3324d7c589a2fa1e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3a408927e4fe3324d7c589a2fa1e2c">&#9670;&nbsp;</a></span>markLanedVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::markLanedVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLanedRegister.html">LanedRegister</a> *&#160;</td>
          <td class="paramname"><em>lanedReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as potential laned register. </p>
<p>Record the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as a potential laned register access. The address and size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is recorded, anticipating that new Varnodes at the same storage location may be created </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to mark </td></tr>
    <tr><td class="paramname">lanedReg</td><td>is the laned register record to associate with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e80f56ef371a0010a9e67ae8510086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e80f56ef371a0010a9e67ae8510086">&#9670;&nbsp;</a></span>newCodeRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newCodeRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a code address <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A reference to a specific <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> is encoded in a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is an <em>annotation</em> in the sense that it will hold no value in the data-flow, it will will only hold a reference to an address. This is used specifically by the branch p-code operations to hold destination addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="af58542dbcc89f4b84ffc8834b023125b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58542dbcc89f4b84ffc8834b023125b">&#9670;&nbsp;</a></span>newConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newConstant </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>constant_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>constant</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is allocated which represents the indicated constant value. Its storage address is in the <em>constant</em> address space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">constant_val</td><td>is the indicated constant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object </dd></dl>

</div>
</div>
<a id="add1098b768d9a176cf59e4f4c9e27cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1098b768d9a176cf59e4f4c9e27cb5">&#9670;&nbsp;</a></span>newIndirectCreation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newIndirectCreation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indeffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>possibleout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a CPUI_INDIRECT op that <em>indirectly</em> <em>creates</em> a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>An <em>indirectly</em> <em>created</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> effectively has no data-flow before the INDIRECT op that defines it, and the value contained by the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is not explicitly calculable. The new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is allocated with a given storage range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeffect</td><td>is the p-code causing the indirect effect </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage range </td></tr>
    <tr><td class="paramname">possibleout</td><td>is <b>true</b> if the output should be treated as a <em>directwrite</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new CPUI_INDIRECT op </dd></dl>

</div>
</div>
<a id="a008246c0350878f3d312b174a227b676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008246c0350878f3d312b174a227b676">&#9670;&nbsp;</a></span>newIndirectOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newIndirectOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>indeffect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>extraFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a representative CPUI_RETURN op for <b>this</b> function. </p>
<p>Create a new CPUI_INDIRECT around a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with an indirect effect.</p>
<p>Typically this is used to annotate data-flow, for the given storage range, passing through a CALL or STORE. An output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is automatically created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeffect</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with the indirect effect </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the storage range to protect </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage range </td></tr>
    <tr><td class="paramname">extraFlags</td><td>are extra boolean properties to put on the INDIRECT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new CPUI_INDIRECT op </dd></dl>

</div>
</div>
<a id="a1b1e9831bb4b1c65df6950ae1f15e0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1e9831bb4b1c65df6950ae1f15e0be">&#9670;&nbsp;</a></span>newOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newOp </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>is the number of operands the new op will have </td></tr>
    <tr><td class="paramname">pc</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> associated with the new op </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

</div>
</div>
<a id="a0d122aa09d739e59a5107338f8ecd8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d122aa09d739e59a5107338f8ecd8ab">&#9670;&nbsp;</a></span>newOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newOp </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<p>This method is typically used for cloning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>is the number of operands the new op will have </td></tr>
    <tr><td class="paramname">sq</td><td>is the sequence number (<a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> and sub-index) of the new op </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

</div>
</div>
<a id="ae1126d213d88120c9e55b5779d746859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1126d213d88120c9e55b5779d746859">&#9670;&nbsp;</a></span>newOpBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::newOpBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>follow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>in3</em> = <code>(<a class="el" href="classVarnode.html">Varnode</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with sequence number. </p>
<p>Create new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with 2 or 3 given operands.</p>
<p>The new op will have a <em>unique</em> space output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and will be inserted before the given <em>follow</em> op. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">follow</td><td>is the <em>follow</em> up to insert the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> before </td></tr>
    <tr><td class="paramname">opc</td><td>is the op-code of the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">in1</td><td>is the first operand </td></tr>
    <tr><td class="paramname">in2</td><td>is the second operand </td></tr>
    <tr><td class="paramname">in3</td><td>is the optional third param </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

</div>
</div>
<a id="ac083b7d6637a5883ef8cbd38e7756837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac083b7d6637a5883ef8cbd38e7756837">&#9670;&nbsp;</a></span>newSpacebasePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newSpacebasePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <em>spacebase</em> register for a given address space. </p>
<p>Given an address space, like <em>stack</em>, that is known to have a base register pointing to it, construct a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> representing that register. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the <em>stack</em> like address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated stack-pointer <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="a731f6fd415269577b7bb1943315b8a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731f6fd415269577b7bb1943315b8a76">&#9670;&nbsp;</a></span>newUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newUnique </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em> = <code>(<a class="el" href="classDatatype.html">Datatype</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>temporary</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A new temporary register storage location is allocated from the <em>unique</em> address space </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">ct</td><td>is an optional data-type to associated with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>temporary</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="af189a9a5b390332c6e87c8faa334cd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af189a9a5b390332c6e87c8faa334cd68">&#9670;&nbsp;</a></span>newUniqueOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newUniqueOut </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <em>temporary</em> output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Allocate a new register from the <em>unique</em> address space and create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object representing it as an output to the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> whose output is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new temporary register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="a22894e1c7b0f30a5391993924cd96d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22894e1c7b0f30a5391993924cd96d3d">&#9670;&nbsp;</a></span>newVarnode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnode </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDatatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>ct</em> = <code>(<a class="el" href="classDatatype.html">Datatype</a>&#160;*)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new unattached <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">m</td><td>is the storage <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">ct</td><td>is a data-type to associate with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object </dd></dl>

</div>
</div>
<a id="a0d6888d1606fd8ed6372355995bc7887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6888d1606fd8ed6372355995bc7887">&#9670;&nbsp;</a></span>newVarnode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnode </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> given an address space and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">base</td><td>is the address space of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">off</td><td>is the offset into the address space of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="a13da637294b7cae252ffc6c9e2116da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13da637294b7cae252ffc6c9e2116da2">&#9670;&nbsp;</a></span>newVarnodeCallSpecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeCallSpecs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>fc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a call specification <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>A call specification (<a class="el" href="classFuncCallSpecs.html" title="A class for analyzing parameters to a sub-function call. ">FuncCallSpecs</a>) is encoded into an <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is used specifically as an input to CPUI_CALL ops to speed up access to their associated call specification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fc</td><td>is the call specification to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="a8ee39fe2d1f2f4702864e78dc06e6bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee39fe2d1f2f4702864e78dc06e6bb8">&#9670;&nbsp;</a></span>newVarnodeIop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeIop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Create a special <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that holds a pointer reference to a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. This is used specifically to let a CPUI_INDIRECT op refer to the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> it is holding an indirect effect for. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to encode in the annotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated <em>annotation</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="a100e6704e4c245e076170268d31b47ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100e6704e4c245e076170268d31b47ec">&#9670;&nbsp;</a></span>newVarnodeOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeOut </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Create a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> which is already defined as output of a given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. This if more efficient as it avoids the initial insertion of the free form of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into the tree, and queryProperties only needs to be called once. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the size of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in bytes </td></tr>
    <tr><td class="paramname">m</td><td>is the storage <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> whose output is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> object </dd></dl>

</div>
</div>
<a id="acc9f6fb3e8a36e0e1e633660fc05fdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9f6fb3e8a36e0e1e633660fc05fdbf">&#9670;&nbsp;</a></span>newVarnodeSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::newVarnodeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> referring to an address space. </p>
<p>A reference to a particular address space is encoded as a constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. These are used for LOAD and STORE p-code ops in particular. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="ad810c24ce5fb16a95de1f7d27c8856d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad810c24ce5fb16a95de1f7d27c8856d8">&#9670;&nbsp;</a></span>nodeJoinCreateBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockBasic.html">BlockBasic</a> * Funcdata::nodeJoinCreateBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>block2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>exita</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>exitb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fora_block1ishigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forb_block1ishigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new basic block for holding a merged CBRANCH. </p>
<p>This is used by <a class="el" href="classConditionalJoin.html" title="Discover and eliminate split conditions. ">ConditionalJoin</a> to do the low-level control-flow manipulation to merge identical conditional branches. Given basic blocks containing the two CBRANCH ops to merge, the new block gets one of the two out edges from each block, and the remaining out edges are changed to point into the new block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block1</td><td>is the basic block containing the first CBRANCH to merge </td></tr>
    <tr><td class="paramname">block2</td><td>is the basic block containing the second CBRANCH </td></tr>
    <tr><td class="paramname">exita</td><td>is the first common exit block for the CBRANCHs </td></tr>
    <tr><td class="paramname">exitb</td><td>is the second common exit block </td></tr>
    <tr><td class="paramname">fora_block1ishigh</td><td>designates which edge is moved for exita </td></tr>
    <tr><td class="paramname">forb_block1ishigh</td><td>designates which edge is moved for exitb </td></tr>
    <tr><td class="paramname">addr</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> associated with (1 of the) CBRANCH ops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new basic block </dd></dl>

</div>
</div>
<a id="a3e19baf8aa1db2ecde4fd12075da0694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e19baf8aa1db2ecde4fd12075da0694">&#9670;&nbsp;</a></span>nodeSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::nodeSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>inedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split control-flow into a basic block, duplicating its p-code into a new block. </p>
<p>P-code is duplicated into another block, and control-flow is modified so that the new block takes over flow from one input edge to the original block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>is the basic block to be duplicated and split </td></tr>
    <tr><td class="paramname">inedge</td><td>is the index of the input edge to move to the duplicate block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a363bd02cb2f20cf1583951d5429a057b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363bd02cb2f20cf1583951d5429a057b">&#9670;&nbsp;</a></span>numHeritagePasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Funcdata::numHeritagePasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of heritage passes performed for the given address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of passes performed </dd></dl>

</div>
</div>
<a id="a07ddc6cd232b4a101968d960fda9b965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ddc6cd232b4a101968d960fda9b965">&#9670;&nbsp;</a></span>onlyOpUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::onlyOpUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>invn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>opmatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParamTrial.html">ParamTrial</a> &amp;&#160;</td>
          <td class="paramname"><em>trial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> seems to only be used by a CALL. </p>
<p>Part of testing whether a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> makes sense as parameter passing storage is looking for different explicit uses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">opmatch</td><td>is the putative CALL op using the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for parameter passing </td></tr>
    <tr><td class="paramname">trial</td><td>is the parameter trial object associated with the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> seems only to be used as parameter to <b>opmatch</b> </dd></dl>

</div>
</div>
<a id="a6976625d7b40efca0bc9941cb199ee44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6976625d7b40efca0bc9941cb199ee44">&#9670;&nbsp;</a></span>opDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and destroy its <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> operands. </p>
<p>All input and output Varnodes to the op are destroyed (their object resources freed), and the op is permanently moved to the <em>dead</em> list. To call this routine, make sure that either:</p><ul>
<li>The op has no output</li>
<li>The op's output has no descendants</li>
<li>or all descendants of output are also going to be destroyed</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeef2a6be0e9c641f72bf4e87020ddf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef2a6be0e9c641f72bf4e87020ddf37">&#9670;&nbsp;</a></span>opDestroyRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opDestroyRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given <em>raw</em> <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>This is a specialized routine for deleting an op during flow generation that has been replaced by something else. The op is expected to be <em>dead</em> with none of its inputs or outputs linked to anything else. Both the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and all the input/output Varnodes are destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cad82485a53f428fdff619a2e523f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cad82485a53f428fdff619a2e523f6f">&#9670;&nbsp;</a></span>opInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; <a class="el" href="classPcodeOp.html">PcodeOp</a> *&gt;::iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at specific point in a basic block. </p>
<p>The <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is removed from the <em>dead</em> list and is inserted <em>immediately</em> before the specified iterator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">bl</td><td>is the basic block being inserted into </td></tr>
    <tr><td class="paramname">iter</td><td>indicates exactly where the op is inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3320ad92e11a48a06e21b8a55395a56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3320ad92e11a48a06e21b8a55395a56b">&#9670;&nbsp;</a></span>opInsertAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> after a specific op. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted <em>immediately</em> after the <em>prev</em> op except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">prev</td><td>is the op to insert after </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dd86e17a47020d06ac8dfd3bb732fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd86e17a47020d06ac8dfd3bb732fe5">&#9670;&nbsp;</a></span>opInsertBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>follow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> before a specific op. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted <em>immediately</em> before the <em>follow</em> op except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">follow</td><td>is the op to insert before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6341eb8ca8a8004f1c77a8e8147a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6341eb8ca8a8004f1c77a8e8147a286">&#9670;&nbsp;</a></span>opInsertBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the beginning of a basic block. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted as the <em>first</em> op in the basic block except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">bl</td><td>is the basic block to insert into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad544a6136ff019bbd18c45043e9b6900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad544a6136ff019bbd18c45043e9b6900">&#9670;&nbsp;</a></span>opInsertEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> at the end of a basic block. </p>
<p>The given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is inserted as the <em>last</em> op in the basic block except:</p><ul>
<li>MULTIEQUALS in a basic block all occur first</li>
<li>INDIRECTs occur immediately before their op</li>
<li>a branch op must be the very last op in a basic block</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to insert </td></tr>
    <tr><td class="paramname">bl</td><td>is the basic block to insert into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab34e641f5ee6f2ebf4aa708e21f2b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34e641f5ee6f2ebf4aa708e21f2b24c">&#9670;&nbsp;</a></span>opInsertInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opInsertInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into the operand list for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is set into the given operand slot. Any existing input Varnodes with slot indices equal to or greater than the specified slot are pushed into the next slot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to insert </td></tr>
    <tr><td class="paramname">slot</td><td>is the input index to insert at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdbfab2362e4d4945c3feb7d3f2c42f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbfab2362e4d4945c3feb7d3f2c42f2">&#9670;&nbsp;</a></span>opMarkHalt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opMarkHalt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark given CPUI_RETURN op as a <em>special</em> halt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given CPUI_RETURN op </td></tr>
    <tr><td class="paramname">flag</td><td>is one of <em>halt</em>, <em>badinstruction</em>, <em>unimplemented</em>, <em>noreturn</em>, or <em>missing</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84937c2241ea5679280223cc0ec8b202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84937c2241ea5679280223cc0ec8b202">&#9670;&nbsp;</a></span>opRemoveInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opRemoveInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a specific input slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the specified slot is unlinked from the op and the slot itself is removed. The slot index for any remaining input Varnodes coming after the specified slot is decreased by one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the index of the specified slot to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aee1f3697913d19bc3fb40dadf75912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aee1f3697913d19bc3fb40dadf75912">&#9670;&nbsp;</a></span>opSetAllInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetAllInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classVarnode.html">Varnode</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all input Varnodes for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> simultaneously. </p>
<p>All previously existing input Varnodes are unset. The input slots for the op are resized and then filled in from the specified array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> to set </td></tr>
    <tr><td class="paramname">vvec</td><td>is the specified array of new input Varnodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa079e2bd26e92671be79601535236a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa079e2bd26e92671be79601535236a63">&#9670;&nbsp;</a></span>opSetInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific input operand for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the operand <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to set </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is placed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9dbf52668db4a1923537e2128719181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dbf52668db4a1923537e2128719181">&#9670;&nbsp;</a></span>opSetOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetOpcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the op-code for a specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">opc</td><td>is the op-code to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2bd3523c574c5b303728ef4d880ec3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bd3523c574c5b303728ef4d880ec3a">&#9670;&nbsp;</a></span>opSetOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSetOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a specific output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the specific <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">vn</td><td>is the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37b36505bab6f7c5676157288e65d5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b36505bab6f7c5676157288e65d5c6">&#9670;&nbsp;</a></span>opStackLoad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::opStackLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>stackref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LOAD expression at an offset relative to a <em>spacebase</em> register for a given address space. </p>
<p>The <em>spacebase</em> register is looked up for the given address space, or an optional previously existing register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> can be provided. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">off</td><td>is the offset to calculate relative to the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">sz</td><td>is the size of the desire LOAD in bytes </td></tr>
    <tr><td class="paramname">op</td><td>is the insertion point <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">stackref</td><td>is the <em>spacebase</em> register <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (if available) </td></tr>
    <tr><td class="paramname">insertafter</td><td>is <b>true</b> if new ops are inserted <em>after</em> the insertion point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>unique</em> space <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> holding the result of the LOAD </dd></dl>

</div>
</div>
<a id="a4582ad34b4e7c851d92db8544999eaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4582ad34b4e7c851d92db8544999eaf3">&#9670;&nbsp;</a></span>opStackStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPcodeOp.html">PcodeOp</a> * Funcdata::opStackStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a STORE expression at an offset relative to a <em>spacebase</em> register for a given address space. </p>
<p>The <em>spacebase</em> register is looked up for the given address space. An insertion point op must be provided, and newly generated ops can come either before or after this insertion point. The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> value being stored must still be set on the returned <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given address space </td></tr>
    <tr><td class="paramname">off</td><td>is the offset to calculate relative to the <em>spacebase</em> register </td></tr>
    <tr><td class="paramname">op</td><td>is the insertion point <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">insertafter</td><td>is <b>true</b> if new ops are inserted <em>after</em> the insertion point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the STORE <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </dd></dl>

</div>
</div>
<a id="a1ae30fdfbe33ecfa6668b5579ae3e82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae30fdfbe33ecfa6668b5579ae3e82a">&#9670;&nbsp;</a></span>opSwapInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opSwapInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two input operands in the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>This is convenience method that is more efficient than call <a class="el" href="classFuncdata.html#aa079e2bd26e92671be79601535236a63" title="Set a specific input operand for the given PcodeOp. ">opSetInput()</a> twice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot1</td><td>is the first input slot being switched </td></tr>
    <tr><td class="paramname">slot2</td><td>is the second input slot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad74d3baa2516f448e7ab5f9a8151b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74d3baa2516f448e7ab5f9a8151b572">&#9670;&nbsp;</a></span>opUndoPtradd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUndoPtradd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a CPUI_PTRADD back into a CPUI_INT_ADD. </p>
<p>Convert the given CPUI_PTRADD into the equivalent CPUI_INT_ADD. This may involve inserting a CPUI_INT_MULT <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. If finalization is requested and a new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is needed, the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is marked as <em>implicit</em> and has its data-type set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given PTRADD </td></tr>
    <tr><td class="paramname">finalize</td><td>is <b>true</b> if finalization is needed for any new <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf0cf87976170d62df42411ffe1e10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf0cf87976170d62df42411ffe1e10a">&#9670;&nbsp;</a></span>opUninsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUninsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> from its basic block. </p>
<p>The op is taken out of its basic block and put into the dead list. If the removal is permanent the input and output Varnodes should be unset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a495ebac694bc98d041e29ce05eece6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ebac694bc98d041e29ce05eece6f9">&#9670;&nbsp;</a></span>opUnlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUnlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset inputs/output and remove given PcodeOP from its basic block. </p>
<p>The op is extricated from all its <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> connections to the functions data-flow and removed from its basic block. This will <em>not</em> change block connections. The <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> objects remains in the <em>dead</em> list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16f821f09d862b3c908d2bce7530b90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f821f09d862b3c908d2bce7530b90a">&#9670;&nbsp;</a></span>opUnsetInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUnsetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear an input operand slot for the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is unlinked from the op. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab91b54da6501e12d4ad1e81ab5d0e5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91b54da6501e12d4ad1e81ab5d0e5c4">&#9670;&nbsp;</a></span>opUnsetOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::opUnsetOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> from the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>The output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> becomes <em>free</em> but is not immediately deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafb83719ca201b5d57283058e2bcadee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb83719ca201b5d57283058e2bcadee">&#9670;&nbsp;</a></span>overrideFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::overrideFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> the control-flow p-code for a particular instruction. </p>
<p>P-code in <b>this</b> function is modified to change the control-flow of the instruction at the given address, based on the <a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given address of the instruction to modify </td></tr>
    <tr><td class="paramname">type</td><td>is the <a class="el" href="classOverride.html" title="A container of commands that override the decompiler&#39;s default behavior for a single function...">Override</a> type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c86861b22f4beb1cac5ab3ab43db6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c86861b22f4beb1cac5ab3ab43db6ae">&#9670;&nbsp;</a></span>printBlockTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printBlockTree </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a description of control-flow structuring to a stream. </p>
<p>A description of each block in the current structure hierarchy is printed to stream. This is suitable for a console mode or debug view of the state of control-flow structuring at any point during analysis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b52d8ec8b53529b02881977971067ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b52d8ec8b53529b02881977971067ce">&#9670;&nbsp;</a></span>printLocalRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printLocalRange </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print description of memory ranges associated with local scopes. </p>
<p>Each scope has a set of memory ranges associated with it, encompassing storage locations of variables that are <em>assumed</em> to be in the scope. Each range for each local scope is printed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a3cdbf385c382c10fc5b48f5842b418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3cdbf385c382c10fc5b48f5842b418">&#9670;&nbsp;</a></span>printRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printRaw </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print raw p-code op descriptions to a stream. </p>
<p>A representation of all PcodeOps in the function body are printed to the stream. Depending on the state of analysis, PcodeOps are grouped into their basic blocks, and within a block, ops are displayed sequentially. Basic labeling of branch destinations is also printed. This is suitable for a console mode or debug view of the state of the function at any given point in its analysis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac150948163b641a4d138ef82bf213f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac150948163b641a4d138ef82bf213f4e">&#9670;&nbsp;</a></span>printVarnodeTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::printVarnodeTree </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a description of all Varnodes to a stream. </p>
<p>A description of each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> currently involved in the data-flow of <b>this</b> function is printed to the output stream. This is suitable as part of a console mode or debug view of the function at any point during its analysis </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2d635570305e3ea710ade3cf090ba8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d635570305e3ea710ade3cf090ba8c">&#9670;&nbsp;</a></span>pushBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::pushBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bbnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a control-flow edge from one block to another. </p>
<p>This is intended for eliminating switch guard artifacts. The edge must be for a conditional jump and must be moved to a block hosting multiple out edges for a BRANCHIND. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the basic block out of which the edge to move flows </td></tr>
    <tr><td class="paramname">slot</td><td>is the index of the (out) edge </td></tr>
    <tr><td class="paramname">bbnew</td><td>is the basic block where the edge should get moved to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38d58c33cdc77c663fceb7de1f6aadeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d58c33cdc77c663fceb7de1f6aadeb">&#9670;&nbsp;</a></span>recoverJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJumpTable.html">JumpTable</a> * Funcdata::recoverJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowInfo.html">FlowInfo</a> *&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>failuremode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover destinations for a BRANCHIND by analyzing nearby data and control-flow. </p>
<p>This is the high-level entry point for jump-table/switch recovery. In short, a copy of the current state of data-flow is made, simplification transformations are applied to the copy, and the resulting data-flow tree is examined to enumerate possible values of the input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. This information is stored in a <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the given BRANCHIND <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
    <tr><td class="paramname">flow</td><td>is current flow information for <b>this</b> function </td></tr>
    <tr><td class="paramname">failuremode</td><td>will hold the final success/failure code (0=success) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the recovered <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> or NULL if there was no success </dd></dl>

</div>
</div>
<a id="a73cbb6375e48cddaedf5e55e40119c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cbb6375e48cddaedf5e55e40119c84">&#9670;&nbsp;</a></span>remapDynamicVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::remapDynamicVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a new dynamic mapping. </p>
<p>Any previous links between the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, and the associate <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> are removed. Then a new dynamic link is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> maps to </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the code <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> where the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is defined </td></tr>
    <tr><td class="paramname">hash</td><td>is the hash for the new dynamic mapping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6145d643e13a072975e34255a06f4e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6145d643e13a072975e34255a06f4e84">&#9670;&nbsp;</a></span>remapVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::remapVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbol.html">Symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>usepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to a given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> using a static mapping. </p>
<p>Any previous links between the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>, the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, and the associate <a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a> are removed. Then a new link is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">sym</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> maps to </td></tr>
    <tr><td class="paramname">usepoint</td><td>is the desired usepoint for the mapping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a53162bf9a1756c4f2f4d7d1d7bbcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a53162bf9a1756c4f2f4d7d1d7bbcec">&#9670;&nbsp;</a></span>removeBranch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeBranch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the indicated branch from a basic block. </p>
<p>The edge is removed from control-flow and affected MULTIEQUAL ops are adjusted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the basic block </td></tr>
    <tr><td class="paramname">num</td><td>is the index of the out edge to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa486c5f0556919686a9fdad4ebc2dcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa486c5f0556919686a9fdad4ebc2dcc1">&#9670;&nbsp;</a></span>removeDoNothingBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeDoNothingBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block from control-flow that performs no operations. </p>
<p>The block must contain only <em>marker</em> operations (MULTIEQUAL) and possibly a single unconditional branch operation. The block and its PcodeOps are completely removed from the current control-flow and data-flow. This forces a reset of the control-flow structuring hierarchy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af83619924b5d0fed25d0563b0f243262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83619924b5d0fed25d0563b0f243262">&#9670;&nbsp;</a></span>removeFromFlowSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeFromFlowSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a basic block splitting its control-flow into two distinct paths. </p>
<p>This is used by <a class="el" href="classConditionalExecution.html" title="A class for simplifying a series of conditionally executed statements. ">ConditionalExecution</a> to eliminate unnecessary control-flow joins. The given block must have 2 inputs and 2 outputs, (and no operations). The block is removed, and control-flow is adjusted so that In(0) flows to Out(0) and In(1) flows to Out(1), or vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">swap</td><td>is <b>true</b> to force In(0)-&gt;Out(1) and In(1)-&gt;Out(0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e75df713649c7bba52b17b1b84bbcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e75df713649c7bba52b17b1b84bbcf6">&#9670;&nbsp;</a></span>removeJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::removeJumpTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJumpTable.html">JumpTable</a> *&#160;</td>
          <td class="paramname"><em>jt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove/delete the given jump-table. </p>
<p>The <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object is freed, and the associated BRANCHIND is no longer marked as a <em>switch</em> point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jt</td><td>is the given <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fca3088c3d01a584aef0db49dfccc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fca3088c3d01a584aef0db49dfccc63">&#9670;&nbsp;</a></span>removeUnreachableBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::removeUnreachableBlocks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>issuewarning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkexistence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove any unreachable basic blocks. </p>
<p>A quick check for unreachable blocks can optionally be made, otherwise the cached state is checked via <a class="el" href="classFuncdata.html#ae7daf83122a6a2ffff93774466baab26" title="Did this function exhibit unreachable code. ">hasUnreachableBlocks()</a>, which is turned on during analysis by calling the structureReset() method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">issuewarning</td><td>is <b>true</b> if warning comments are desired </td></tr>
    <tr><td class="paramname">checkexistence</td><td>is <b>true</b> to force an active search for unreachable blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if unreachable blocks were actually found and removed </dd></dl>

</div>
</div>
<a id="a8af7249a90794ba6001046e28c0aeb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af7249a90794ba6001046e28c0aeb5c">&#9670;&nbsp;</a></span>replaceLessequal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::replaceLessequal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncdata.html">Funcdata</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace INT_LESSEQUAL and INT_SLESSEQUAL expressions. </p>
<p>Do in-place replacement of</p><ul>
<li><code>c &lt;= x</code> with <code>c-1 &lt; x</code> OR</li>
<li><code>x &lt;= c</code> with <code>x &lt; c+1</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the function being analyzed </td></tr>
    <tr><td class="paramname">op</td><td>is comparison <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid replacement was performed </dd></dl>

</div>
</div>
<a id="a754fe8bd5805e6d9fd8041365e7747eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754fe8bd5805e6d9fd8041365e7747eb">&#9670;&nbsp;</a></span>replaceVolatile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::replaceVolatile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace accesses of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with <em>volatile</em> operations. </p>
<p>The <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is assumed not fully linked. The read or write action is modeled by inserting a special <em>user</em> op that represents the action. The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is replaced by a temporary <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> within the data-flow, and the original address becomes a parameter to the user op. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to model as volatile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if a change was made </dd></dl>

</div>
</div>
<a id="a7419de8057421b8e9300c4a26c60ecef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7419de8057421b8e9300c4a26c60ecef">&#9670;&nbsp;</a></span>restoreXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 Funcdata::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the state of <b>this</b> function from an XML description. </p>
<p>From an XML &lt;function&gt; tag, recover the name, address, prototype, symbol, jump-table, and override information for <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root &lt;function&gt; tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the symbol id associated with the function </dd></dl>

</div>
</div>
<a id="a07a41bb91dd51c9a76d8f6d1e2f09328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a41bb91dd51c9a76d8f6d1e2f09328">&#9670;&nbsp;</a></span>restoreXmlJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::restoreXmlJumpTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore jump-tables from an XML description. </p>
<p>This parses a &lt;jumptablelist&gt; tag and builds a <a class="el" href="classJumpTable.html" title="A map from values to control-flow targets within a function. ">JumpTable</a> object for each &lt;jumptable&gt; sub-tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the root &lt;jumptablelist&gt; tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e7664bd70368066f7ad70a8922795e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e7664bd70368066f7ad70a8922795e">&#9670;&nbsp;</a></span>saveXml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>savetree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an XML description of <b>this</b> function to stream. </p>
<p>An XML description of <b>this</b> function is written to the stream, including name, address, prototype, symbol, jump-table, and override information. If indicated by the caller, a description of the entire <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> and <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> tree is also emitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
    <tr><td class="paramname">id</td><td>is the unique id associated with the function symbol </td></tr>
    <tr><td class="paramname">savetree</td><td>is <b>true</b> if the p-code tree should be emitted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accde64f2642f6e86545df826e2751f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accde64f2642f6e86545df826e2751f8b">&#9670;&nbsp;</a></span>saveXmlHigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXmlHigh </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save an XML description of all HighVariables to stream. </p>
<p>This produces a single &lt;highlist&gt; tag, with a &lt;high&gt; sub-tag for each high-level variable (<a class="el" href="classHighVariable.html" title="A high-level variable modeled as a list of low-level variables, each written once. ">HighVariable</a>) currently associated with <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f2d5d66f0ae7c5c4eae20d60ad30897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2d5d66f0ae7c5c4eae20d60ad30897">&#9670;&nbsp;</a></span>saveXmlJumpTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXmlJumpTable </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an XML description of jump-tables to stream. </p>
<p>A &lt;jumptablelist&gt; tag is written with &lt;jumptable&gt; sub-tags describing each jump-table associated with the control-flow of <b>this</b> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7630153130424a56fac5a4b4a4792b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7630153130424a56fac5a4b4a4792b60">&#9670;&nbsp;</a></span>saveXmlTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::saveXmlTree </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save an XML description of the p-code tree to stream. </p>
<p>A single &lt;ast&gt; tag is produced with children describing Varnodes, PcodeOps, and basic blocks making up <b>this</b> function's current syntax tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0c8b4dab63367913749e68fbd33789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0c8b4dab63367913749e68fbd33789">&#9670;&nbsp;</a></span>seenDeadcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::seenDeadcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark that dead Varnodes have been seen in a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the address space to mark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15885a8369e2c43c8c7883a4fabd533e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15885a8369e2c43c8c7883a4fabd533e">&#9670;&nbsp;</a></span>setBasicBlockRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setBasicBlockRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the initial ownership range for the given basic block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>is the given basic block </td></tr>
    <tr><td class="paramname">beg</td><td>is the beginning <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the owned code range </td></tr>
    <tr><td class="paramname">end</td><td>is the ending <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> of the owned code range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac40aef88ca7a101e4697df5e0ec5f605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40aef88ca7a101e4697df5e0ec5f605">&#9670;&nbsp;</a></span>setDeadCodeDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setDeadCodeDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a delay before removing dead code for a specific address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the specific address space </td></tr>
    <tr><td class="paramname">delay</td><td>is the number of passes to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23bcddc7a3b959812f9a1660b39cc6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bcddc7a3b959812f9a1660b39cc6ef">&#9670;&nbsp;</a></span>setDoublePrecisRecovery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setDoublePrecisRecovery </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether double precision analysis is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if double precision analysis is enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84a9880613a03f3aea65acf3dd1343d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a9880613a03f3aea65acf3dd1343d6">&#9670;&nbsp;</a></span>setInputVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVarnode.html">Varnode</a> * Funcdata::setInputVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> as an input to the function. </p>
<p>An <em>input</em> <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> has a special designation within SSA form as not being defined by a p-code operation and is a formal input to the data-flow of the function. It is not necessarily a formal function parameter.</p>
<p>The given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to be marked is also returned unless there is an input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that already exists which overlaps the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. If the Varnodes have the same size and storage address, the preexisting input <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is returned instead. Otherwise an exception is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to mark as an input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the marked <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </dd></dl>

</div>
</div>
<a id="ac33bb4d59a0125d36710fe80453b9526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33bb4d59a0125d36710fe80453b9526">&#9670;&nbsp;</a></span>setJumptableRecovery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setJumptableRecovery </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether <b>this</b> is being used for jump-table recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> to indicate a jump-table is being recovered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af21c852eb9f606c5cd19fb2456927ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21c852eb9f606c5cd19fb2456927ecd">&#9670;&nbsp;</a></span>setRestartPending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::setRestartPending </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle whether analysis needs to be restarted for <b>this</b> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is <b>true</b> if a reset is required </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96433773ee0126ce9a25b0970a6ef513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96433773ee0126ce9a25b0970a6ef513">&#9670;&nbsp;</a></span>spacebase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::spacebase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark registers that map to a virtual address space. </p>
<p>This routine searches for an marks <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> objects, like stack-pointer registers, that are used as a base address for a virtual address space. Each <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> gets a special data-type and is marked so that <a class="el" href="classVarnode.html#acd05a4490f361d118129cc0490072420" title="Is this location used to store the base point for a virtual address space? ">Varnode::isSpacebase()</a> returns <b>true</b>. </p>

</div>
</div>
<a id="aaf4a89f4e3da37a4107992689f7b89ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4a89f4e3da37a4107992689f7b89ff">&#9670;&nbsp;</a></span>spacebaseConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::spacebaseConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSymbolEntry.html">SymbolEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>rampoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>origval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>origsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a constant pointer into a <em>ram</em> CPUI_PTRSUB. </p>
<p>A constant known to be a pointer into an address space like <b>ram</b> is converted into a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> defined by CPUI_PTRSUB, which triggers a <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> lookup at points during analysis. The constant must point to a known <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a>.</p>
<p>The PTRSUB takes the constant 0 as its first input, which is marked as a <em>spacebase</em> to indicate this situation. The second input to PTRSUB becomes the offset to the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> within the address space. An additional INT_SUB may be inserted to get from the start of the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> to the address indicated by the original constant pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>is the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> referencing the constant pointer </td></tr>
    <tr><td class="paramname">slot</td><td>is the input slot of the constant pointer </td></tr>
    <tr><td class="paramname">entry</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> being pointed (in)to </td></tr>
    <tr><td class="paramname">rampoint</td><td>is the constant pointer interpreted as an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">origval</td><td>is the constant </td></tr>
    <tr><td class="paramname">origsize</td><td>is the size of the constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f0c9d7c7fb4217731ae45f7848e4034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c9d7c7fb4217731ae45f7848e4034">&#9670;&nbsp;</a></span>spliceBlockBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::spliceBlockBasic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>bl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMerge.html" title="Class for merging low-level Varnodes into high-level HighVariables. ">Merge</a> the given basic block with the block it flows into. </p>
<p>The given block must have a single output block, which will be removed. The given block has the p-code from the output block concatenated to its own, and it inherits the output block's out edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>is the given basic block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0637a2c7f6a1e511284cfeecb4b0d475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0637a2c7f6a1e511284cfeecb4b0d475">&#9670;&nbsp;</a></span>startProcessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::startProcessing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start processing for this function. </p>
<p>This routine does basic set-up for analyzing the function. In particular, it generates the raw p-code, builds basic blocks, and generates the call specification objects. </p>

</div>
</div>
<a id="a5ba1555023c49006ed39936b9a40aba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba1555023c49006ed39936b9a40aba4">&#9670;&nbsp;</a></span>switchEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::switchEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFlowBlock.html">FlowBlock</a> *&#160;</td>
          <td class="paramname"><em>inblock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockBasic.html">BlockBasic</a> *&#160;</td>
          <td class="paramname"><em>outbefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlowBlock.html">FlowBlock</a> *&#160;</td>
          <td class="paramname"><em>outafter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch an outgoing edge from the given <em>source</em> block to flow into another block. </p>
<p>This does <em>not</em> adjust MULTIEQUAL data-flow. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inblock</td><td>is the given <em>source</em> block </td></tr>
    <tr><td class="paramname">outbefore</td><td>is the other side of the desired edge </td></tr>
    <tr><td class="paramname">outafter</td><td>is the new destination block desired </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca583e76acc0a61bc30bd32461d25aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca583e76acc0a61bc30bd32461d25aee">&#9670;&nbsp;</a></span>syncVarnodesWithSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Funcdata::syncVarnodesWithSymbols </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classScopeLocal.html">ScopeLocal</a> *&#160;</td>
          <td class="paramname"><em>lm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>typesyes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> properties based on (new) <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> information. </p>
<p>Boolean properties <b>addrtied</b>, <b>addrforce</b>, <b>auto_live</b>, and <b>nolocalalias</b> for Varnodes are updated based on new <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> information they map to. The caller can elect to update data-type information as well, where Varnodes and their associated HighVariables have their data-type finalized based symbols. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lm</td><td>is the <a class="el" href="classSymbol.html" title="The base class for a symbol in a symbol table or scope. ">Symbol</a> scope within which to search for mapped Varnodes </td></tr>
    <tr><td class="paramname">typesyes</td><td>is <b>true</b> if the caller wants to update data-types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if any <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> was updated </dd></dl>

</div>
</div>
<a id="aab7f940f85609d395283520eca3a71f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7f940f85609d395283520eca3a71f0">&#9670;&nbsp;</a></span>totalReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::totalReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>newvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all read references to the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the first <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (being replaced) </td></tr>
    <tr><td class="paramname">newvn</td><td>is the second <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> (the replacement) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2934e1e4246d41a5e28f6fcb56acc937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2934e1e4246d41a5e28f6fcb56acc937">&#9670;&nbsp;</a></span>totalReplaceConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::totalReplaceConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every read reference of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> with a constant value. </p>
<p>A new constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is created for each read site. If there are any marker ops (MULTIEQUAL) a single COPY op is inserted and the marker input is set to be the output of the COPY. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">val</td><td>is the constant value to replace it with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070edf06c2d300a7d6d1bda21189b477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070edf06c2d300a7d6d1bda21189b477">&#9670;&nbsp;</a></span>transferVarnodeProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::transferVarnodeProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>newVn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>lsbOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy properties from an existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to a new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>The new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> is assumed to overlap the storage of the existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. Properties like boolean flags and <em>consume</em> bits are copied as appropriate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the existing <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">newVn</td><td>is the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> that has its properties set </td></tr>
    <tr><td class="paramname">lsbOffset</td><td>is the significance offset of the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> within the exising </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a122718ad87c13b714676c61050461388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122718ad87c13b714676c61050461388">&#9670;&nbsp;</a></span>truncatedFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::truncatedFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFlowInfo.html">FlowInfo</a> *&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a clone with truncated control-flow given a partial function. </p>
<p>Existing p-code is cloned from another function whose flow has not been completely followed. Artificial halt operators are inserted wherever flow is incomplete and basic blocks are generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the partial function to clone </td></tr>
    <tr><td class="paramname">flow</td><td>is partial function's flow information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4bea7abaa0ea3ade9d04cb78a521aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bea7abaa0ea3ade9d04cb78a521aac">&#9670;&nbsp;</a></span>updateOpFromSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::updateOpFromSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFuncCallSpecs.html">FuncCallSpecs</a> *&#160;</td>
          <td class="paramname"><em>fc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update CALL <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> properties based on its corresponding call specification. </p>
<p>As call specifications for a particular call site are updated, this routine pushes back properties to the particular CALL op that are relevant for analysis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fc</td><td>is the call specification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19698f34a432f84d8cbe94f8e0ad20d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19698f34a432f84d8cbe94f8e0ad20d4">&#9670;&nbsp;</a></span>warning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::warning </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>txt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>ad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a warning comment in the function body. </p>
<p>The comment is added to the global database, indexed via its placement address and the entry address of the function. The emitter will attempt to place the comment before the source expression that maps most closely to the address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txt</td><td>is the string body of the comment </td></tr>
    <tr><td class="paramname">ad</td><td>is the placement address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87967b12187406a7fdf311cc4b836118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87967b12187406a7fdf311cc4b836118">&#9670;&nbsp;</a></span>warningHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Funcdata::warningHeader </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>txt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a warning comment as part of the function header. </p>
<p>The warning will be emitted as part of the block comment printed right before the prototype. The comment is stored in the global comment database, indexed via the function's entry address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txt</td><td>is the string body of the comment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="funcdata_8hh_source.html">funcdata.hh</a></li>
<li>funcdata.cc</li>
<li>funcdata_block.cc</li>
<li>funcdata_op.cc</li>
<li>funcdata_varnode.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
