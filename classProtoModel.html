<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ProtoModel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classProtoModel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProtoModel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <b>prototype</b> <b>model:</b> a model for passing parameters between functions.  
 <a href="classProtoModel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fspec_8hh_source.html">fspec.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ProtoModel:</div>
<div class="dyncontent">
<div class="center"><img src="classProtoModel__inherit__graph.png" border="0" usemap="#ProtoModel_inherit__map" alt="Inheritance graph"/></div>
<map name="ProtoModel_inherit__map" id="ProtoModel_inherit__map">
<area shape="rect" id="node2" href="classProtoModelMerged.html" title="A prototype model made by merging together other models. " alt="" coords="5,80,136,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab532221dd4a9946b2dea90be44c79879"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classProtoModel.html#ab532221dd4a9946b2dea90be44c79879ab0874d825448e7c731717fad59bbec92">extrapop_unknown</a> = 0x8000
 }</td></tr>
<tr class="separator:ab532221dd4a9946b2dea90be44c79879"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ef7db884a8c5bcdea92ed7b2d6a9ac0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a4ef7db884a8c5bcdea92ed7b2d6a9ac0">ProtoModel</a> (<a class="el" href="classArchitecture.html">Architecture</a> *g)</td></tr>
<tr class="memdesc:a4ef7db884a8c5bcdea92ed7b2d6a9ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConstructor.html">Constructor</a> for use with <a class="el" href="classProtoModel.html#a8fe30abbc7fe1c709b1b8fe9c81803b8" title="Restore this model from an XML stream. ">restoreXml()</a>  <a href="#a4ef7db884a8c5bcdea92ed7b2d6a9ac0">More...</a><br /></td></tr>
<tr class="separator:a4ef7db884a8c5bcdea92ed7b2d6a9ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6385c58ce2f155d13f506c64a7a03b11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a6385c58ce2f155d13f506c64a7a03b11">ProtoModel</a> (const string &amp;nm, const <a class="el" href="classProtoModel.html">ProtoModel</a> &amp;op2)</td></tr>
<tr class="memdesc:a6385c58ce2f155d13f506c64a7a03b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor changing the name.  <a href="#a6385c58ce2f155d13f506c64a7a03b11">More...</a><br /></td></tr>
<tr class="separator:a6385c58ce2f155d13f506c64a7a03b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae253f61258ac2ad8f165200d1737e7a3"><td class="memItemLeft" align="right" valign="top"><a id="ae253f61258ac2ad8f165200d1737e7a3"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#ae253f61258ac2ad8f165200d1737e7a3">~ProtoModel</a> (void)</td></tr>
<tr class="memdesc:ae253f61258ac2ad8f165200d1737e7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae253f61258ac2ad8f165200d1737e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f8d9a9dbc7fb8d52aa180410cddc8b"><td class="memItemLeft" align="right" valign="top"><a id="a19f8d9a9dbc7fb8d52aa180410cddc8b"></a>
const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a19f8d9a9dbc7fb8d52aa180410cddc8b">getName</a> (void) const</td></tr>
<tr class="memdesc:a19f8d9a9dbc7fb8d52aa180410cddc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the prototype model. <br /></td></tr>
<tr class="separator:a19f8d9a9dbc7fb8d52aa180410cddc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256b9f054603fd6d166fdf86689467bf"><td class="memItemLeft" align="right" valign="top"><a id="a256b9f054603fd6d166fdf86689467bf"></a>
<a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a256b9f054603fd6d166fdf86689467bf">getArch</a> (void) const</td></tr>
<tr class="memdesc:a256b9f054603fd6d166fdf86689467bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the owning <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a>. <br /></td></tr>
<tr class="separator:a256b9f054603fd6d166fdf86689467bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd9f07bc75fc5f2497f1d4de685a8cf"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a5bd9f07bc75fc5f2497f1d4de685a8cf">hasEffect</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size) const</td></tr>
<tr class="memdesc:a5bd9f07bc75fc5f2497f1d4de685a8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine side-effect of <b>this</b> on the given memory range.  <a href="#a5bd9f07bc75fc5f2497f1d4de685a8cf">More...</a><br /></td></tr>
<tr class="separator:a5bd9f07bc75fc5f2497f1d4de685a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640ae87320b6d6781639643057e61e1d"><td class="memItemLeft" align="right" valign="top"><a id="a640ae87320b6d6781639643057e61e1d"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a640ae87320b6d6781639643057e61e1d">getExtraPop</a> (void) const</td></tr>
<tr class="memdesc:a640ae87320b6d6781639643057e61e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack-pointer <em>extrapop</em> for <b>this</b> model. <br /></td></tr>
<tr class="separator:a640ae87320b6d6781639643057e61e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eb0adf6bb66f15bbbde19c02c931ca"><td class="memItemLeft" align="right" valign="top"><a id="a42eb0adf6bb66f15bbbde19c02c931ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a42eb0adf6bb66f15bbbde19c02c931ca">setExtraPop</a> (int4 ep)</td></tr>
<tr class="memdesc:a42eb0adf6bb66f15bbbde19c02c931ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stack-pointer <em>extrapop</em>. <br /></td></tr>
<tr class="separator:a42eb0adf6bb66f15bbbde19c02c931ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af505f8d493ab0dcefca9e94941c13658"><td class="memItemLeft" align="right" valign="top"><a id="af505f8d493ab0dcefca9e94941c13658"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#af505f8d493ab0dcefca9e94941c13658">getInjectUponEntry</a> (void) const</td></tr>
<tr class="memdesc:af505f8d493ab0dcefca9e94941c13658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inject <em>uponentry</em> id. <br /></td></tr>
<tr class="separator:af505f8d493ab0dcefca9e94941c13658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8994c68acebcf5c0278d86be39a530"><td class="memItemLeft" align="right" valign="top"><a id="a2e8994c68acebcf5c0278d86be39a530"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a2e8994c68acebcf5c0278d86be39a530">getInjectUponReturn</a> (void) const</td></tr>
<tr class="memdesc:a2e8994c68acebcf5c0278d86be39a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inject <em>uponreturn</em> id. <br /></td></tr>
<tr class="separator:a2e8994c68acebcf5c0278d86be39a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6da17343cb12b0e798fe7211441c58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a7f6da17343cb12b0e798fe7211441c58">deriveInputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const</td></tr>
<tr class="memdesc:a7f6da17343cb12b0e798fe7211441c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of input <em>trials</em>, derive the most likely input prototype.  <a href="#a7f6da17343cb12b0e798fe7211441c58">More...</a><br /></td></tr>
<tr class="separator:a7f6da17343cb12b0e798fe7211441c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463595607985ec774f3df35dfbd7ca94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a463595607985ec774f3df35dfbd7ca94">deriveOutputMap</a> (<a class="el" href="classParamActive.html">ParamActive</a> *active) const</td></tr>
<tr class="memdesc:a463595607985ec774f3df35dfbd7ca94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of output <em>trials</em>, derive the most likely output prototype.  <a href="#a463595607985ec774f3df35dfbd7ca94">More...</a><br /></td></tr>
<tr class="separator:a463595607985ec774f3df35dfbd7ca94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c2a4e9e1a7a13ef948c8a9c55dd831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a13c2a4e9e1a7a13ef948c8a9c55dd831">assignParameterStorage</a> (const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> *&gt; &amp;typelist, vector&lt; <a class="el" href="structParameterPieces.html">ParameterPieces</a> &gt; &amp;res, bool ignoreOutputError)</td></tr>
<tr class="memdesc:a13c2a4e9e1a7a13ef948c8a9c55dd831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate input and output storage locations given a function prototype.  <a href="#a13c2a4e9e1a7a13ef948c8a9c55dd831">More...</a><br /></td></tr>
<tr class="separator:a13c2a4e9e1a7a13ef948c8a9c55dd831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06031cb84a876e36a3648362c4af8662"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a06031cb84a876e36a3648362c4af8662">checkInputJoin</a> (const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisize, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losize) const</td></tr>
<tr class="memdesc:a06031cb84a876e36a3648362c4af8662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given two input storage locations can represent a single logical parameter.  <a href="#a06031cb84a876e36a3648362c4af8662">More...</a><br /></td></tr>
<tr class="separator:a06031cb84a876e36a3648362c4af8662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0ae91c9fa12f548418c469f63c9d1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a0e0ae91c9fa12f548418c469f63c9d1d">checkOutputJoin</a> (const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisize, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losize) const</td></tr>
<tr class="memdesc:a0e0ae91c9fa12f548418c469f63c9d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given two output storage locations can represent a single logical return value.  <a href="#a0e0ae91c9fa12f548418c469f63c9d1d">More...</a><br /></td></tr>
<tr class="separator:a0e0ae91c9fa12f548418c469f63c9d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc6e7d218491b657d1f5e5bb997592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a6ddc6e7d218491b657d1f5e5bb997592">checkInputSplit</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 splitpoint) const</td></tr>
<tr class="memdesc:a6ddc6e7d218491b657d1f5e5bb997592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if it makes sense to split a single storage location into two input parameters.  <a href="#a6ddc6e7d218491b657d1f5e5bb997592">More...</a><br /></td></tr>
<tr class="separator:a6ddc6e7d218491b657d1f5e5bb997592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4736d007016235f93ae81100f8312e26"><td class="memItemLeft" align="right" valign="top"><a id="a4736d007016235f93ae81100f8312e26"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a4736d007016235f93ae81100f8312e26">getLocalRange</a> (void) const</td></tr>
<tr class="memdesc:a4736d007016235f93ae81100f8312e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of (possible) local stack variables. <br /></td></tr>
<tr class="separator:a4736d007016235f93ae81100f8312e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a83c006b588fad0b0842c6f9862e66b"><td class="memItemLeft" align="right" valign="top"><a id="a2a83c006b588fad0b0842c6f9862e66b"></a>
const <a class="el" href="classRangeList.html">RangeList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a2a83c006b588fad0b0842c6f9862e66b">getParamRange</a> (void) const</td></tr>
<tr class="memdesc:a2a83c006b588fad0b0842c6f9862e66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of (possible) stack parameters. <br /></td></tr>
<tr class="separator:a2a83c006b588fad0b0842c6f9862e66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9fa95940e32b03d475257ca177cfaa"><td class="memItemLeft" align="right" valign="top"><a id="a5c9fa95940e32b03d475257ca177cfaa"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a5c9fa95940e32b03d475257ca177cfaa">effectBegin</a> (void) const</td></tr>
<tr class="memdesc:a5c9fa95940e32b03d475257ca177cfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a>. <br /></td></tr>
<tr class="separator:a5c9fa95940e32b03d475257ca177cfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eccb4ede5b877d6256cbbc2b9f4666"><td class="memItemLeft" align="right" valign="top"><a id="ac5eccb4ede5b877d6256cbbc2b9f4666"></a>
vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#ac5eccb4ede5b877d6256cbbc2b9f4666">effectEnd</a> (void) const</td></tr>
<tr class="memdesc:ac5eccb4ede5b877d6256cbbc2b9f4666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the last <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a>. <br /></td></tr>
<tr class="separator:ac5eccb4ede5b877d6256cbbc2b9f4666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f841c8f099cc2f124b8257c51d50f"><td class="memItemLeft" align="right" valign="top"><a id="a8d1f841c8f099cc2f124b8257c51d50f"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a8d1f841c8f099cc2f124b8257c51d50f">numLikelyTrash</a> (void) const</td></tr>
<tr class="memdesc:a8d1f841c8f099cc2f124b8257c51d50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <em>likelytrash</em> locations. <br /></td></tr>
<tr class="separator:a8d1f841c8f099cc2f124b8257c51d50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6449c1c7d16d6ec396d29e58042cad"><td class="memItemLeft" align="right" valign="top"><a id="a1e6449c1c7d16d6ec396d29e58042cad"></a>
const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a1e6449c1c7d16d6ec396d29e58042cad">getLikelyTrash</a> (int4 i) const</td></tr>
<tr class="memdesc:a1e6449c1c7d16d6ec396d29e58042cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th <em>likelytrashh</em> location. <br /></td></tr>
<tr class="separator:a1e6449c1c7d16d6ec396d29e58042cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac691b583d93e89de88e6185e251768d0"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#ac691b583d93e89de88e6185e251768d0">characterizeAsInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size) const</td></tr>
<tr class="memdesc:ac691b583d93e89de88e6185e251768d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Characterize whether the given range overlaps parameter storage.  <a href="#ac691b583d93e89de88e6185e251768d0">More...</a><br /></td></tr>
<tr class="separator:ac691b583d93e89de88e6185e251768d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0e6fe360413702b20cd04367dc477f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a1c0e6fe360413702b20cd04367dc477f">possibleInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size) const</td></tr>
<tr class="memdesc:a1c0e6fe360413702b20cd04367dc477f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given storage location make sense as an input parameter.  <a href="#a1c0e6fe360413702b20cd04367dc477f">More...</a><br /></td></tr>
<tr class="separator:a1c0e6fe360413702b20cd04367dc477f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2696911b81cc71cc68d927d7c02204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#aea2696911b81cc71cc68d927d7c02204">possibleOutputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size) const</td></tr>
<tr class="memdesc:aea2696911b81cc71cc68d927d7c02204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given storage location make sense as a return value.  <a href="#aea2696911b81cc71cc68d927d7c02204">More...</a><br /></td></tr>
<tr class="separator:aea2696911b81cc71cc68d927d7c02204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6577cdf023ed6a660ba804e43e356b4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a6577cdf023ed6a660ba804e43e356b4e">possibleInputParamWithSlot</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 &amp;slot, int4 &amp;slotsize) const</td></tr>
<tr class="memdesc:a6577cdf023ed6a660ba804e43e356b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the slot and slot size for the given storage location as an input parameter.  <a href="#a6577cdf023ed6a660ba804e43e356b4e">More...</a><br /></td></tr>
<tr class="separator:a6577cdf023ed6a660ba804e43e356b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3283c9f718ce1e521186810f48ce6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#afd3283c9f718ce1e521186810f48ce6f">possibleOutputParamWithSlot</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, int4 &amp;slot, int4 &amp;slotsize) const</td></tr>
<tr class="memdesc:afd3283c9f718ce1e521186810f48ce6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the slot and slot size for the given storage location as a return value.  <a href="#afd3283c9f718ce1e521186810f48ce6f">More...</a><br /></td></tr>
<tr class="separator:afd3283c9f718ce1e521186810f48ce6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0c20931a1fe2c0d3cf4fb3f8fe7c02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a8c0c20931a1fe2c0d3cf4fb3f8fe7c02">unjustifiedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:a8c0c20931a1fe2c0d3cf4fb3f8fe7c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given storage location looks like an <em>unjustified</em> input parameter.  <a href="#a8c0c20931a1fe2c0d3cf4fb3f8fe7c02">More...</a><br /></td></tr>
<tr class="separator:a8c0c20931a1fe2c0d3cf4fb3f8fe7c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcf1b51c0ce470e353e798b9eaa8603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a4fcf1b51c0ce470e353e798b9eaa8603">assumedInputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:a4fcf1b51c0ce470e353e798b9eaa8603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing input parameter for the given storage.  <a href="#a4fcf1b51c0ce470e353e798b9eaa8603">More...</a><br /></td></tr>
<tr class="separator:a4fcf1b51c0ce470e353e798b9eaa8603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ad1cd29d07b30a4525049a6b2ee270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a74ad1cd29d07b30a4525049a6b2ee270">assumedOutputExtension</a> (const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:a74ad1cd29d07b30a4525049a6b2ee270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of extension and containing return value location for the given storage.  <a href="#a74ad1cd29d07b30a4525049a6b2ee270">More...</a><br /></td></tr>
<tr class="separator:a74ad1cd29d07b30a4525049a6b2ee270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b4e24eaff01c41d6316407a2dde2e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a66b4e24eaff01c41d6316407a2dde2e1">getBiggestContainedInputParam</a> (const <a class="el" href="classAddress.html">Address</a> &amp;loc, int4 size, <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;res) const</td></tr>
<tr class="memdesc:a66b4e24eaff01c41d6316407a2dde2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass-back the biggest input parameter contained within the given range.  <a href="#a66b4e24eaff01c41d6316407a2dde2e1">More...</a><br /></td></tr>
<tr class="separator:a66b4e24eaff01c41d6316407a2dde2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9918d9e7595d9f33f53bd9ffd3118f19"><td class="memItemLeft" align="right" valign="top"><a id="a9918d9e7595d9f33f53bd9ffd3118f19"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a9918d9e7595d9f33f53bd9ffd3118f19">getSpacebase</a> (void) const</td></tr>
<tr class="memdesc:a9918d9e7595d9f33f53bd9ffd3118f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack space associated with <b>this</b> model. <br /></td></tr>
<tr class="separator:a9918d9e7595d9f33f53bd9ffd3118f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd453910b4e750e3c67f26969c17001"><td class="memItemLeft" align="right" valign="top"><a id="a9fd453910b4e750e3c67f26969c17001"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a9fd453910b4e750e3c67f26969c17001">isStackGrowsNegative</a> (void) const</td></tr>
<tr class="memdesc:a9fd453910b4e750e3c67f26969c17001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if the stack <em>grows</em> toward smaller addresses. <br /></td></tr>
<tr class="separator:a9fd453910b4e750e3c67f26969c17001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace107c2668bbd0091159f5c9e5a9042"><td class="memItemLeft" align="right" valign="top"><a id="aace107c2668bbd0091159f5c9e5a9042"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#aace107c2668bbd0091159f5c9e5a9042">hasThisPointer</a> (void) const</td></tr>
<tr class="memdesc:aace107c2668bbd0091159f5c9e5a9042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a model for (non-static) class methods. <br /></td></tr>
<tr class="separator:aace107c2668bbd0091159f5c9e5a9042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8699b4b61ebc7565dbfd7ec7ab600eca"><td class="memItemLeft" align="right" valign="top"><a id="a8699b4b61ebc7565dbfd7ec7ab600eca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a8699b4b61ebc7565dbfd7ec7ab600eca">isConstructor</a> (void) const</td></tr>
<tr class="memdesc:a8699b4b61ebc7565dbfd7ec7ab600eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> model for class constructors. <br /></td></tr>
<tr class="separator:a8699b4b61ebc7565dbfd7ec7ab600eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e71fa168f7af91d6b658516a61326"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a0a6e71fa168f7af91d6b658516a61326">getMaxInputDelay</a> (void) const</td></tr>
<tr class="memdesc:a0a6e71fa168f7af91d6b658516a61326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible input parameters.  <a href="#a0a6e71fa168f7af91d6b658516a61326">More...</a><br /></td></tr>
<tr class="separator:a0a6e71fa168f7af91d6b658516a61326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6692a33595e306f23f23d98093a006bf"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a6692a33595e306f23f23d98093a006bf">getMaxOutputDelay</a> (void) const</td></tr>
<tr class="memdesc:a6692a33595e306f23f23d98093a006bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum heritage delay across all possible return values.  <a href="#a6692a33595e306f23f23d98093a006bf">More...</a><br /></td></tr>
<tr class="separator:a6692a33595e306f23f23d98093a006bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580207b945d3734b6f1e6023b3ca2678"><td class="memItemLeft" align="right" valign="top"><a id="a580207b945d3734b6f1e6023b3ca2678"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a580207b945d3734b6f1e6023b3ca2678">isMerged</a> (void) const</td></tr>
<tr class="memdesc:a580207b945d3734b6f1e6023b3ca2678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is <b>this</b> a merged prototype model. <br /></td></tr>
<tr class="separator:a580207b945d3734b6f1e6023b3ca2678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe30abbc7fe1c709b1b8fe9c81803b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#a8fe30abbc7fe1c709b1b8fe9c81803b8">restoreXml</a> (const <a class="el" href="classElement.html">Element</a> *el)</td></tr>
<tr class="memdesc:a8fe30abbc7fe1c709b1b8fe9c81803b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <b>this</b> model from an XML stream.  <a href="#a8fe30abbc7fe1c709b1b8fe9c81803b8">More...</a><br /></td></tr>
<tr class="separator:a8fe30abbc7fe1c709b1b8fe9c81803b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aec744a55c36bed8f08fa923fad80df46"><td class="memItemLeft" align="right" valign="top">static uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProtoModel.html#aec744a55c36bed8f08fa923fad80df46">lookupEffect</a> (const vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt; &amp;efflist, const <a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:aec744a55c36bed8f08fa923fad80df46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an effect from the given <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list.  <a href="#aec744a55c36bed8f08fa923fad80df46">More...</a><br /></td></tr>
<tr class="separator:aec744a55c36bed8f08fa923fad80df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a35178d22f44e8a5ab5fcb4d7c9caf25e"><td class="memItemLeft" align="right" valign="top"><a id="a35178d22f44e8a5ab5fcb4d7c9caf25e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ProtoModelMerged</b></td></tr>
<tr class="separator:a35178d22f44e8a5ab5fcb4d7c9caf25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <b>prototype</b> <b>model:</b> a model for passing parameters between functions. </p>
<p>This encompasses both input parameters and return values. It attempts to describe the ABI, Application Binary Interface, of the processor or compiler. Any number of function prototypes (<a class="el" href="classFuncProto.html" title="A function prototype. ">FuncProto</a>) can be implemented under a <b>prototype</b> <b>model</b>, which represents a static rule set the compiler uses to decide:</p><ul>
<li>Storage locations for input parameters</li>
<li>Storage locations for return values</li>
<li>Expected side-effects of a function on other (non-parameter) registers and storage locations</li>
<li>Behavior of the stack and the stack pointer across function calls</li>
</ul>
<p>Major analysis concerns are:</p><ul>
<li>Recovering function prototypes from data-flow information: <a class="el" href="classProtoModel.html#a7f6da17343cb12b0e798fe7211441c58" title="Given a list of input trials, derive the most likely input prototype. ">deriveInputMap()</a> and <a class="el" href="classProtoModel.html#a463595607985ec774f3df35dfbd7ca94" title="Given a list of output trials, derive the most likely output prototype. ">deriveOutputMap()</a></li>
<li>Calculating parameter storage locations given a function prototype: <a class="el" href="classProtoModel.html#a13c2a4e9e1a7a13ef948c8a9c55dd831" title="Calculate input and output storage locations given a function prototype. ">assignParameterStorage()</a></li>
<li>Behavior of data-flow around call sites</li>
</ul>
<p>A prototype model supports the concept of <b>extrapop</b>, which is defined as the change in value of the stack pointer (or the number of bytes popped from the stack) across a call. This value is calculated starting from the point of the p-code CALL or CALLIND op, when the stack parameters have already been pushed by the calling function. So <em>extrapop</em> only reflects changes made by the callee. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab532221dd4a9946b2dea90be44c79879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab532221dd4a9946b2dea90be44c79879">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab532221dd4a9946b2dea90be44c79879ab0874d825448e7c731717fad59bbec92"></a>extrapop_unknown&#160;</td><td class="fielddoc"><p>Reserved extrapop value meaning the function's <em>extrapop</em> is unknown. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4ef7db884a8c5bcdea92ed7b2d6a9ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7db884a8c5bcdea92ed7b2d6a9ac0">&#9670;&nbsp;</a></span>ProtoModel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProtoModel::ProtoModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArchitecture.html">Architecture</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classConstructor.html">Constructor</a> for use with <a class="el" href="classProtoModel.html#a8fe30abbc7fe1c709b1b8fe9c81803b8" title="Restore this model from an XML stream. ">restoreXml()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>is the <a class="el" href="classArchitecture.html" title="Manager for all the major decompiler subsystems. ">Architecture</a> that will own the new prototype model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6385c58ce2f155d13f506c64a7a03b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6385c58ce2f155d13f506c64a7a03b11">&#9670;&nbsp;</a></span>ProtoModel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProtoModel::ProtoModel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classProtoModel.html">ProtoModel</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor changing the name. </p>
<p>Everything is copied from the given prototype model except the name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the new name for <b>this</b> copy </td></tr>
    <tr><td class="paramname">op2</td><td>is the prototype model to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a13c2a4e9e1a7a13ef948c8a9c55dd831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c2a4e9e1a7a13ef948c8a9c55dd831">&#9670;&nbsp;</a></span>assignParameterStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProtoModel::assignParameterStorage </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classDatatype.html">Datatype</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>typelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structParameterPieces.html">ParameterPieces</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreOutputError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate input and output storage locations given a function prototype. </p>
<p>The data-types of the function prototype are passed in as an ordered list, with the first data-type corresponding to the <em>return</em> <em>value</em> and all remaining data-types corresponding to the input parameters. Based on <b>this</b> model, a storage location is selected for each (input and output) parameter and passed back to the caller. The passed back storage locations are ordered similarly, with the output storage as the first entry. The model has the option of inserting a <em>hidden</em> return value pointer in the input storage locations.</p>
<p>A <b>void</b> return type is indicated by the formal TYPE_VOID in the (either) list. If the model can't map the specific output prototype, the caller has the option of whether an exception (<a class="el" href="structParamUnassignedError.html" title="Exception thrown when a prototype can&#39;t be modeled properly. ">ParamUnassignedError</a>) is thrown. If they choose not to throw, the unmapped return value is assumed to be <em>void</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typelist</td><td>is the list of data-types from the function prototype </td></tr>
    <tr><td class="paramname">res</td><td>will hold the storage locations for each parameter </td></tr>
    <tr><td class="paramname">ignoreOutputError</td><td>is <b>true</b> if problems assigning the output parameter are ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fcf1b51c0ce470e353e798b9eaa8603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcf1b51c0ce470e353e798b9eaa8603">&#9670;&nbsp;</a></span>assumedInputExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> ProtoModel::assumedInputExtension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of extension and containing input parameter for the given storage. </p>
<p>If the given storage is properly contained within a normal parameter and the model typically extends a small value into the full container, pass back the full container and the type of extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given storage </td></tr>
    <tr><td class="paramname">res</td><td>is the parameter storage to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extension operator (INT_ZEXT INT_SEXT) or INT_COPY if there is no extension. INT_PIECE indicates the extension is determined by the specific prototype. </dd></dl>

</div>
</div>
<a id="a74ad1cd29d07b30a4525049a6b2ee270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ad1cd29d07b30a4525049a6b2ee270">&#9670;&nbsp;</a></span>assumedOutputExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> ProtoModel::assumedOutputExtension </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of extension and containing return value location for the given storage. </p>
<p>If the given storage is properly contained within a normal return value location and the model typically extends a small value into the full container, pass back the full container and the type of extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given storage </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given storage </td></tr>
    <tr><td class="paramname">res</td><td>is the parameter storage to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extension operator (INT_ZEXT INT_SEXT) or INT_COPY if there is no extension. INT_PIECE indicates the extension is determined by the specific prototype. </dd></dl>

</div>
</div>
<a id="ac691b583d93e89de88e6185e251768d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac691b583d93e89de88e6185e251768d0">&#9670;&nbsp;</a></span>characterizeAsInputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 ProtoModel::characterizeAsInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Characterize whether the given range overlaps parameter storage. </p>
<p>Does the range naturally fit inside a potential parameter entry from this model or does it contain a parameter entry. Return one of three values indicating this characterization:</p><ul>
<li>0 means there is no intersection between the range and any <a class="el" href="classParamEntry.html" title="A contiguous range of memory that can be used to pass parameters. ">ParamEntry</a></li>
<li>1 means that at least one <a class="el" href="classParamEntry.html" title="A contiguous range of memory that can be used to pass parameters. ">ParamEntry</a> contains the range in a properly justified manner</li>
<li>2 means no <a class="el" href="classParamEntry.html" title="A contiguous range of memory that can be used to pass parameters. ">ParamEntry</a> contains the range, but the range contains at least one <a class="el" href="classParamEntry.html" title="A contiguous range of memory that can be used to pass parameters. ">ParamEntry</a> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the characterization code </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a06031cb84a876e36a3648362c4af8662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06031cb84a876e36a3648362c4af8662">&#9670;&nbsp;</a></span>checkInputJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::checkInputJoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>hiaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>hisize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>losize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given two input storage locations can represent a single logical parameter. </p>
<p>Within the conventions of this model, do the two (hi/lo) locations represent consecutive input parameter locations that can be replaced by a single logical parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hiaddr</td><td>is the address of the most significant part of the value </td></tr>
    <tr><td class="paramname">hisize</td><td>is the size of the most significant part in bytes </td></tr>
    <tr><td class="paramname">loaddr</td><td>is the address of the least significant part of the value </td></tr>
    <tr><td class="paramname">losize</td><td>is the size of the least significant part in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the two pieces can be joined </dd></dl>

</div>
</div>
<a id="a6ddc6e7d218491b657d1f5e5bb997592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddc6e7d218491b657d1f5e5bb997592">&#9670;&nbsp;</a></span>checkInputSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::checkInputSplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>splitpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if it makes sense to split a single storage location into two input parameters. </p>
<p>A storage location and split point is provided, implying two new storage locations. Does <b>this</b> model allow these locations to be considered separate parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of provided storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the location in bytes </td></tr>
    <tr><td class="paramname">splitpoint</td><td>is the number of bytes to consider in the first (in address order) piece </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the storage location can be split </dd></dl>

</div>
</div>
<a id="a0e0ae91c9fa12f548418c469f63c9d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0ae91c9fa12f548418c469f63c9d1d">&#9670;&nbsp;</a></span>checkOutputJoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::checkOutputJoin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>hiaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>hisize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>losize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given two output storage locations can represent a single logical return value. </p>
<p>Within the conventions of this model, do the two (hi/lo) locations represent consecutive locations that can be replaced by a single logical return value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hiaddr</td><td>is the address of the most significant part of the value </td></tr>
    <tr><td class="paramname">hisize</td><td>is the size of the most significant part in bytes </td></tr>
    <tr><td class="paramname">loaddr</td><td>is the address of the least significant part of the value </td></tr>
    <tr><td class="paramname">losize</td><td>is the size of the least significant part in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the two pieces can be joined </dd></dl>

</div>
</div>
<a id="a7f6da17343cb12b0e798fe7211441c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6da17343cb12b0e798fe7211441c58">&#9670;&nbsp;</a></span>deriveInputMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtoModel::deriveInputMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of input <em>trials</em>, derive the most likely input prototype. </p>
<p>Trials are sorted and marked as <em>used</em> or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>is the collection of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> input trials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a463595607985ec774f3df35dfbd7ca94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463595607985ec774f3df35dfbd7ca94">&#9670;&nbsp;</a></span>deriveOutputMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtoModel::deriveOutputMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParamActive.html">ParamActive</a> *&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of output <em>trials</em>, derive the most likely output prototype. </p>
<p>One trial (at most) is marked <em>used</em> and moved to the front of the list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>is the collection of output trials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66b4e24eaff01c41d6316407a2dde2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b4e24eaff01c41d6316407a2dde2e1">&#9670;&nbsp;</a></span>getBiggestContainedInputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::getBiggestContainedInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass-back the biggest input parameter contained within the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the given range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
    <tr><td class="paramname">res</td><td>will hold the parameter storage description being passed back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if there is at least one parameter contained in the range </dd></dl>

</div>
</div>
<a id="a0a6e71fa168f7af91d6b658516a61326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6e71fa168f7af91d6b658516a61326">&#9670;&nbsp;</a></span>getMaxInputDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 ProtoModel::getMaxInputDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum heritage delay across all possible input parameters. </p>
<p>Depending on the address space, data-flow for a parameter may not be available until extra transform passes have completed. This method returns the number of passes that must occur before we can guarantee that all parameters have data-flow info. </p><dl class="section return"><dt>Returns</dt><dd>the maximum number of passes across all input parameters in <b>this</b> model </dd></dl>

</div>
</div>
<a id="a6692a33595e306f23f23d98093a006bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6692a33595e306f23f23d98093a006bf">&#9670;&nbsp;</a></span>getMaxOutputDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 ProtoModel::getMaxOutputDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum heritage delay across all possible return values. </p>
<p>Depending on the address space, data-flow for a parameter may not be available until extra transform passes have completed. This method returns the number of passes that must occur before we can guarantee that any return value has data-flow info. </p><dl class="section return"><dt>Returns</dt><dd>the maximum number of passes across all output parameters in <b>this</b> model </dd></dl>

</div>
</div>
<a id="a5bd9f07bc75fc5f2497f1d4de685a8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd9f07bc75fc5f2497f1d4de685a8cf">&#9670;&nbsp;</a></span>hasEffect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint4 ProtoModel::hasEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine side-effect of <b>this</b> on the given memory range. </p>
<p>The model is searched for an <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> matching the given range and the effect type is returned. If there is no <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> or the effect generally isn't known, <a class="el" href="classEffectRecord.html#a9a77875d39274819c56d6e4df5f23ab0a02697f294ad0f4b53317da792c577a10" title="An unknown effect (indicates the absence of an EffectRecord) ">EffectRecord::unknown_effect</a> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> type </dd></dl>

</div>
</div>
<a id="aec744a55c36bed8f08fa923fad80df46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec744a55c36bed8f08fa923fad80df46">&#9670;&nbsp;</a></span>lookupEffect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 ProtoModel::lookupEffect </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classEffectRecord.html">EffectRecord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>efflist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up an effect from the given <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> list. </p>
<p>If a given memory range matches an <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a>, return the effect type. Otherwise return <a class="el" href="classEffectRecord.html#a9a77875d39274819c56d6e4df5f23ab0a02697f294ad0f4b53317da792c577a10" title="An unknown effect (indicates the absence of an EffectRecord) ">EffectRecord::unknown_effect</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">efflist</td><td>is the list of EffectRecords which must be sorted </td></tr>
    <tr><td class="paramname">addr</td><td>is the starting address of the given memory range </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the memory range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classEffectRecord.html" title="Description of the indirect effect a sub-function has on a memory range. ">EffectRecord</a> type </dd></dl>

</div>
</div>
<a id="a1c0e6fe360413702b20cd04367dc477f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0e6fe360413702b20cd04367dc477f">&#9670;&nbsp;</a></span>possibleInputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::possibleInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the given storage location make sense as an input parameter. </p>
<p>Within <b>this</b> model, decide if the storage location can be considered an input parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the location can be a parameter </dd></dl>

</div>
</div>
<a id="a6577cdf023ed6a660ba804e43e356b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6577cdf023ed6a660ba804e43e356b4e">&#9670;&nbsp;</a></span>possibleInputParamWithSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::possibleInputParamWithSlot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>slotsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass-back the slot and slot size for the given storage location as an input parameter. </p>
<p>This checks if the given storage location acts as an input parameter in <b>this</b> model and passes back the number of slots that it occupies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage location </td></tr>
    <tr><td class="paramname">slot</td><td>if the <em>slot</em> number to pass back </td></tr>
    <tr><td class="paramname">slotsize</td><td>is the number of consumed slots to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the location can be a parameter </dd></dl>

</div>
</div>
<a id="aea2696911b81cc71cc68d927d7c02204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2696911b81cc71cc68d927d7c02204">&#9670;&nbsp;</a></span>possibleOutputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::possibleOutputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the given storage location make sense as a return value. </p>
<p>Within <b>this</b> model, decide if the storage location can be considered an output parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the location can be a parameter </dd></dl>

</div>
</div>
<a id="afd3283c9f718ce1e521186810f48ce6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3283c9f718ce1e521186810f48ce6f">&#9670;&nbsp;</a></span>possibleOutputParamWithSlot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::possibleOutputParamWithSlot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>slotsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass-back the slot and slot size for the given storage location as a return value. </p>
<p>This checks if the given storage location acts as an output parameter in <b>this</b> model and passes back the number of slots that it occupies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the storage location </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the storage location </td></tr>
    <tr><td class="paramname">slot</td><td>if the <em>slot</em> number to pass back </td></tr>
    <tr><td class="paramname">slotsize</td><td>is the number of consumed slots to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the location can be a parameter </dd></dl>

</div>
</div>
<a id="a8fe30abbc7fe1c709b1b8fe9c81803b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe30abbc7fe1c709b1b8fe9c81803b8">&#9670;&nbsp;</a></span>restoreXml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProtoModel::restoreXml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore <b>this</b> model from an XML stream. </p>
<p>Read in details about <b>this</b> model from a &lt;prototype&gt; tag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the &lt;prototype&gt; element </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classProtoModelMerged.html#a1c80c617c086b0edacb483f8315d12e9">ProtoModelMerged</a>.</p>

</div>
</div>
<a id="a8c0c20931a1fe2c0d3cf4fb3f8fe7c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0c20931a1fe2c0d3cf4fb3f8fe7c02">&#9670;&nbsp;</a></span>unjustifiedInputParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProtoModel::unjustifiedInputParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given storage location looks like an <em>unjustified</em> input parameter. </p>
<p>The storage for a value may be contained in a normal parameter location but be unjustified within that container, i.e. the least significant bytes are not being used. If this is the case, pass back the full parameter location and return <b>true</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>is the starting address of the given storage </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the given storage </td></tr>
    <tr><td class="paramname">res</td><td>is the full parameter storage to pass back </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the given storage is unjustified within its parameter container </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fspec_8hh_source.html">fspec.hh</a></li>
<li>fspec.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
