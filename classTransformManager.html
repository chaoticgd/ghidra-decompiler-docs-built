<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: TransformManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classTransformManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TransformManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for splitting larger registers holding smaller logical lanes.  
 <a href="classTransformManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="transform_8hh_source.html">transform.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TransformManager:</div>
<div class="dyncontent">
<div class="center"><img src="classTransformManager__inherit__graph.png" border="0" usemap="#TransformManager_inherit__map" alt="Inheritance graph"/></div>
<map name="TransformManager_inherit__map" id="TransformManager_inherit__map">
<area shape="rect" id="node2" href="classLaneDivide.html" title="LaneDivide" alt="" coords="5,80,92,107"/>
<area shape="rect" id="node3" href="classSplitFlow.html" title="Class for splitting up Varnodes that hold 2 logical variables. " alt="" coords="116,80,192,107"/>
<area shape="rect" id="node4" href="classSubfloatFlow.html" title="Class for tracing changes of precision in floating point variables. " alt="" coords="217,80,315,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a686f103eb5e1edbb042659da618f7d72"><td class="memItemLeft" align="right" valign="top"><a id="a686f103eb5e1edbb042659da618f7d72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a686f103eb5e1edbb042659da618f7d72">TransformManager</a> (<a class="el" href="classFuncdata.html">Funcdata</a> *f)</td></tr>
<tr class="memdesc:a686f103eb5e1edbb042659da618f7d72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classConstructor.html">Constructor</a>. <br /></td></tr>
<tr class="separator:a686f103eb5e1edbb042659da618f7d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8b53384ed370e1dc4a3526fed7f62b"><td class="memItemLeft" align="right" valign="top"><a id="aae8b53384ed370e1dc4a3526fed7f62b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#aae8b53384ed370e1dc4a3526fed7f62b">~TransformManager</a> (void)</td></tr>
<tr class="memdesc:aae8b53384ed370e1dc4a3526fed7f62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:aae8b53384ed370e1dc4a3526fed7f62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b948f919c95e2f4a3b000a75d8ffbe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#ae2b948f919c95e2f4a3b000a75d8ffbe">preserveAddress</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 bitSize, int4 lsbOffset) const</td></tr>
<tr class="memdesc:ae2b948f919c95e2f4a3b000a75d8ffbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should the address of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> be preserved when constructing a piece.  <a href="#ae2b948f919c95e2f4a3b000a75d8ffbe">More...</a><br /></td></tr>
<tr class="separator:ae2b948f919c95e2f4a3b000a75d8ffbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea7e510b55fc9043feb2478e004d2e8"><td class="memItemLeft" align="right" valign="top"><a id="a9ea7e510b55fc9043feb2478e004d2e8"></a>
<a class="el" href="classFuncdata.html">Funcdata</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a9ea7e510b55fc9043feb2478e004d2e8">getFunction</a> (void) const</td></tr>
<tr class="memdesc:a9ea7e510b55fc9043feb2478e004d2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function being transformed. <br /></td></tr>
<tr class="separator:a9ea7e510b55fc9043feb2478e004d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854b4855ec3ced3b0afb12fd3e5e9cba"><td class="memItemLeft" align="right" valign="top"><a id="a854b4855ec3ced3b0afb12fd3e5e9cba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a854b4855ec3ced3b0afb12fd3e5e9cba">clearVarnodeMarks</a> (void)</td></tr>
<tr class="memdesc:a854b4855ec3ced3b0afb12fd3e5e9cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear mark for all Varnodes in the map. <br /></td></tr>
<tr class="separator:a854b4855ec3ced3b0afb12fd3e5e9cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee3318c0a3ee71435e402b31a47b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#aaaee3318c0a3ee71435e402b31a47b91">newPreexistingVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:aaaee3318c0a3ee71435e402b31a47b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make placeholder for preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#aaaee3318c0a3ee71435e402b31a47b91">More...</a><br /></td></tr>
<tr class="separator:aaaee3318c0a3ee71435e402b31a47b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1a80d967583d907cf2f27025347f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a2e1a80d967583d907cf2f27025347f51">newUnique</a> (int4 size)</td></tr>
<tr class="memdesc:a2e1a80d967583d907cf2f27025347f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make placeholder for new unique space <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a2e1a80d967583d907cf2f27025347f51">More...</a><br /></td></tr>
<tr class="separator:a2e1a80d967583d907cf2f27025347f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0be0feebea331c9e12fe80e7c2229f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#af0be0feebea331c9e12fe80e7c2229f2">newConstant</a> (int4 size, int4 lsbOffset, uintb val)</td></tr>
<tr class="memdesc:af0be0feebea331c9e12fe80e7c2229f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make placeholder for constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#af0be0feebea331c9e12fe80e7c2229f2">More...</a><br /></td></tr>
<tr class="separator:af0be0feebea331c9e12fe80e7c2229f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab566ae1e823aadc9ce8316ad4bf53a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#ab566ae1e823aadc9ce8316ad4bf53a91">newIop</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:ab566ae1e823aadc9ce8316ad4bf53a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make placeholder for special iop constant.  <a href="#ab566ae1e823aadc9ce8316ad4bf53a91">More...</a><br /></td></tr>
<tr class="separator:ab566ae1e823aadc9ce8316ad4bf53a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208b344db9e2b0f8aae46bbdd1478e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a208b344db9e2b0f8aae46bbdd1478e1b">newPiece</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 bitSize, int4 lsbOffset)</td></tr>
<tr class="memdesc:a208b344db9e2b0f8aae46bbdd1478e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make placeholder for piece of a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a208b344db9e2b0f8aae46bbdd1478e1b">More...</a><br /></td></tr>
<tr class="separator:a208b344db9e2b0f8aae46bbdd1478e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8751dc0fd19ea8264bf93d3bb9b2569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#af8751dc0fd19ea8264bf93d3bb9b2569">newSplit</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;description)</td></tr>
<tr class="memdesc:af8751dc0fd19ea8264bf93d3bb9b2569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into its lanes.  <a href="#af8751dc0fd19ea8264bf93d3bb9b2569">More...</a><br /></td></tr>
<tr class="separator:af8751dc0fd19ea8264bf93d3bb9b2569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ea37c74d10a836ca3e77cf5a065519"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#af7ea37c74d10a836ca3e77cf5a065519">newSplit</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;description, int4 numLanes, int4 startLane)</td></tr>
<tr class="memdesc:af7ea37c74d10a836ca3e77cf5a065519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into a subset of lanes in the given description.  <a href="#af7ea37c74d10a836ca3e77cf5a065519">More...</a><br /></td></tr>
<tr class="separator:af7ea37c74d10a836ca3e77cf5a065519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef51eeb1b0c9e98951427667253561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformOp.html">TransformOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a3aef51eeb1b0c9e98951427667253561">newOpReplace</a> (int4 numParams, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, <a class="el" href="classPcodeOp.html">PcodeOp</a> *replace)</td></tr>
<tr class="memdesc:a3aef51eeb1b0c9e98951427667253561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new placeholder op intended to replace an existing op.  <a href="#a3aef51eeb1b0c9e98951427667253561">More...</a><br /></td></tr>
<tr class="separator:a3aef51eeb1b0c9e98951427667253561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6dc76f33136751101f20f2ab6d2c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformOp.html">TransformOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#acea6dc76f33136751101f20f2ab6d2c7">newOp</a> (int4 numParams, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, <a class="el" href="classTransformOp.html">TransformOp</a> *follow)</td></tr>
<tr class="memdesc:acea6dc76f33136751101f20f2ab6d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new placeholder op that will not replace an existing op.  <a href="#acea6dc76f33136751101f20f2ab6d2c7">More...</a><br /></td></tr>
<tr class="separator:acea6dc76f33136751101f20f2ab6d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd33f9b4ca4c111d912f5c36112c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformOp.html">TransformOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a00cd33f9b4ca4c111d912f5c36112c7c">newPreexistingOp</a> (int4 numParams, <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> opc, <a class="el" href="classPcodeOp.html">PcodeOp</a> *originalOp)</td></tr>
<tr class="memdesc:a00cd33f9b4ca4c111d912f5c36112c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new placeholder op for an existing <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>.  <a href="#a00cd33f9b4ca4c111d912f5c36112c7c">More...</a><br /></td></tr>
<tr class="separator:a00cd33f9b4ca4c111d912f5c36112c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d5897da21f3a9f194769a5f67f638b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a22d5897da21f3a9f194769a5f67f638b">getPreexistingVarnode</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn)</td></tr>
<tr class="memdesc:a22d5897da21f3a9f194769a5f67f638b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (or create) placeholder for preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>.  <a href="#a22d5897da21f3a9f194769a5f67f638b">More...</a><br /></td></tr>
<tr class="separator:a22d5897da21f3a9f194769a5f67f638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dfb3c6f8c822455d41832d06449ecb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#ad4dfb3c6f8c822455d41832d06449ecb">getPiece</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, int4 bitSize, int4 lsbOffset)</td></tr>
<tr class="memdesc:ad4dfb3c6f8c822455d41832d06449ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (or create) placeholder piece.  <a href="#ad4dfb3c6f8c822455d41832d06449ecb">More...</a><br /></td></tr>
<tr class="separator:ad4dfb3c6f8c822455d41832d06449ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890f76d4b44a6f0ccad97533e9fdaf2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a890f76d4b44a6f0ccad97533e9fdaf2d">getSplit</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;description)</td></tr>
<tr class="memdesc:a890f76d4b44a6f0ccad97533e9fdaf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find (or create) placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into its lanes.  <a href="#a890f76d4b44a6f0ccad97533e9fdaf2d">More...</a><br /></td></tr>
<tr class="separator:a890f76d4b44a6f0ccad97533e9fdaf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530bf14b465eefccb3d173fa1796bf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a530bf14b465eefccb3d173fa1796bf4d">getSplit</a> (<a class="el" href="classVarnode.html">Varnode</a> *vn, const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;description, int4 numLanes, int4 startLane)</td></tr>
<tr class="memdesc:a530bf14b465eefccb3d173fa1796bf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find (or create) placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into a subset of lanes from a description.  <a href="#a530bf14b465eefccb3d173fa1796bf4d">More...</a><br /></td></tr>
<tr class="separator:a530bf14b465eefccb3d173fa1796bf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17f9dbe7f73713ed4b5684682169c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#af17f9dbe7f73713ed4b5684682169c0f">opSetInput</a> (<a class="el" href="classTransformOp.html">TransformOp</a> *rop, <a class="el" href="classTransformVar.html">TransformVar</a> *rvn, int4 slot)</td></tr>
<tr class="memdesc:af17f9dbe7f73713ed4b5684682169c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark given variable as input to given op.  <a href="#af17f9dbe7f73713ed4b5684682169c0f">More...</a><br /></td></tr>
<tr class="separator:af17f9dbe7f73713ed4b5684682169c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d67484b4dd36d3fb5ca19697a48f66a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a0d67484b4dd36d3fb5ca19697a48f66a">opSetOutput</a> (<a class="el" href="classTransformOp.html">TransformOp</a> *rop, <a class="el" href="classTransformVar.html">TransformVar</a> *rvn)</td></tr>
<tr class="memdesc:a0d67484b4dd36d3fb5ca19697a48f66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark given variable as output of given op.  <a href="#a0d67484b4dd36d3fb5ca19697a48f66a">More...</a><br /></td></tr>
<tr class="separator:a0d67484b4dd36d3fb5ca19697a48f66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcee2b69511dfb160421566ad1e9ce8"><td class="memItemLeft" align="right" valign="top"><a id="a2dcee2b69511dfb160421566ad1e9ce8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a2dcee2b69511dfb160421566ad1e9ce8">apply</a> (void)</td></tr>
<tr class="memdesc:a2dcee2b69511dfb160421566ad1e9ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the full transform to the function. <br /></td></tr>
<tr class="separator:a2dcee2b69511dfb160421566ad1e9ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3f8190cd08984f5a860b9798105a7c5d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransformManager.html#a3f8190cd08984f5a860b9798105a7c5d">preexistingGuard</a> (int4 slot, <a class="el" href="classTransformVar.html">TransformVar</a> *rvn)</td></tr>
<tr class="memdesc:a3f8190cd08984f5a860b9798105a7c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should newPreexistingOp be called.  <a href="#a3f8190cd08984f5a860b9798105a7c5d">More...</a><br /></td></tr>
<tr class="separator:a3f8190cd08984f5a860b9798105a7c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for splitting larger registers holding smaller logical lanes. </p>
<p>Given a starting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> in the data-flow, look for evidence of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> being interpreted as disjoint logical values concatenated together (lanes). If the interpretation is consistent for data-flow involving the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, split <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and data-flow into explicit operations on the lanes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad4dfb3c6f8c822455d41832d06449ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dfb3c6f8c822455d41832d06449ecb">&#9670;&nbsp;</a></span>getPiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::getPiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>bitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>lsbOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (or create) placeholder piece. </p>
<p>Given a big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, find the placeholder corresponding to the logical value given by a size and significance offset. If it doesn't exist, create it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> containing the logical value </td></tr>
    <tr><td class="paramname">bitSize</td><td>is the size of the logical value in bytes </td></tr>
    <tr><td class="paramname">lsbOffset</td><td>is the signficance offset of the logical value within the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found/created placeholder </dd></dl>

</div>
</div>
<a id="a22d5897da21f3a9f194769a5f67f638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d5897da21f3a9f194769a5f67f638b">&#9670;&nbsp;</a></span>getPreexistingVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::getPreexistingVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (or create) placeholder for preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Check if a placeholder node was created for the preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> for, otherwise create a new one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to find a placeholder for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the placeholder node </dd></dl>

</div>
</div>
<a id="a890f76d4b44a6f0ccad97533e9fdaf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890f76d4b44a6f0ccad97533e9fdaf2d">&#9670;&nbsp;</a></span>getSplit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::getSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find (or create) placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into its lanes. </p>
<p>Given a big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and a lane description, look up placeholders for all its explicit pieces. If they don't exist, create them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">description</td><td>shows how the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of the <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a> placeholders from least to most significant </dd></dl>

</div>
</div>
<a id="a530bf14b465eefccb3d173fa1796bf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530bf14b465eefccb3d173fa1796bf4d">&#9670;&nbsp;</a></span>getSplit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::getSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numLanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>startLane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find (or create) placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into a subset of lanes from a description. </p>
<p>Given a big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and a specific subset of a lane description, look up placeholders for all the explicit pieces. If they don't exist, create them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">description</td><td>describes all the possible lanes </td></tr>
    <tr><td class="paramname">numLanes</td><td>is the number of lanes in the subset </td></tr>
    <tr><td class="paramname">startLane</td><td>is the starting (least significant) lane in the subset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of the <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a> placeholders from least to most significant </dd></dl>

</div>
</div>
<a id="af0be0feebea331c9e12fe80e7c2229f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0be0feebea331c9e12fe80e7c2229f2">&#9670;&nbsp;</a></span>newConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newConstant </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>lsbOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make placeholder for constant <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Create a new constant in the transform view. A piece of an existing constant can be created by giving the existing value and the least significant offset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the size in bytes of the new constant </td></tr>
    <tr><td class="paramname">lsbOffset</td><td>is the number of bits to strip off of the existing value </td></tr>
    <tr><td class="paramname">val</td><td>is the value of the constant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="ab566ae1e823aadc9ce8316ad4bf53a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab566ae1e823aadc9ce8316ad4bf53a91">&#9670;&nbsp;</a></span>newIop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newIop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make placeholder for special iop constant. </p>
<p>Used for creating INDIRECT placeholders. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the original iop parameter to the INDIRECT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="acea6dc76f33136751101f20f2ab6d2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea6dc76f33136751101f20f2ab6d2c7">&#9670;&nbsp;</a></span>newOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformOp.html">TransformOp</a> * TransformManager::newOp </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTransformOp.html">TransformOp</a> *&#160;</td>
          <td class="paramname"><em>follow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new placeholder op that will not replace an existing op. </p>
<p>An uninitialized placeholder for the new op is created. When (if) the new op is created it will not replace an existing op. The op that follows it must be given. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParams</td><td>is the number of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs intended for the new op </td></tr>
    <tr><td class="paramname">opc</td><td>is the opcode of the new op </td></tr>
    <tr><td class="paramname">follow</td><td>is the placeholder for the op that follow the new op when it is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="a3aef51eeb1b0c9e98951427667253561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aef51eeb1b0c9e98951427667253561">&#9670;&nbsp;</a></span>newOpReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformOp.html">TransformOp</a> * TransformManager::newOpReplace </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new placeholder op intended to replace an existing op. </p>
<p>An uninitialized placeholder for the new op is created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParams</td><td>is the number of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs intended for the new op </td></tr>
    <tr><td class="paramname">opc</td><td>is the opcode of the new op </td></tr>
    <tr><td class="paramname">replace</td><td>is the existing op the new op will replace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="a208b344db9e2b0f8aae46bbdd1478e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208b344db9e2b0f8aae46bbdd1478e1b">&#9670;&nbsp;</a></span>newPiece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newPiece </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>bitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>lsbOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make placeholder for piece of a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<p>Given a single logical value within a larger <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>, create a placeholder for that logical value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the large <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">bitSize</td><td>is the size of the logical value in bits </td></tr>
    <tr><td class="paramname">lsbOffset</td><td>is the number of least significant bits of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> dropped from the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the placeholder variable </dd></dl>

</div>
</div>
<a id="a00cd33f9b4ca4c111d912f5c36112c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cd33f9b4ca4c111d912f5c36112c7c">&#9670;&nbsp;</a></span>newPreexistingOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformOp.html">TransformOp</a> * TransformManager::newPreexistingOp </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPcodeOp.html">PcodeOp</a> *&#160;</td>
          <td class="paramname"><em>originalOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new placeholder op for an existing <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a>. </p>
<p>An uninitialized placeholder for the existing op is created. When applied, this causes the op to be transformed as described by the placeholder, changing its opcode and inputs. The output however is unaffected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParams</td><td>is the number of <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> inputs intended for the transformed op </td></tr>
    <tr><td class="paramname">opc</td><td>is the opcode of the transformed op </td></tr>
    <tr><td class="paramname">originalOp</td><td>is the preexisting <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="aaaee3318c0a3ee71435e402b31a47b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaee3318c0a3ee71435e402b31a47b91">&#9670;&nbsp;</a></span>newPreexistingVarnode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newPreexistingVarnode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make placeholder for preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the preexisting <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to create a placeholder for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="af8751dc0fd19ea8264bf93d3bb9b2569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8751dc0fd19ea8264bf93d3bb9b2569">&#9670;&nbsp;</a></span>newSplit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into its lanes. </p>
<p>Given a big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and a lane description, create placeholders for all the explicit pieces that the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will be split into. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">description</td><td>shows how the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of the new <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a> placeholders from least to most significant </dd></dl>

</div>
</div>
<a id="af7ea37c74d10a836ca3e77cf5a065519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ea37c74d10a836ca3e77cf5a065519">&#9670;&nbsp;</a></span>newSplit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLaneDescription.html">LaneDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>numLanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>startLane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create placeholder nodes splitting a <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> into a subset of lanes in the given description. </p>
<p>Given a big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> and specific subset of a lane description, create placeholders for all the explicit pieces that the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will be split into. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the big <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> to split </td></tr>
    <tr><td class="paramname">description</td><td>gives a list of potentional lanes </td></tr>
    <tr><td class="paramname">numLanes</td><td>is the number of lanes in the subset </td></tr>
    <tr><td class="paramname">startLane</td><td>is the starting (least significant) lane in the subset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of the new <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a> placeholders from least to most significant </dd></dl>

</div>
</div>
<a id="a2e1a80d967583d907cf2f27025347f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1a80d967583d907cf2f27025347f51">&#9670;&nbsp;</a></span>newUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransformVar.html">TransformVar</a> * TransformManager::newUnique </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make placeholder for new unique space <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the size in bytes of the new unique <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new placeholder node </dd></dl>

</div>
</div>
<a id="af17f9dbe7f73713ed4b5684682169c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17f9dbe7f73713ed4b5684682169c0f">&#9670;&nbsp;</a></span>opSetInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TransformManager::opSetInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTransformOp.html">TransformOp</a> *&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark given variable as input to given op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>is the given placeholder op whose input is set </td></tr>
    <tr><td class="paramname">rvn</td><td>is the placeholder variable to set </td></tr>
    <tr><td class="paramname">slot</td><td>is the input position to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d67484b4dd36d3fb5ca19697a48f66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d67484b4dd36d3fb5ca19697a48f66a">&#9670;&nbsp;</a></span>opSetOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TransformManager::opSetOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTransformOp.html">TransformOp</a> *&#160;</td>
          <td class="paramname"><em>rop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark given variable as output of given op. </p>
<p>Establish that the given op produces the given var as output. Mark both the <em>output</em> field of the <a class="el" href="classTransformOp.html" title="Placeholder node for PcodeOp that will exist after a transform is applied to a function. ">TransformOp</a> and the <em>def</em> field of the <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rop</td><td>is the given op </td></tr>
    <tr><td class="paramname">rvn</td><td>is the given variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f8190cd08984f5a860b9798105a7c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8190cd08984f5a860b9798105a7c5d">&#9670;&nbsp;</a></span>preexistingGuard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformManager::preexistingGuard </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTransformVar.html">TransformVar</a> *&#160;</td>
          <td class="paramname"><em>rvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should newPreexistingOp be called. </p>
<p><a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> marking prevents duplicate <a class="el" href="classTransformOp.html" title="Placeholder node for PcodeOp that will exist after a transform is applied to a function. ">TransformOp</a> (and <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a>) records from getting created, except in the case of a preexisting <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> with 2 (or more) non-constant inputs. Because the op is preexisting the output <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> doesn't get marked, and the op will be visited for each input. This method determines when the <a class="el" href="classTransformOp.html" title="Placeholder node for PcodeOp that will exist after a transform is applied to a function. ">TransformOp</a> object should be created, with the goal of creating it exactly once even though the op is visited more than once. It currently assumes the <a class="el" href="classPcodeOp.html" title="Lowest level operation of the p-code language. ">PcodeOp</a> is binary, and the slot along which the op is currently visited is passed in, along with the <a class="el" href="classTransformVar.html" title="Placeholder node for Varnode that will exist after a transform is applied to a function. ">TransformVar</a> for the <em>other</em> input. It returns <b>true</b> if the <a class="el" href="classTransformOp.html" title="Placeholder node for PcodeOp that will exist after a transform is applied to a function. ">TransformOp</a> should be created. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>is the incoming slot along which the op is visited </td></tr>
    <tr><td class="paramname">rvn</td><td>is the other input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2b948f919c95e2f4a3b000a75d8ffbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b948f919c95e2f4a3b000a75d8ffbe">&#9670;&nbsp;</a></span>preserveAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformManager::preserveAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVarnode.html">Varnode</a> *&#160;</td>
          <td class="paramname"><em>vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>bitSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>lsbOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should the address of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> be preserved when constructing a piece. </p>
<p>A new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> will be created that represents a logical piece of the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. This routine determines whether the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> should be constructed using storage which overlaps the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a>. It returns <b>true</b> if overlapping storage should be used, <b>false</b> if the new <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> should be constructed as a unique temporary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vn</td><td>is the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
    <tr><td class="paramname">bitSize</td><td>is the logical size of the <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> piece being constructed </td></tr>
    <tr><td class="paramname">lsbOffset</td><td>is the least significant bit position of the logical value within the given <a class="el" href="classVarnode.html" title="A low-level variable or contiguous set of bytes described by an Address and a size. ">Varnode</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if overlapping storage should be used in construction </dd></dl>

<p>Reimplemented in <a class="el" href="classSubfloatFlow.html#a4303e6fb3f259339fc66affdbc4bf613">SubfloatFlow</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="transform_8hh_source.html">transform.hh</a></li>
<li>transform.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
